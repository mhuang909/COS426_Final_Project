{"version":3,"file":"main.1f329ca3da31e13efb96.js","mappings":"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EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC9F,GAAI,EAAG,EA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,EAAG,EAAG,EAAG,EAAG,GAC/F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC/F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC9F,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,E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EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAA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,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC/F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC/F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9F,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EA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","sources":["webpack://lower-case-dashed-name-of-project/webpack/runtime/load script","webpack://lower-case-dashed-name-of-project/./node_modules/earcut/src/earcut.js","webpack://lower-case-dashed-name-of-project/./node_modules/parse-svg-path/index.js","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/node_modules/eventemitter3/index.js","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/cache/Cache.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/resolver/Resolver.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/utils/convertToList.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/colord/index.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/color/Color.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/colord/plugins/names.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/environment/adapter.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/extensions/Extensions.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/filters/FilterEffect.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/matrix/Matrix.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/matrix/groupD8.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/misc/const.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/misc/pow2.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/point/Point.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/init.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/misc/NOOP.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/types.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/container-mixins/cacheAsTextureMixin.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/container-mixins/getGlobalMixin.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/RenderGroup.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/Container.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/culling/cullingMixin.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/utils/multiplyColors.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/shapes/Circle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/shapes/Polygon.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/const.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPixelLine.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/sprite/Sprite.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text/TextStyle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/view/ViewContainer.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/spritesheet/init.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/ticker/TickerListener.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/ticker/Ticker.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/ticker/const.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/const.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/data/removeItems.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/data/uid.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/global/globalHooks.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/logging/deprecation.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/logging/warn.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/path.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/pool/Pool.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/node_modules/eventemitter3/index.mjs","webpack://lower-case-dashed-name-of-project/webpack/bootstrap","webpack://lower-case-dashed-name-of-project/webpack/runtime/define property getters","webpack://lower-case-dashed-name-of-project/webpack/runtime/ensure chunk","webpack://lower-case-dashed-name-of-project/webpack/runtime/get javascript chunk filename","webpack://lower-case-dashed-name-of-project/webpack/runtime/getFullHash","webpack://lower-case-dashed-name-of-project/webpack/runtime/hasOwnProperty shorthand","webpack://lower-case-dashed-name-of-project/webpack/runtime/make namespace object","webpack://lower-case-dashed-name-of-project/webpack/runtime/publicPath","webpack://lower-case-dashed-name-of-project/webpack/runtime/jsonp chunk loading","webpack://lower-case-dashed-name-of-project/./src/components/controller/Controller.ts","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/environment-browser/browserExt.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/app/Application.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text-bitmap/BitmapFont.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontTextParser.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLParser.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text-bitmap/asset/loadBitmapFont.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/BackgroundLoader.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/cache/parsers/cacheTextureArray.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/detections/utils/testImageFormat.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/detections/parsers/detectAvif.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/detections/parsers/detectDefaults.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/detections/utils/testVideoFormat.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/detections/parsers/detectMp4.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/detections/parsers/detectOgv.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/detections/parsers/detectWebm.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/detections/parsers/detectWebp.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/loader/Loader.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/utils/checkDataUrl.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/utils/checkExtension.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/loader/parsers/loadJson.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/loader/parsers/loadTxt.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/loader/parsers/loadWebFont.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/utils/network/getResolutionOfUrl.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/loader/parsers/textures/utils/createTexture.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadSVG.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/loader/workers/WorkerManager.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadTextures.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/loader/parsers/textures/loadVideoTextures.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/resolver/parsers/resolveTextureUrl.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/resolver/parsers/resolveJsonUrl.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/assets/Assets.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/sprite-animated/AnimatedSprite.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text/AbstractText.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/scene/text/Text.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/pixi.js/lib/index.mjs","webpack://lower-case-dashed-name-of-project/./src/assets/characters.png","webpack://lower-case-dashed-name-of-project/./src/assets/atlas.ts","webpack://lower-case-dashed-name-of-project/./src/assets/sheet.png","webpack://lower-case-dashed-name-of-project/./src/components/debug/Rectangle.ts","webpack://lower-case-dashed-name-of-project/./src/components/physics/collisionbody.ts","webpack://lower-case-dashed-name-of-project/./src/components/objects/Platform/Platform.ts","webpack://lower-case-dashed-name-of-project/./src/components/animations/AnimationController.ts","webpack://lower-case-dashed-name-of-project/./node_modules/three/build/three.core.js","webpack://lower-case-dashed-name-of-project/./src/components/physics/physics.ts","webpack://lower-case-dashed-name-of-project/./src/assets/audio/jump_01.mp3","webpack://lower-case-dashed-name-of-project/./src/components/objects/Player/player.ts","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/tilemap/lib/settings.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/tilemap/lib/TilemapGeometry.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/tilemap/lib/TilemapPipe.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/tilemap/lib/TileTextureArray.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/tilemap/lib/gl_tilemap.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/tilemap/lib/gpu_tilemap.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/tilemap/lib/Tilemap.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/tilemap/lib/CompositeTilemap.mjs","webpack://lower-case-dashed-name-of-project/./node_modules/@pixi/tilemap/lib/index.mjs","webpack://lower-case-dashed-name-of-project/./src/assets/audio/spike.mp3","webpack://lower-case-dashed-name-of-project/./src/components/objects/Exit/Exit.ts","webpack://lower-case-dashed-name-of-project/./src/components/scenes/Scene.ts","webpack://lower-case-dashed-name-of-project/./src/assets/scenes/scene0.ts","webpack://lower-case-dashed-name-of-project/./src/assets/scenes/scene1.ts","webpack://lower-case-dashed-name-of-project/./src/assets/scenes/scene2.ts","webpack://lower-case-dashed-name-of-project/./src/assets/scenes/scene3.ts","webpack://lower-case-dashed-name-of-project/./src/components/scenes/SceneManager.ts","webpack://lower-case-dashed-name-of-project/./src/app.ts","webpack://lower-case-dashed-name-of-project/./src/components/scenes/Scenes.ts"],"sourcesContent":["var inProgress = {};\nvar dataWebpackPrefix = \"lower-case-dashed-name-of-project:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\n\n\"use strict\";\nclass CacheClass {\n  constructor() {\n    this._parsers = [];\n    this._cache = /* @__PURE__ */ new Map();\n    this._cacheMap = /* @__PURE__ */ new Map();\n  }\n  /** Clear all entries. */\n  reset() {\n    this._cacheMap.clear();\n    this._cache.clear();\n  }\n  /**\n   * Check if the key exists\n   * @param key - The key to check\n   */\n  has(key) {\n    return this._cache.has(key);\n  }\n  /**\n   * Fetch entry by key\n   * @param key - The key of the entry to get\n   */\n  get(key) {\n    const result = this._cache.get(key);\n    if (!result) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n    }\n    return result;\n  }\n  /**\n   * Set a value by key or keys name\n   * @param key - The key or keys to set\n   * @param value - The value to store in the cache or from which cacheable assets will be derived.\n   */\n  set(key, value) {\n    const keys = convertToList(key);\n    let cacheableAssets;\n    for (let i = 0; i < this.parsers.length; i++) {\n      const parser = this.parsers[i];\n      if (parser.test(value)) {\n        cacheableAssets = parser.getCacheableAssets(keys, value);\n        break;\n      }\n    }\n    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n    if (!cacheableAssets) {\n      keys.forEach((key2) => {\n        cacheableMap.set(key2, value);\n      });\n    }\n    const cacheKeys = [...cacheableMap.keys()];\n    const cachedAssets = {\n      cacheKeys,\n      keys\n    };\n    keys.forEach((key2) => {\n      this._cacheMap.set(key2, cachedAssets);\n    });\n    cacheKeys.forEach((key2) => {\n      const val = cacheableAssets ? cacheableAssets[key2] : value;\n      if (this._cache.has(key2) && this._cache.get(key2) !== val) {\n        warn(\"[Cache] already has key:\", key2);\n      }\n      this._cache.set(key2, cacheableMap.get(key2));\n    });\n  }\n  /**\n   * Remove entry by key\n   *\n   * This function will also remove any associated alias from the cache also.\n   * @param key - The key of the entry to remove\n   */\n  remove(key) {\n    if (!this._cacheMap.has(key)) {\n      warn(`[Assets] Asset id ${key} was not found in the Cache`);\n      return;\n    }\n    const cacheMap = this._cacheMap.get(key);\n    const cacheKeys = cacheMap.cacheKeys;\n    cacheKeys.forEach((key2) => {\n      this._cache.delete(key2);\n    });\n    cacheMap.keys.forEach((key2) => {\n      this._cacheMap.delete(key2);\n    });\n  }\n  /** All loader parsers registered */\n  get parsers() {\n    return this._parsers;\n  }\n}\nconst Cache = new CacheClass();\n\nexport { Cache };\n//# sourceMappingURL=Cache.mjs.map\n","\"use strict\";\nvar LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {\n  LoaderParserPriority2[LoaderParserPriority2[\"Low\"] = 0] = \"Low\";\n  LoaderParserPriority2[LoaderParserPriority2[\"Normal\"] = 1] = \"Normal\";\n  LoaderParserPriority2[LoaderParserPriority2[\"High\"] = 2] = \"High\";\n  return LoaderParserPriority2;\n})(LoaderParserPriority || {});\n\nexport { LoaderParserPriority };\n//# sourceMappingURL=LoaderParser.mjs.map\n","\"use strict\";\nfunction processX(base, ids, depth, result, tags) {\n  const id = ids[depth];\n  for (let i = 0; i < id.length; i++) {\n    const value = id[i];\n    if (depth < ids.length - 1) {\n      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n    } else {\n      tags.push(base.replace(result[depth], value));\n    }\n  }\n}\nfunction createStringVariations(string) {\n  const regex = /\\{(.*?)\\}/g;\n  const result = string.match(regex);\n  const tags = [];\n  if (result) {\n    const ids = [];\n    result.forEach((vars) => {\n      const split = vars.substring(1, vars.length - 1).split(\",\");\n      ids.push(split);\n    });\n    processX(string, ids, 0, result, tags);\n  } else {\n    tags.push(string);\n  }\n  return tags;\n}\n\nexport { createStringVariations };\n//# sourceMappingURL=createStringVariations.mjs.map\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { createStringVariations } from '../utils/createStringVariations.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = convertToList(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      warn(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = convertToList(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = convertToList(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem(bundleIds);\n    bundleIds = convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem(keys);\n    keys = convertToList(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[0];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\nexport { Resolver, getUrlExtension };\n//# sourceMappingURL=Resolver.mjs.map\n","\"use strict\";\nconst convertToList = (input, transform, forceTransform = false) => {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n  if (!transform) {\n    return input;\n  }\n  return input.map((item) => {\n    if (typeof item === \"string\" || forceTransform) {\n      return transform(item);\n    }\n    return item;\n  });\n};\n\nexport { convertToList };\n//# sourceMappingURL=convertToList.mjs.map\n","\"use strict\";\nconst copySearchParams = (targetUrl, sourceUrl) => {\n  const searchParams = sourceUrl.split(\"?\")[1];\n  if (searchParams) {\n    targetUrl += `?${searchParams}`;\n  }\n  return targetUrl;\n};\n\nexport { copySearchParams };\n//# sourceMappingURL=copySearchParams.mjs.map\n","\"use strict\";\nconst isSingleItem = (item) => !Array.isArray(item);\n\nexport { isSingleItem };\n//# sourceMappingURL=isSingleItem.mjs.map\n","var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n","import { extend, colord } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\n\"use strict\";\nextend([namesPlugin]);\nconst _Color = class _Color {\n  /**\n   * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n   */\n  constructor(value = 16777215) {\n    this._value = null;\n    this._components = new Float32Array(4);\n    this._components.fill(1);\n    this._int = 16777215;\n    this.value = value;\n  }\n  /** Get red component (0 - 1) */\n  get red() {\n    return this._components[0];\n  }\n  /** Get green component (0 - 1) */\n  get green() {\n    return this._components[1];\n  }\n  /** Get blue component (0 - 1) */\n  get blue() {\n    return this._components[2];\n  }\n  /** Get alpha component (0 - 1) */\n  get alpha() {\n    return this._components[3];\n  }\n  /**\n   * Set the value, suitable for chaining\n   * @param value\n   * @see Color.value\n   */\n  setValue(value) {\n    this.value = value;\n    return this;\n  }\n  /**\n   * The current color source.\n   *\n   * When setting:\n   * - Setting to an instance of `Color` will copy its color source and components.\n   * - Otherwise, `Color` will try to normalize the color source and set the components.\n   *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n   *\n   * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n   * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n   *\n   * When getting:\n   * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n   *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n   * - Otherwise, the color source used when setting is returned.\n   */\n  set value(value) {\n    if (value instanceof _Color) {\n      this._value = this._cloneSource(value._value);\n      this._int = value._int;\n      this._components.set(value._components);\n    } else if (value === null) {\n      throw new Error(\"Cannot set Color#value to null\");\n    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {\n      this._value = this._cloneSource(value);\n      this._normalize(this._value);\n    }\n  }\n  get value() {\n    return this._value;\n  }\n  /**\n   * Copy a color source internally.\n   * @param value - Color source\n   */\n  _cloneSource(value) {\n    if (typeof value === \"string\" || typeof value === \"number\" || value instanceof Number || value === null) {\n      return value;\n    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n      return value.slice(0);\n    } else if (typeof value === \"object\" && value !== null) {\n      return { ...value };\n    }\n    return value;\n  }\n  /**\n   * Equality check for color sources.\n   * @param value1 - First color source\n   * @param value2 - Second color source\n   * @returns `true` if the color sources are equal, `false` otherwise.\n   */\n  _isSourceEqual(value1, value2) {\n    const type1 = typeof value1;\n    const type2 = typeof value2;\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 === \"number\" || type1 === \"string\" || value1 instanceof Number) {\n      return value1 === value2;\n    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {\n      if (value1.length !== value2.length) {\n        return false;\n      }\n      return value1.every((v, i) => v === value2[i]);\n    } else if (value1 !== null && value2 !== null) {\n      const keys1 = Object.keys(value1);\n      const keys2 = Object.keys(value2);\n      if (keys1.length !== keys2.length) {\n        return false;\n      }\n      return keys1.every((key) => value1[key] === value2[key]);\n    }\n    return value1 === value2;\n  }\n  /**\n   * Convert to a RGBA color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n   */\n  toRgba() {\n    const [r, g, b, a] = this._components;\n    return { r, g, b, a };\n  }\n  /**\n   * Convert to a RGB color object.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n   */\n  toRgb() {\n    const [r, g, b] = this._components;\n    return { r, g, b };\n  }\n  /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n  toRgbaString() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return `rgba(${r},${g},${b},${this.alpha})`;\n  }\n  toUint8RgbArray(out) {\n    const [r, g, b] = this._components;\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out || (out = this._arrayRgb);\n    out[0] = Math.round(r * 255);\n    out[1] = Math.round(g * 255);\n    out[2] = Math.round(b * 255);\n    return out;\n  }\n  toArray(out) {\n    if (!this._arrayRgba) {\n      this._arrayRgba = [];\n    }\n    out || (out = this._arrayRgba);\n    const [r, g, b, a] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    out[3] = a;\n    return out;\n  }\n  toRgbArray(out) {\n    if (!this._arrayRgb) {\n      this._arrayRgb = [];\n    }\n    out || (out = this._arrayRgb);\n    const [r, g, b] = this._components;\n    out[0] = r;\n    out[1] = g;\n    out[2] = b;\n    return out;\n  }\n  /**\n   * Convert to a hexadecimal number.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toNumber(); // returns 16777215\n   */\n  toNumber() {\n    return this._int;\n  }\n  /**\n   * Convert to a BGR number\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n   */\n  toBgrNumber() {\n    const [r, g, b] = this.toUint8RgbArray();\n    return (b << 16) + (g << 8) + r;\n  }\n  /**\n   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n   * @returns {number} - The color as a number in little endian format.\n   */\n  toLittleEndianNumber() {\n    const value = this._int;\n    return (value >> 16) + (value & 65280) + ((value & 255) << 16);\n  }\n  /**\n   * Multiply with another color. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param {ColorSource} value - The color to multiply by.\n   */\n  multiply(value) {\n    const [r, g, b, a] = _Color._temp.setValue(value)._components;\n    this._components[0] *= r;\n    this._components[1] *= g;\n    this._components[2] *= b;\n    this._components[3] *= a;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Converts color to a premultiplied alpha format. This action is destructive, and will\n   * override the previous `value` property to be `null`.\n   * @param alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {Color} - Itself.\n   */\n  premultiply(alpha, applyToRGB = true) {\n    if (applyToRGB) {\n      this._components[0] *= alpha;\n      this._components[1] *= alpha;\n      this._components[2] *= alpha;\n    }\n    this._components[3] = alpha;\n    this._refreshInt();\n    this._value = null;\n    return this;\n  }\n  /**\n   * Premultiplies alpha with current color.\n   * @param {number} alpha - The alpha to multiply by.\n   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n   * @returns {number} tint multiplied by alpha\n   */\n  toPremultiplied(alpha, applyToRGB = true) {\n    if (alpha === 1) {\n      return (255 << 24) + this._int;\n    }\n    if (alpha === 0) {\n      return applyToRGB ? 0 : this._int;\n    }\n    let r = this._int >> 16 & 255;\n    let g = this._int >> 8 & 255;\n    let b = this._int & 255;\n    if (applyToRGB) {\n      r = r * alpha + 0.5 | 0;\n      g = g * alpha + 0.5 | 0;\n      b = b * alpha + 0.5 | 0;\n    }\n    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;\n  }\n  /**\n   * Convert to a hexadecimal string.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHex(); // returns \"#ffffff\"\n   */\n  toHex() {\n    const hexString = this._int.toString(16);\n    return `#${\"000000\".substring(0, 6 - hexString.length) + hexString}`;\n  }\n  /**\n   * Convert to a hexadecimal string with alpha.\n   * @example\n   * import { Color } from 'pixi.js';\n   * new Color('white').toHexa(); // returns \"#ffffffff\"\n   */\n  toHexa() {\n    const alphaValue = Math.round(this._components[3] * 255);\n    const alphaString = alphaValue.toString(16);\n    return this.toHex() + \"00\".substring(0, 2 - alphaString.length) + alphaString;\n  }\n  /**\n   * Set alpha, suitable for chaining.\n   * @param alpha\n   */\n  setAlpha(alpha) {\n    this._components[3] = this._clamp(alpha);\n    return this;\n  }\n  /**\n   * Normalize the input value into rgba\n   * @param value - Input value\n   */\n  _normalize(value) {\n    let r;\n    let g;\n    let b;\n    let a;\n    if ((typeof value === \"number\" || value instanceof Number) && value >= 0 && value <= 16777215) {\n      const int = value;\n      r = (int >> 16 & 255) / 255;\n      g = (int >> 8 & 255) / 255;\n      b = (int & 255) / 255;\n      a = 1;\n    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value);\n      [r, g, b, a = 1] = value;\n    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {\n      value = this._clamp(value, 0, 255);\n      [r, g, b, a = 255] = value;\n      r /= 255;\n      g /= 255;\n      b /= 255;\n      a /= 255;\n    } else if (typeof value === \"string\" || typeof value === \"object\") {\n      if (typeof value === \"string\") {\n        const match = _Color.HEX_PATTERN.exec(value);\n        if (match) {\n          value = `#${match[2]}`;\n        }\n      }\n      const color = colord(value);\n      if (color.isValid()) {\n        ({ r, g, b, a } = color.rgba);\n        r /= 255;\n        g /= 255;\n        b /= 255;\n      }\n    }\n    if (r !== void 0) {\n      this._components[0] = r;\n      this._components[1] = g;\n      this._components[2] = b;\n      this._components[3] = a;\n      this._refreshInt();\n    } else {\n      throw new Error(`Unable to convert color ${value}`);\n    }\n  }\n  /** Refresh the internal color rgb number */\n  _refreshInt() {\n    this._clamp(this._components);\n    const [r, g, b] = this._components;\n    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);\n  }\n  /**\n   * Clamps values to a range. Will override original values\n   * @param value - Value(s) to clamp\n   * @param min - Minimum value\n   * @param max - Maximum value\n   */\n  _clamp(value, min = 0, max = 1) {\n    if (typeof value === \"number\") {\n      return Math.min(Math.max(value, min), max);\n    }\n    value.forEach((v, i) => {\n      value[i] = Math.min(Math.max(v, min), max);\n    });\n    return value;\n  }\n  /**\n   * Check if the value is a color-like object\n   * @param value - Value to check\n   * @returns True if the value is a color-like object\n   * @static\n   * @example\n   * import { Color } from 'pixi.js';\n   * Color.isColorLike('white'); // returns true\n   * Color.isColorLike(0xffffff); // returns true\n   * Color.isColorLike([1, 1, 1]); // returns true\n   */\n  static isColorLike(value) {\n    return typeof value === \"number\" || typeof value === \"string\" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;\n  }\n};\n/**\n * Default Color object for static uses\n * @example\n * import { Color } from 'pixi.js';\n * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n */\n_Color.shared = new _Color();\n/**\n * Temporary Color object for static uses internally.\n * As to not conflict with Color.shared.\n * @ignore\n */\n_Color._temp = new _Color();\n/** Pattern for hex strings */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\nlet Color = _Color;\n\nexport { Color };\n//# sourceMappingURL=Color.mjs.map\n","export default function(e,f){var a={white:\"#ffffff\",bisque:\"#ffe4c4\",blue:\"#0000ff\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",azure:\"#f0ffff\",whitesmoke:\"#f5f5f5\",papayawhip:\"#ffefd5\",plum:\"#dda0dd\",blanchedalmond:\"#ffebcd\",black:\"#000000\",gold:\"#ffd700\",goldenrod:\"#daa520\",gainsboro:\"#dcdcdc\",cornsilk:\"#fff8dc\",cornflowerblue:\"#6495ed\",burlywood:\"#deb887\",aquamarine:\"#7fffd4\",beige:\"#f5f5dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkkhaki:\"#bdb76b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkgrey:\"#a9a9a9\",peachpuff:\"#ffdab9\",darkmagenta:\"#8b008b\",darkred:\"#8b0000\",darkorchid:\"#9932cc\",darkorange:\"#ff8c00\",darkslateblue:\"#483d8b\",gray:\"#808080\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",wheat:\"#f5deb3\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",ghostwhite:\"#f8f8ff\",darkviolet:\"#9400d3\",magenta:\"#ff00ff\",green:\"#008000\",dodgerblue:\"#1e90ff\",grey:\"#808080\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",blueviolet:\"#8a2be2\",forestgreen:\"#228b22\",lawngreen:\"#7cfc00\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",fuchsia:\"#ff00ff\",brown:\"#a52a2a\",maroon:\"#800000\",mediumblue:\"#0000cd\",lightcoral:\"#f08080\",darkturquoise:\"#00ced1\",lightcyan:\"#e0ffff\",ivory:\"#fffff0\",lightyellow:\"#ffffe0\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",linen:\"#faf0e6\",mediumaquamarine:\"#66cdaa\",lemonchiffon:\"#fffacd\",lime:\"#00ff00\",khaki:\"#f0e68c\",mediumseagreen:\"#3cb371\",limegreen:\"#32cd32\",mediumspringgreen:\"#00fa9a\",lightskyblue:\"#87cefa\",lightblue:\"#add8e6\",midnightblue:\"#191970\",lightpink:\"#ffb6c1\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",mintcream:\"#f5fffa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",navajowhite:\"#ffdead\",navy:\"#000080\",mediumvioletred:\"#c71585\",powderblue:\"#b0e0e6\",palegoldenrod:\"#eee8aa\",oldlace:\"#fdf5e6\",paleturquoise:\"#afeeee\",mediumturquoise:\"#48d1cc\",mediumorchid:\"#ba55d3\",rebeccapurple:\"#663399\",lightsteelblue:\"#b0c4de\",mediumslateblue:\"#7b68ee\",thistle:\"#d8bfd8\",tan:\"#d2b48c\",orchid:\"#da70d6\",mediumpurple:\"#9370db\",purple:\"#800080\",pink:\"#ffc0cb\",skyblue:\"#87ceeb\",springgreen:\"#00ff7f\",palegreen:\"#98fb98\",red:\"#ff0000\",yellow:\"#ffff00\",slateblue:\"#6a5acd\",lavenderblush:\"#fff0f5\",peru:\"#cd853f\",palevioletred:\"#db7093\",violet:\"#ee82ee\",teal:\"#008080\",slategray:\"#708090\",slategrey:\"#708090\",aliceblue:\"#f0f8ff\",darkseagreen:\"#8fbc8f\",darkolivegreen:\"#556b2f\",greenyellow:\"#adff2f\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",tomato:\"#ff6347\",silver:\"#c0c0c0\",sienna:\"#a0522d\",lavender:\"#e6e6fa\",lightgreen:\"#90ee90\",orange:\"#ffa500\",orangered:\"#ff4500\",steelblue:\"#4682b4\",royalblue:\"#4169e1\",turquoise:\"#40e0d0\",yellowgreen:\"#9acd32\",salmon:\"#fa8072\",saddlebrown:\"#8b4513\",sandybrown:\"#f4a460\",rosybrown:\"#bc8f8f\",darksalmon:\"#e9967a\",lightgoldenrodyellow:\"#fafad2\",snow:\"#fffafa\",lightgrey:\"#d3d3d3\",lightgray:\"#d3d3d3\",dimgray:\"#696969\",dimgrey:\"#696969\",olivedrab:\"#6b8e23\",olive:\"#808000\"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return\"transparent\";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b=\"black\";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d=\"transparent\"===r?\"#0000\":a[r];return d?new e(d).toRgb():null},\"name\"])}\n","import { BrowserAdapter } from '../environment-browser/BrowserAdapter.mjs';\n\n\"use strict\";\nlet currentAdapter = BrowserAdapter;\nconst DOMAdapter = {\n  /**\n   * Returns the current adapter.\n   * @returns {environment.Adapter} The current adapter.\n   */\n  get() {\n    return currentAdapter;\n  },\n  /**\n   * Sets the current adapter.\n   * @param adapter - The new adapter.\n   */\n  set(adapter) {\n    currentAdapter = adapter;\n  }\n};\n\nexport { DOMAdapter };\n//# sourceMappingURL=adapter.mjs.map\n","\"use strict\";\nconst BrowserAdapter = {\n  createCanvas: (width, height) => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  },\n  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n  getWebGLRenderingContext: () => WebGLRenderingContext,\n  getNavigator: () => navigator,\n  getBaseUrl: () => document.baseURI ?? window.location.href,\n  getFontFaceSet: () => document.fonts,\n  fetch: (url, options) => fetch(url, options),\n  parseXML: (xml) => {\n    const parser = new DOMParser();\n    return parser.parseFromString(xml, \"text/xml\");\n  }\n};\n\nexport { BrowserAdapter };\n//# sourceMappingURL=BrowserAdapter.mjs.map\n","\"use strict\";\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2[\"Application\"] = \"application\";\n  ExtensionType2[\"WebGLPipes\"] = \"webgl-pipes\";\n  ExtensionType2[\"WebGLPipesAdaptor\"] = \"webgl-pipes-adaptor\";\n  ExtensionType2[\"WebGLSystem\"] = \"webgl-system\";\n  ExtensionType2[\"WebGPUPipes\"] = \"webgpu-pipes\";\n  ExtensionType2[\"WebGPUPipesAdaptor\"] = \"webgpu-pipes-adaptor\";\n  ExtensionType2[\"WebGPUSystem\"] = \"webgpu-system\";\n  ExtensionType2[\"CanvasSystem\"] = \"canvas-system\";\n  ExtensionType2[\"CanvasPipesAdaptor\"] = \"canvas-pipes-adaptor\";\n  ExtensionType2[\"CanvasPipes\"] = \"canvas-pipes\";\n  ExtensionType2[\"Asset\"] = \"asset\";\n  ExtensionType2[\"LoadParser\"] = \"load-parser\";\n  ExtensionType2[\"ResolveParser\"] = \"resolve-parser\";\n  ExtensionType2[\"CacheParser\"] = \"cache-parser\";\n  ExtensionType2[\"DetectionParser\"] = \"detection-parser\";\n  ExtensionType2[\"MaskEffect\"] = \"mask-effect\";\n  ExtensionType2[\"BlendMode\"] = \"blend-mode\";\n  ExtensionType2[\"TextureSource\"] = \"texture-source\";\n  ExtensionType2[\"Environment\"] = \"environment\";\n  ExtensionType2[\"ShapeBuilder\"] = \"shape-builder\";\n  ExtensionType2[\"Batcher\"] = \"batcher\";\n  return ExtensionType2;\n})(ExtensionType || {});\nconst normalizeExtension = (ext) => {\n  if (typeof ext === \"function\" || typeof ext === \"object\" && ext.extension) {\n    if (!ext.extension) {\n      throw new Error(\"Extension class must have an extension object\");\n    }\n    const metadata = typeof ext.extension !== \"object\" ? { type: ext.extension } : ext.extension;\n    ext = { ...metadata, ref: ext };\n  }\n  if (typeof ext === \"object\") {\n    ext = { ...ext };\n  } else {\n    throw new Error(\"Invalid extension type\");\n  }\n  if (typeof ext.type === \"string\") {\n    ext.type = [ext.type];\n  }\n  return ext;\n};\nconst normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;\nconst extensions = {\n  /** @ignore */\n  _addHandlers: {},\n  /** @ignore */\n  _removeHandlers: {},\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {extensions} For chaining.\n   */\n  remove(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n    });\n    return this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {extensions} For chaining.\n   */\n  add(...extensions2) {\n    extensions2.map(normalizeExtension).forEach((ext) => {\n      ext.type.forEach((type) => {\n        const handlers = this._addHandlers;\n        const queue = this._queue;\n        if (!handlers[type]) {\n          queue[type] = queue[type] || [];\n          queue[type]?.push(ext);\n        } else {\n          handlers[type]?.(ext);\n        }\n      });\n    });\n    return this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n   * @returns {extensions} For chaining.\n   */\n  handle(type, onAdd, onRemove) {\n    const addHandlers = this._addHandlers;\n    const removeHandlers = this._removeHandlers;\n    if (addHandlers[type] || removeHandlers[type]) {\n      throw new Error(`Extension type ${type} already has a handler`);\n    }\n    addHandlers[type] = onAdd;\n    removeHandlers[type] = onRemove;\n    const queue = this._queue;\n    if (queue[type]) {\n      queue[type]?.forEach((ext) => onAdd(ext));\n      delete queue[type];\n    }\n    return this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {extensions} For chaining.\n   */\n  handleByMap(type, map) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (extension.name) {\n          map[extension.name] = extension.ref;\n        }\n      },\n      (extension) => {\n        if (extension.name) {\n          delete map[extension.name];\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions with a `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The array of named extensions.\n   * @param defaultPriority - Fallback priority if none is defined.\n   * @returns {extensions} For chaining.\n   */\n  handleByNamedList(type, map, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index >= 0)\n          return;\n        map.push({ name: extension.name, value: extension.ref });\n        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));\n      },\n      (extension) => {\n        const index = map.findIndex((item) => item.name === extension.name);\n        if (index !== -1) {\n          map.splice(index, 1);\n        }\n      }\n    );\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @param defaultPriority - The default priority to use if none is specified.\n   * @returns {extensions} For chaining.\n   */\n  handleByList(type, list, defaultPriority = -1) {\n    return this.handle(\n      type,\n      (extension) => {\n        if (list.includes(extension.ref)) {\n          return;\n        }\n        list.push(extension.ref);\n        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n      },\n      (extension) => {\n        const index = list.indexOf(extension.ref);\n        if (index !== -1) {\n          list.splice(index, 1);\n        }\n      }\n    );\n  }\n};\n\nexport { ExtensionType, extensions, normalizeExtensionPriority };\n//# sourceMappingURL=Extensions.mjs.map\n","\"use strict\";\nclass FilterEffect {\n  constructor() {\n    /** the pipe that knows how to handle this effect */\n    this.pipe = \"filter\";\n    /** the priority of this effect */\n    this.priority = 1;\n  }\n  destroy() {\n    for (let i = 0; i < this.filters.length; i++) {\n      this.filters[i].destroy();\n    }\n    this.filters = null;\n    this.filterArea = null;\n  }\n}\n\nexport { FilterEffect };\n//# sourceMappingURL=FilterEffect.mjs.map\n","import { PI_2 } from '../misc/const.mjs';\nimport { Point } from '../point/Point.mjs';\n\n\"use strict\";\nclass Matrix {\n  /**\n   * @param a - x scale\n   * @param b - y skew\n   * @param c - x skew\n   * @param d - y scale\n   * @param tx - x translation\n   * @param ty - y translation\n   */\n  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    this.array = null;\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   * @param array - The array that the matrix will be populated from.\n   */\n  fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  }\n  /**\n   * Sets the matrix properties.\n   * @param a - Matrix component\n   * @param b - Matrix component\n   * @param c - Matrix component\n   * @param d - Matrix component\n   * @param tx - Matrix component\n   * @param ty - Matrix component\n   * @returns This matrix. Good for chaining method calls.\n   */\n  set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  }\n  /**\n   * Creates an array from the current Matrix object.\n   * @param transpose - Whether we need to transpose the matrix or not\n   * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @returns The newly created array which contains the matrix\n   */\n  toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n    const array = out || this.array;\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n    return array;\n  }\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, transformed through this matrix\n   */\n  apply(pos, newPos) {\n    newPos = newPos || new Point();\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  }\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   * @param pos - The origin\n   * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @returns {Point} The new point, inverse-transformed through this matrix\n   */\n  applyInverse(pos, newPos) {\n    newPos = newPos || new Point();\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const tx = this.tx;\n    const ty = this.ty;\n    const id = 1 / (a * d + c * -b);\n    const x = pos.x;\n    const y = pos.y;\n    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;\n    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;\n    return newPos;\n  }\n  /**\n   * Translates the matrix on the x and y.\n   * @param x - How much to translate x by\n   * @param y - How much to translate y by\n   * @returns This matrix. Good for chaining method calls.\n   */\n  translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  }\n  /**\n   * Applies a scale transformation to the matrix.\n   * @param x - The amount to scale horizontally\n   * @param y - The amount to scale vertically\n   * @returns This matrix. Good for chaining method calls.\n   */\n  scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the matrix.\n   * @param angle - The angle in radians.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  rotate(angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const a1 = this.a;\n    const c1 = this.c;\n    const tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  }\n  /**\n   * Appends the given Matrix to this Matrix.\n   * @param matrix - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  append(matrix) {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  }\n  /**\n   * Appends two matrix's and sets the result to this matrix. AB = A * B\n   * @param a - The matrix to append.\n   * @param b - The matrix to append.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  appendFrom(a, b) {\n    const a1 = a.a;\n    const b1 = a.b;\n    const c1 = a.c;\n    const d1 = a.d;\n    const tx = a.tx;\n    const ty = a.ty;\n    const a2 = b.a;\n    const b2 = b.b;\n    const c2 = b.c;\n    const d2 = b.d;\n    this.a = a1 * a2 + b1 * c2;\n    this.b = a1 * b2 + b1 * d2;\n    this.c = c1 * a2 + d1 * c2;\n    this.d = c1 * b2 + d1 * d2;\n    this.tx = tx * a2 + ty * c2 + b.tx;\n    this.ty = tx * b2 + ty * d2 + b.ty;\n    return this;\n  }\n  /**\n   * Sets the matrix based on all the available properties\n   * @param x - Position on the x axis\n   * @param y - Position on the y axis\n   * @param pivotX - Pivot on the x axis\n   * @param pivotY - Pivot on the y axis\n   * @param scaleX - Scale on the x axis\n   * @param scaleY - Scale on the y axis\n   * @param rotation - Rotation in radians\n   * @param skewX - Skew on the x axis\n   * @param skewY - Skew on the y axis\n   * @returns This matrix. Good for chaining method calls.\n   */\n  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  }\n  /**\n   * Prepends the given Matrix to this Matrix.\n   * @param matrix - The matrix to prepend\n   * @returns This matrix. Good for chaining method calls.\n   */\n  prepend(matrix) {\n    const tx1 = this.tx;\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      const a1 = this.a;\n      const c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  }\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   * @param transform - The transform to apply the properties to.\n   * @returns The transform with the newly applied properties\n   */\n  decompose(transform) {\n    const a = this.a;\n    const b = this.b;\n    const c = this.c;\n    const d = this.d;\n    const pivot = transform.pivot;\n    const skewX = -Math.atan2(-c, d);\n    const skewY = Math.atan2(b, a);\n    const delta = Math.abs(skewX + skewY);\n    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    }\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d);\n    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);\n    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);\n    return transform;\n  }\n  /**\n   * Inverts this matrix\n   * @returns This matrix. Good for chaining method calls.\n   */\n  invert() {\n    const a1 = this.a;\n    const b1 = this.b;\n    const c1 = this.c;\n    const d1 = this.d;\n    const tx1 = this.tx;\n    const n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  }\n  /** Checks if this matrix is an identity matrix */\n  isIdentity() {\n    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n  }\n  /**\n   * Resets this Matrix to an identity (default) matrix.\n   * @returns This matrix. Good for chaining method calls.\n   */\n  identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  }\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   * @returns A copy of this matrix. Good for chaining method calls.\n   */\n  clone() {\n    const matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   * @param matrix - The matrix to copy to.\n   * @returns The matrix given in parameter with its values updated.\n   */\n  copyTo(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  }\n  /**\n   * Changes the values of the matrix to be the same as the ones in given matrix\n   * @param matrix - The matrix to copy from.\n   * @returns this\n   */\n  copyFrom(matrix) {\n    this.a = matrix.a;\n    this.b = matrix.b;\n    this.c = matrix.c;\n    this.d = matrix.d;\n    this.tx = matrix.tx;\n    this.ty = matrix.ty;\n    return this;\n  }\n  /**\n   * check to see if two matrices are the same\n   * @param matrix - The matrix to compare to.\n   */\n  equals(matrix) {\n    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;\n  }\n  toString() {\n    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n  }\n  /**\n   * A default (identity) matrix.\n   *\n   * This is a shared object, if you want to modify it consider creating a new `Matrix`\n   * @readonly\n   */\n  static get IDENTITY() {\n    return identityMatrix.identity();\n  }\n  /**\n   * A static Matrix that can be used to avoid creating new objects.\n   * Will always ensure the matrix is reset to identity when requested.\n   * Use this object for fast but temporary calculations, as it may be mutated later on.\n   * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n   * @readonly\n   */\n  static get shared() {\n    return tempMatrix.identity();\n  }\n}\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n\nexport { Matrix };\n//# sourceMappingURL=Matrix.mjs.map\n","import { Matrix } from './Matrix.mjs';\n\n\"use strict\";\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst rotationCayley = [];\nconst rotationMatrices = [];\nconst signum = Math.sign;\nfunction init() {\n  for (let i = 0; i < 16; i++) {\n    const row = [];\n    rotationCayley.push(row);\n    for (let j = 0; j < 16; j++) {\n      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n      for (let k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n  for (let i = 0; i < 16; i++) {\n    const mat = new Matrix();\n    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n    rotationMatrices.push(mat);\n  }\n}\ninit();\nconst groupD8 = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0       | East      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45     | Southeast |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90     | South     |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135    | Southwest |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180     | West      |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135/225 | Northwest    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90/270  | North        |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45/315  | Northeast    |\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof maths.groupD8\n   * @constant {GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: (ind) => ux[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: (ind) => uy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: (ind) => vx[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} ind - sprite rotation angle.\n   * @returns {GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: (ind) => vy[ind],\n  /**\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: (rotation) => {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n    return -rotation & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {GD8Symmetry} Composed operation\n   */\n  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],\n  /**\n   * Reverse of `add`.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotationSecond - Second operation\n   * @param {GD8Symmetry} rotationFirst - First operation\n   * @returns {GD8Symmetry} Result\n   */\n  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof maths.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: (rotation) => rotation ^ 4,\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof maths.groupD8\n   * @param {GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: (rotation) => (rotation & 3) === 2,\n  // rotation % 4 === 2\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof maths.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: (dx, dy) => {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return groupD8.S;\n      }\n      return groupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return groupD8.E;\n      }\n      return groupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return groupD8.SE;\n      }\n      return groupD8.SW;\n    } else if (dx > 0) {\n      return groupD8.NE;\n    }\n    return groupD8.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof maths.groupD8\n   * @param {Matrix} matrix - sprite world matrix\n   * @param {GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {\n    const mat = rotationMatrices[groupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\n\nexport { groupD8 };\n//# sourceMappingURL=groupD8.mjs.map\n","\"use strict\";\nconst PI_2 = Math.PI * 2;\nconst RAD_TO_DEG = 180 / Math.PI;\nconst DEG_TO_RAD = Math.PI / 180;\n\nexport { DEG_TO_RAD, PI_2, RAD_TO_DEG };\n//# sourceMappingURL=const.mjs.map\n","\"use strict\";\nfunction nextPow2(v) {\n  v += v === 0 ? 1 : 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\nfunction isPow2(v) {\n  return !(v & v - 1) && !!v;\n}\nfunction log2(v) {\n  let r = (v > 65535 ? 1 : 0) << 4;\n  v >>>= r;\n  let shift = (v > 255 ? 1 : 0) << 3;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 15 ? 1 : 0) << 2;\n  v >>>= shift;\n  r |= shift;\n  shift = (v > 3 ? 1 : 0) << 1;\n  v >>>= shift;\n  r |= shift;\n  return r | v >> 1;\n}\n\nexport { isPow2, log2, nextPow2 };\n//# sourceMappingURL=pow2.mjs.map\n","\"use strict\";\nclass ObservablePoint {\n  /**\n   * Creates a new `ObservablePoint`\n   * @param observer - Observer to pass to listen for change events.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(observer, x, y) {\n    this._x = x || 0;\n    this._y = y || 0;\n    this._observer = observer;\n  }\n  /**\n   * Creates a clone of this point.\n   * @param observer - Optional observer to pass to the new observable point.\n   * @returns a copy of this observable point\n   */\n  clone(observer) {\n    return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=x] - position of the point on the y axis\n   * @returns The observable point instance itself\n   */\n  set(x = 0, y = x) {\n    if (this._x !== x || this._y !== y) {\n      this._x = x;\n      this._y = y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies x and y from the given point (`p`)\n   * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n   * @returns The observable point instance itself\n   */\n  copyFrom(p) {\n    if (this._x !== p.x || this._y !== p.y) {\n      this._x = p.x;\n      this._y = p.y;\n      this._observer._onUpdate(this);\n    }\n    return this;\n  }\n  /**\n   * Copies this point's x and y into that of the given point (`p`)\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this._x, this._y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this._x && p.y === this._y;\n  }\n  toString() {\n    return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n  }\n  /** Position of the observable point on the x axis. */\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    if (this._x !== value) {\n      this._x = value;\n      this._observer._onUpdate(this);\n    }\n  }\n  /** Position of the observable point on the y axis. */\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    if (this._y !== value) {\n      this._y = value;\n      this._observer._onUpdate(this);\n    }\n  }\n}\n\nexport { ObservablePoint };\n//# sourceMappingURL=ObservablePoint.mjs.map\n","\"use strict\";\nclass Point {\n  /**\n   * Creates a new `Point`\n   * @param {number} [x=0] - position of the point on the x axis\n   * @param {number} [y=0] - position of the point on the y axis\n   */\n  constructor(x = 0, y = 0) {\n    /** Position of the point on the x axis */\n    this.x = 0;\n    /** Position of the point on the y axis */\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  /**\n   * Creates a clone of this point\n   * @returns A clone of this point\n   */\n  clone() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Copies `x` and `y` from the given point into this point\n   * @param p - The point to copy from\n   * @returns The point instance itself\n   */\n  copyFrom(p) {\n    this.set(p.x, p.y);\n    return this;\n  }\n  /**\n   * Copies this point's x and y into the given point (`p`).\n   * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n   * @returns The point (`p`) with values updated\n   */\n  copyTo(p) {\n    p.set(this.x, this.y);\n    return p;\n  }\n  /**\n   * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n   * @param p - The point to check\n   * @returns Returns `true` if both `x` and `y` are equal\n   */\n  equals(p) {\n    return p.x === this.x && p.y === this.y;\n  }\n  /**\n   * Sets the point to a new `x` and `y` position.\n   * If `y` is omitted, both `x` and `y` will be set to `x`.\n   * @param {number} [x=0] - position of the point on the `x` axis\n   * @param {number} [y=x] - position of the point on the `y` axis\n   * @returns The point instance itself\n   */\n  set(x = 0, y = x) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  toString() {\n    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n  }\n  /**\n   * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n   * @readonly\n   */\n  static get shared() {\n    tempPoint.x = 0;\n    tempPoint.y = 0;\n    return tempPoint;\n  }\n}\nconst tempPoint = new Point();\n\nexport { Point };\n//# sourceMappingURL=Point.mjs.map\n","import { Point } from '../point/Point.mjs';\n\n\"use strict\";\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\nclass Rectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rectangle\n   * @param width - The overall width of the rectangle\n   * @param height - The overall height of the rectangle\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    this.type = \"rectangle\";\n    this.x = Number(x);\n    this.y = Number(y);\n    this.width = Number(width);\n    this.height = Number(height);\n  }\n  /** Returns the left edge of the rectangle. */\n  get left() {\n    return this.x;\n  }\n  /** Returns the right edge of the rectangle. */\n  get right() {\n    return this.x + this.width;\n  }\n  /** Returns the top edge of the rectangle. */\n  get top() {\n    return this.y;\n  }\n  /** Returns the bottom edge of the rectangle. */\n  get bottom() {\n    return this.y + this.height;\n  }\n  /** Determines whether the Rectangle is empty. */\n  isEmpty() {\n    return this.left === this.right || this.top === this.bottom;\n  }\n  /** A constant empty rectangle. This is a new object every time the property is accessed */\n  static get EMPTY() {\n    return new Rectangle(0, 0, 0, 0);\n  }\n  /**\n   * Creates a clone of this Rectangle\n   * @returns a copy of the rectangle\n   */\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n  /**\n   * Converts a Bounds object to a Rectangle object.\n   * @param bounds - The bounds to copy and convert to a rectangle.\n   * @returns Returns itself.\n   */\n  copyFromBounds(bounds) {\n    this.x = bounds.minX;\n    this.y = bounds.minY;\n    this.width = bounds.maxX - bounds.minX;\n    this.height = bounds.maxY - bounds.minY;\n    return this;\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rectangle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Rectangle\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x < this.x + this.width) {\n      if (y >= this.y && y < this.y + this.height) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(x, y, strokeWidth) {\n    const { width, height } = this;\n    if (width <= 0 || height <= 0)\n      return false;\n    const _x = this.x;\n    const _y = this.y;\n    const outerLeft = _x - strokeWidth / 2;\n    const outerRight = _x + width + strokeWidth / 2;\n    const outerTop = _y - strokeWidth / 2;\n    const outerBottom = _y + height + strokeWidth / 2;\n    const innerLeft = _x + strokeWidth / 2;\n    const innerRight = _x + width - strokeWidth / 2;\n    const innerTop = _y + strokeWidth / 2;\n    const innerBottom = _y + height - strokeWidth / 2;\n    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n  }\n  /**\n   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n   * Returns true only if the area of the intersection is >0, this means that Rectangles\n   * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n   * (width or height equal to zero) can't intersect any other rectangle.\n   * @param {Rectangle} other - The Rectangle to intersect with `this`.\n   * @param {Matrix} transform - The transformation matrix of `other`.\n   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n   */\n  intersects(other, transform) {\n    if (!transform) {\n      const x02 = this.x < other.x ? other.x : this.x;\n      const x12 = this.right > other.right ? other.right : this.right;\n      if (x12 <= x02) {\n        return false;\n      }\n      const y02 = this.y < other.y ? other.y : this.y;\n      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;\n      return y12 > y02;\n    }\n    const x0 = this.left;\n    const x1 = this.right;\n    const y0 = this.top;\n    const y1 = this.bottom;\n    if (x1 <= x0 || y1 <= y0) {\n      return false;\n    }\n    const lt = tempPoints[0].set(other.left, other.top);\n    const lb = tempPoints[1].set(other.left, other.bottom);\n    const rt = tempPoints[2].set(other.right, other.top);\n    const rb = tempPoints[3].set(other.right, other.bottom);\n    if (rt.x <= lt.x || lb.y <= lt.y) {\n      return false;\n    }\n    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);\n    if (s === 0) {\n      return false;\n    }\n    transform.apply(lt, lt);\n    transform.apply(lb, lb);\n    transform.apply(rt, rt);\n    transform.apply(rb, rb);\n    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {\n      return false;\n    }\n    const nx = s * (lb.y - lt.y);\n    const ny = s * (lt.x - lb.x);\n    const n00 = nx * x0 + ny * y0;\n    const n10 = nx * x1 + ny * y0;\n    const n01 = nx * x0 + ny * y1;\n    const n11 = nx * x1 + ny * y1;\n    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {\n      return false;\n    }\n    const mx = s * (lt.y - rt.y);\n    const my = s * (rt.x - lt.x);\n    const m00 = mx * x0 + my * y0;\n    const m10 = mx * x1 + my * y0;\n    const m01 = mx * x0 + my * y1;\n    const m11 = mx * x1 + my * y1;\n    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pads the rectangle making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   * @returns Returns itself.\n   */\n  pad(paddingX = 0, paddingY = paddingX) {\n    this.x -= paddingX;\n    this.y -= paddingY;\n    this.width += paddingX * 2;\n    this.height += paddingY * 2;\n    return this;\n  }\n  /**\n   * Fits this rectangle around the passed one.\n   * @param rectangle - The rectangle to fit.\n   * @returns Returns itself.\n   */\n  fit(rectangle) {\n    const x1 = Math.max(this.x, rectangle.x);\n    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.max(this.y, rectangle.y);\n    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = Math.max(x2 - x1, 0);\n    this.y = y1;\n    this.height = Math.max(y2 - y1, 0);\n    return this;\n  }\n  /**\n   * Enlarges rectangle that way its corners lie on grid\n   * @param resolution - resolution\n   * @param eps - precision\n   * @returns Returns itself.\n   */\n  ceil(resolution = 1, eps = 1e-3) {\n    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n    this.x = Math.floor((this.x + eps) * resolution) / resolution;\n    this.y = Math.floor((this.y + eps) * resolution) / resolution;\n    this.width = x2 - this.x;\n    this.height = y2 - this.y;\n    return this;\n  }\n  /**\n   * Enlarges this rectangle to include the passed rectangle.\n   * @param rectangle - The rectangle to include.\n   * @returns Returns itself.\n   */\n  enlarge(rectangle) {\n    const x1 = Math.min(this.x, rectangle.x);\n    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n    const y1 = Math.min(this.y, rectangle.y);\n    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n    this.x = x1;\n    this.width = x2 - x1;\n    this.y = y1;\n    this.height = y2 - y1;\n    return this;\n  }\n  /**\n   * Returns the framing rectangle of the rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.copyFrom(this);\n    return out;\n  }\n  toString() {\n    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n  }\n}\n\nexport { Rectangle };\n//# sourceMappingURL=Rectangle.mjs.map\n","\"use strict\";\nconst fragTemplate = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(\"\\n\");\nfunction generateIfTestSrc(maxIfs) {\n  let src = \"\";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += \"\\nelse \";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  try {\n    while (true) {\n      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n      gl.shaderSource(shader, fragmentSrc);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        maxIfs = maxIfs / 2 | 0;\n      } else {\n        break;\n      }\n    }\n  } finally {\n    gl.deleteShader(shader);\n  }\n  return maxIfs;\n}\n\nexport { checkMaxIfStatementsInShader };\n//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map\n","import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext.mjs';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader.mjs';\n\n\"use strict\";\nlet maxTexturesPerBatchCache = null;\nfunction getMaxTexturesPerBatch() {\n  if (maxTexturesPerBatchCache)\n    return maxTexturesPerBatchCache;\n  const gl = getTestContext();\n  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n    maxTexturesPerBatchCache,\n    gl\n  );\n  gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n  return maxTexturesPerBatchCache;\n}\n\nexport { getMaxTexturesPerBatch };\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n","import { BindGroup } from '../../renderers/gpu/shader/BindGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\n\n\"use strict\";\nconst cachedGroups = {};\nfunction getTextureBatchBindGroup(textures, size) {\n  let uid = 2166136261;\n  for (let i = 0; i < size; i++) {\n    uid ^= textures[i].uid;\n    uid = Math.imul(uid, 16777619);\n    uid >>>= 0;\n  }\n  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\nlet maxTextures = 0;\nfunction generateTextureBatchBindGroup(textures, size, key) {\n  const bindGroupResources = {};\n  let bindIndex = 0;\n  if (!maxTextures)\n    maxTextures = getMaxTexturesPerBatch();\n  for (let i = 0; i < maxTextures; i++) {\n    const texture = i < size ? textures[i] : Texture.EMPTY.source;\n    bindGroupResources[bindIndex++] = texture.source;\n    bindGroupResources[bindIndex++] = texture.style;\n  }\n  const bindGroup = new BindGroup(bindGroupResources);\n  cachedGroups[key] = bindGroup;\n  return bindGroup;\n}\n\nexport { getTextureBatchBindGroup };\n//# sourceMappingURL=getTextureBatchBindGroup.mjs.map\n","\"use strict\";\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\nexport { BatchTextureArray };\n//# sourceMappingURL=BatchTextureArray.mjs.map\n","import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\n\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.textures = new BatchTextureArray();\n    this.blendMode = \"normal\";\n    this.topology = \"triangle-strip\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nconst batchPool = [];\nlet batchPoolIndex = 0;\nfunction getBatchFromPool() {\n  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\nfunction returnBatchToPool(batch) {\n  batchPool[batchPoolIndex++] = batch;\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    /** unique id for this batcher */\n    this.uid = uid(\"batcher\");\n    /** Indicates whether the batch data has been modified and needs updating. */\n    this.dirty = true;\n    /** The current index of the batch being processed. */\n    this.batchIndex = 0;\n    /** An array of all batches created during the current rendering process. */\n    this.batches = [];\n    this._elements = [];\n    _Batcher.defaultOptions.maxTextures = _Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n    this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n    this.indexBuffer = new Uint16Array(indicesInitialSize);\n    this.maxTextures = maxTextures;\n  }\n  begin() {\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batchIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject._indexStart = this.indexSize;\n    batchableObject._attributeStart = this.attributeSize;\n    batchableObject._batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.attributeSize * this.vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject._textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    const attributeBuffer = this.attributeBuffer;\n    if (batchableObject.packAsQuad) {\n      this.packQuadAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    } else {\n      this.packAttributes(\n        batchableObject,\n        attributeBuffer.float32View,\n        attributeBuffer.uint32View,\n        batchableObject._attributeStart,\n        batchableObject._textureId\n      );\n    }\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    if (!elements[this.elementStart])\n      return;\n    let batch = getBatchFromPool();\n    let textureBatch = batch.textures;\n    textureBatch.clear();\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    let topology = firstElement.topology;\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const indexBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    const maxTextures = this.maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n      if (source._batchTick === BATCH_TICK && !breakRequired) {\n        element._textureId = source._textureBindLocation;\n        size += element.indexSize;\n        if (element.packAsQuad) {\n          this.packQuadAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packQuadIndex(\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        } else {\n          this.packAttributes(\n            element,\n            f32,\n            u32,\n            element._attributeStart,\n            element._textureId\n          );\n          this.packIndex(\n            element,\n            indexBuffer,\n            element._indexStart,\n            element._attributeStart / this.vertexSize\n          );\n        }\n        element._batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || breakRequired) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          topology,\n          instructionSet,\n          action\n        );\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        topology = element.topology;\n        batch = getBatchFromPool();\n        textureBatch = batch.textures;\n        textureBatch.clear();\n        ++BATCH_TICK;\n      }\n      element._textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element._batch = batch;\n      size += element.indexSize;\n      if (element.packAsQuad) {\n        this.packQuadAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packQuadIndex(\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      } else {\n        this.packAttributes(\n          element,\n          f32,\n          u32,\n          element._attributeStart,\n          element._textureId\n        );\n        this.packIndex(\n          element,\n          indexBuffer,\n          element._indexStart,\n          element._attributeStart / this.vertexSize\n        );\n      }\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        topology,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.bindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.topology = topology;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    this.batches[this.batchIndex++] = batch;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  packQuadIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  packIndex(element, indexBuffer, index, indicesOffset) {\n    const indices = element.indices;\n    const size = element.indexSize;\n    const indexOffset = element.indexOffset;\n    const attributeOffset = element.attributeOffset;\n    for (let i = 0; i < size; i++) {\n      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n    }\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i]._batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  maxTextures: null,\n  attributesInitialSize: 4,\n  indicesInitialSize: 6\n};\nlet Batcher = _Batcher;\n\nexport { Batch, Batcher };\n//# sourceMappingURL=Batcher.mjs.map\n","import { Buffer } from '../../renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry.mjs';\n\n\"use strict\";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends Geometry {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new Buffer({\n      data: placeHolderBufferData,\n      label: \"attribute-batch-buffer\",\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new Buffer({\n      data: placeHolderIndexData,\n      label: \"index-batch-buffer\",\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 0\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 2 * 4\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: \"unorm8x4\",\n          stride,\n          offset: 4 * 4\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: \"uint16x2\",\n          stride,\n          offset: 5 * 4\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\nexport { BatchGeometry };\n//# sourceMappingURL=BatchGeometry.mjs.map\n","import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram.mjs';\nimport { colorBitGl, colorBit } from '../../high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBitGl, generateTextureBatchBit } from '../../high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBitGl, roundPixelsBit } from '../../high-shader/shader-bits/roundPixelsBit.mjs';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nimport { Shader } from '../../renderers/shared/shader/Shader.mjs';\n\n\"use strict\";\nclass DefaultShader extends Shader {\n  constructor(maxTextures) {\n    const glProgram = compileHighShaderGlProgram({\n      name: \"batch\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(maxTextures),\n        roundPixelsBitGl\n      ]\n    });\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"batch\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(maxTextures),\n        roundPixelsBit\n      ]\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        batchSamplers: getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n}\n\nexport { DefaultShader };\n//# sourceMappingURL=DefaultShader.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Batcher } from './Batcher.mjs';\nimport { BatchGeometry } from './BatchGeometry.mjs';\nimport { DefaultShader } from './DefaultShader.mjs';\n\n\"use strict\";\nlet defaultShader = null;\nconst _DefaultBatcher = class _DefaultBatcher extends Batcher {\n  constructor() {\n    super(...arguments);\n    this.geometry = new BatchGeometry();\n    this.shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));\n    this.name = _DefaultBatcher.extension.name;\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    this.vertexSize = 6;\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n   * @param element - The DefaultBatchableMeshElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packAttributes(element, float32View, uint32View, index, textureId) {\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const { positions, uvs } = element;\n    const argb = element.color;\n    const offset = element.attributeOffset;\n    const end = offset + element.attributeSize;\n    for (let i = offset; i < end; i++) {\n      const i2 = i * 2;\n      const x = positions[i2];\n      const y = positions[i2 + 1];\n      float32View[index++] = a * x + c * y + tx;\n      float32View[index++] = d * y + b * x + ty;\n      float32View[index++] = uvs[i2];\n      float32View[index++] = uvs[i2 + 1];\n      uint32View[index++] = argb;\n      uint32View[index++] = textureIdAndRound;\n    }\n  }\n  /**\n   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n   * @param element - The DefaultBatchableQuadElement to pack.\n   * @param float32View - The Float32Array view to pack into.\n   * @param uint32View - The Uint32Array view to pack into.\n   * @param index - The starting index in the views.\n   * @param textureId - The texture ID to use.\n   */\n  packQuadAttributes(element, float32View, uint32View, index, textureId) {\n    const texture = element.texture;\n    const wt = element.transform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = element.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = element.color;\n    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n};\n/** @ignore */\n_DefaultBatcher.extension = {\n  type: [\n    ExtensionType.Batcher\n  ],\n  name: \"default\"\n};\nlet DefaultBatcher = _DefaultBatcher;\n\nexport { DefaultBatcher };\n//# sourceMappingURL=DefaultBatcher.mjs.map\n","import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n        \n        {{end}}\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n        main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","import { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction addMaskBounds(mask, bounds, skipUpdateTransform) {\n  const boundsToMask = tempBounds;\n  mask.measurable = true;\n  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n  bounds.addBoundsMask(boundsToMask);\n  mask.measurable = false;\n}\n\nexport { addMaskBounds };\n//# sourceMappingURL=addMaskBounds.mjs.map\n","import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds.mjs';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addMaskLocalBounds(mask, bounds, localRoot) {\n  const boundsToMask = boundsPool.get();\n  mask.measurable = true;\n  const tempMatrix = matrixPool.get().identity();\n  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n  getLocalBounds(mask, boundsToMask, relativeMask);\n  mask.measurable = false;\n  bounds.addBoundsMask(boundsToMask);\n  matrixPool.return(tempMatrix);\n  boundsPool.return(boundsToMask);\n}\nfunction getMatrixRelativeToParent(target, root, matrix) {\n  if (!target) {\n    warn(\"Mask bounds, renderable is not inside the root container\");\n    return matrix;\n  }\n  if (target !== root) {\n    getMatrixRelativeToParent(target.parent, root, matrix);\n    target.updateLocalTransform();\n    matrix.append(target.localTransform);\n  }\n  return matrix;\n}\n\nexport { addMaskLocalBounds, getMatrixRelativeToParent };\n//# sourceMappingURL=addMaskLocalBounds.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { addMaskBounds } from '../utils/addMaskBounds.mjs';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds.mjs';\n\n\"use strict\";\nclass AlphaMask {\n  constructor(options) {\n    this.priority = 0;\n    this.inverse = false;\n    this.pipe = \"alphaMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.renderMaskToTexture = !(mask instanceof Sprite);\n    this.mask.renderable = this.renderMaskToTexture;\n    this.mask.includeInBuild = !this.renderMaskToTexture;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    if (!this.inverse) {\n      addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Sprite;\n  }\n}\nAlphaMask.extension = ExtensionType.MaskEffect;\n\nexport { AlphaMask };\n//# sourceMappingURL=AlphaMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"colorMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n  }\n  destroy() {\n  }\n  static test(mask) {\n    return typeof mask === \"number\";\n  }\n}\nColorMask.extension = ExtensionType.MaskEffect;\n\nexport { ColorMask };\n//# sourceMappingURL=ColorMask.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Container } from '../../../scene/container/Container.mjs';\nimport { addMaskBounds } from '../utils/addMaskBounds.mjs';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds.mjs';\n\n\"use strict\";\nclass StencilMask {\n  constructor(options) {\n    this.priority = 0;\n    this.pipe = \"stencilMask\";\n    if (options?.mask) {\n      this.init(options.mask);\n    }\n  }\n  init(mask) {\n    this.mask = mask;\n    this.mask.includeInBuild = false;\n    this.mask.measurable = false;\n  }\n  reset() {\n    this.mask.measurable = true;\n    this.mask.includeInBuild = true;\n    this.mask = null;\n  }\n  addBounds(bounds, skipUpdateTransform) {\n    addMaskBounds(this.mask, bounds, skipUpdateTransform);\n  }\n  addLocalBounds(bounds, localRoot) {\n    addMaskLocalBounds(this.mask, bounds, localRoot);\n  }\n  containsPoint(point, hitTestFn) {\n    const mask = this.mask;\n    return hitTestFn(mask, point);\n  }\n  destroy() {\n    this.reset();\n  }\n  static test(mask) {\n    return mask instanceof Container;\n  }\n}\nStencilMask.extension = ExtensionType.MaskEffect;\n\nexport { StencilMask };\n//# sourceMappingURL=StencilMask.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { AlphaMask } from './mask/alpha/AlphaMask.mjs';\nimport { ColorMask } from './mask/color/ColorMask.mjs';\nimport { StencilMask } from './mask/stencil/StencilMask.mjs';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource.mjs';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource.mjs';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource.mjs';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource.mjs';\nimport './renderers/shared/texture/utils/textureFrom.mjs';\nimport './mask/MaskEffectManager.mjs';\n\n\"use strict\";\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nvar CLEAR = /* @__PURE__ */ ((CLEAR2) => {\n  CLEAR2[CLEAR2[\"NONE\"] = 0] = \"NONE\";\n  CLEAR2[CLEAR2[\"COLOR\"] = 16384] = \"COLOR\";\n  CLEAR2[CLEAR2[\"STENCIL\"] = 1024] = \"STENCIL\";\n  CLEAR2[CLEAR2[\"DEPTH\"] = 256] = \"DEPTH\";\n  CLEAR2[CLEAR2[\"COLOR_DEPTH\"] = 16640] = \"COLOR_DEPTH\";\n  CLEAR2[CLEAR2[\"COLOR_STENCIL\"] = 17408] = \"COLOR_STENCIL\";\n  CLEAR2[CLEAR2[\"DEPTH_STENCIL\"] = 1280] = \"DEPTH_STENCIL\";\n  CLEAR2[CLEAR2[\"ALL\"] = 17664] = \"ALL\";\n  return CLEAR2;\n})(CLEAR || {});\n\nexport { CLEAR };\n//# sourceMappingURL=const.mjs.map\n","import { getTestContext } from './getTestContext.mjs';\n\n\"use strict\";\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = \"mediump\";\n    const gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\nexport { getMaxFragmentPrecision };\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n","\"use strict\";\nconst fragmentNameCache = {};\nconst VertexNameCache = {};\nfunction setProgramName(src, { name = `pixi-program` }, isFragment = true) {\n  name = name.replace(/\\s+/g, \"-\");\n  name += isFragment ? \"-fragment\" : \"-vertex\";\n  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n  if (nameCache[name]) {\n    nameCache[name]++;\n    name += `-${nameCache[name]}`;\n  } else {\n    nameCache[name] = 1;\n  }\n  if (src.indexOf(\"#define SHADER_NAME\") !== -1)\n    return src;\n  const shaderName = `#define SHADER_NAME ${name}`;\n  return `${shaderName}\n${src}`;\n}\n\nexport { setProgramName };\n//# sourceMappingURL=setProgramName.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision.mjs';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines.mjs';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision.mjs';\nimport { insertVersion } from './program/preprocessors/insertVersion.mjs';\nimport { setProgramName } from './program/preprocessors/setProgramName.mjs';\nimport { stripVersion } from './program/preprocessors/stripVersion.mjs';\n\n\"use strict\";\nconst processes = {\n  // strips any version headers..\n  stripVersion,\n  // adds precision string if not already present\n  ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines,\n  // add the program name to the shader\n  setProgramName,\n  // add the version string to the shader header\n  insertVersion\n};\nconst programCache = /* @__PURE__ */ Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = { ..._GlProgram.defaultOptions, ...options };\n    const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: \"highp\",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach((processKey) => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, \"gl-program\");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: \"highp\",\n  preferredFragmentPrecision: \"mediump\"\n};\nlet GlProgram = _GlProgram;\n\nexport { GlProgram };\n//# sourceMappingURL=GlProgram.mjs.map\n","\"use strict\";\nfunction stripVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return src.replace(\"#version 300 es\", \"\");\n}\n\nexport { stripVersion };\n//# sourceMappingURL=stripVersion.mjs.map\n","\"use strict\";\nfunction ensurePrecision(src, options, isFragment) {\n  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n  if (src.substring(0, 9) !== \"precision\") {\n    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n    if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") {\n      precision = \"mediump\";\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") {\n    return src.replace(\"precision highp\", \"precision mediump\");\n  }\n  return src;\n}\n\nexport { ensurePrecision };\n//# sourceMappingURL=ensurePrecision.mjs.map\n","\"use strict\";\nfunction addProgramDefines(src, isES300, isFragment) {\n  if (isES300)\n    return src;\n  if (isFragment) {\n    src = src.replace(\"out vec4 finalColor;\", \"\");\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n  }\n  return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\nexport { addProgramDefines };\n//# sourceMappingURL=addProgramDefines.mjs.map\n","\"use strict\";\nfunction insertVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return `#version 300 es\n${src}`;\n}\n\nexport { insertVersion };\n//# sourceMappingURL=insertVersion.mjs.map\n","import { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nconst batchSamplersUniformGroupHash = {};\nfunction getBatchSamplersUniformGroup(maxTextures) {\n  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n  if (batchSamplersUniformGroup)\n    return batchSamplersUniformGroup;\n  const sampleValues = new Int32Array(maxTextures);\n  for (let i = 0; i < maxTextures; i++) {\n    sampleValues[i] = i;\n  }\n  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n  }, { isStatic: true });\n  return batchSamplersUniformGroup;\n}\n\nexport { getBatchSamplersUniformGroup };\n//# sourceMappingURL=getBatchSamplersUniformGroup.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\n\n\"use strict\";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = DOMAdapter.get().createCanvas();\n    context = canvas.getContext(\"webgl\", {});\n  }\n  return context;\n}\n\nexport { getTestContext };\n//# sourceMappingURL=getTestContext.mjs.map\n","\"use strict\";\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join(\"|\");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    resource.on?.(\"change\", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\n\nexport { BindGroup };\n//# sourceMappingURL=BindGroup.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: \"float32\",\n  \"vec2<f32>\": \"float32x2\",\n  \"vec3<f32>\": \"float32x3\",\n  \"vec4<f32>\": \"float32x4\",\n  vec2f: \"float32x2\",\n  vec3f: \"float32x3\",\n  vec4f: \"float32x4\",\n  i32: \"sint32\",\n  \"vec2<i32>\": \"sint32x2\",\n  \"vec3<i32>\": \"sint32x3\",\n  \"vec4<i32>\": \"sint32x4\",\n  u32: \"uint32\",\n  \"vec2<u32>\": \"uint32x2\",\n  \"vec3<u32>\": \"uint32x3\",\n  \"vec4<u32>\": \"uint32x4\",\n  bool: \"uint32\",\n  \"vec2<bool>\": \"uint32x2\",\n  \"vec3<bool>\": \"uint32x3\",\n  \"vec4<bool>\": \"uint32x4\"\n};\nfunction extractAttributesFromGpuProgram({ source, entryPoint }) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: getAttributeInfoFromFormat(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\n\nexport { extractAttributesFromGpuProgram };\n//# sourceMappingURL=extractAttributesFromGpuProgram.mjs.map\n","\"use strict\";\nfunction extractStructAndGroups(wgsl) {\n  const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n  const groupPattern = /@group\\((\\d+)\\)/;\n  const bindingPattern = /@binding\\((\\d+)\\)/;\n  const namePattern = /var(<[^>]+>)? (\\w+)/;\n  const typePattern = /:\\s*(\\w+)/;\n  const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n  const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n  const structName = /struct\\s+(\\w+)/;\n  const groups = wgsl.match(linePattern)?.map((item) => ({\n    group: parseInt(item.match(groupPattern)[1], 10),\n    binding: parseInt(item.match(bindingPattern)[1], 10),\n    name: item.match(namePattern)[2],\n    isUniform: item.match(namePattern)[1] === \"<uniform>\",\n    type: item.match(typePattern)[1]\n  }));\n  if (!groups) {\n    return {\n      groups: [],\n      structs: []\n    };\n  }\n  const structs = wgsl.match(structPattern)?.map((struct) => {\n    const name = struct.match(structName)[1];\n    const members = struct.match(structMemberPattern).reduce((acc, member) => {\n      const [name2, type] = member.split(\":\");\n      acc[name2.trim()] = type.trim();\n      return acc;\n    }, {});\n    if (!members) {\n      return null;\n    }\n    return { name, members };\n  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n  return {\n    groups,\n    structs\n  };\n}\n\nexport { extractStructAndGroups };\n//# sourceMappingURL=extractStructAndGroups.mjs.map\n","\"use strict\";\nvar ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {\n  ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n  ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n  ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n  return ShaderStage2;\n})(ShaderStage || {});\n\nexport { ShaderStage };\n//# sourceMappingURL=const.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram.mjs';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups.mjs';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups.mjs';\nimport { generateLayoutHash } from './utils/generateLayoutHash.mjs';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates.mjs';\n\n\"use strict\";\nconst programCache = /* @__PURE__ */ Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /**\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._attributeLocationsKey = 0;\n    const { fragment, vertex, layout, gpuLayout, name } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const { vertex, fragment } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = createIdFromString(bigKey, \"program\");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n    }\n    return programCache[key];\n  }\n}\n\nexport { GpuProgram };\n//# sourceMappingURL=GpuProgram.mjs.map\n","\"use strict\";\nfunction removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {\n  const structNameSet = /* @__PURE__ */ new Set();\n  const dupeGroupKeySet = /* @__PURE__ */ new Set();\n  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {\n    if (structNameSet.has(struct.name)) {\n      return false;\n    }\n    structNameSet.add(struct.name);\n    return true;\n  });\n  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {\n    const key = `${group.name}-${group.binding}`;\n    if (dupeGroupKeySet.has(key)) {\n      return false;\n    }\n    dupeGroupKeySet.add(key);\n    return true;\n  });\n  return { structs, groups };\n}\n\nexport { removeStructAndGroupDuplicates };\n//# sourceMappingURL=removeStructAndGroupDuplicates.mjs.map\n","\"use strict\";\nfunction generateLayoutHash({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = {};\n    }\n    layout[group.group][group.name] = group.binding;\n  }\n  return layout;\n}\n\nexport { generateLayoutHash };\n//# sourceMappingURL=generateLayoutHash.mjs.map\n","import { ShaderStage } from '../../../shared/shader/const.mjs';\n\n\"use strict\";\nfunction generateGpuLayoutGroups({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = [];\n    }\n    if (group.isUniform) {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n        buffer: {\n          type: \"uniform\"\n        }\n      });\n    } else if (group.type === \"sampler\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        sampler: {\n          type: \"filtering\"\n        }\n      });\n    } else if (group.type === \"texture_2d\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        texture: {\n          sampleType: \"float\",\n          viewDimension: \"2d\",\n          multisampled: false\n        }\n      });\n    }\n  }\n  return layout;\n}\n\nexport { generateGpuLayoutGroups };\n//# sourceMappingURL=generateGpuLayoutGroups.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { BufferUsage } from './const.mjs';\n\n\"use strict\";\nclass Buffer extends EventEmitter {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"buffer\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    this._dataInt32 = null;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size ?? (size = data?.byteLength);\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  get dataInt32() {\n    if (!this._dataInt32) {\n      this._dataInt32 = new Int32Array(this.data.buffer);\n    }\n    return this._dataInt32;\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & BufferUsage.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= BufferUsage.STATIC;\n    } else {\n      this.descriptor.usage &= ~BufferUsage.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit(\"update\", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    this._dataInt32 = null;\n    if (!oldData || oldData.length !== value.length) {\n      if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit(\"update\", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = uid(\"resource\");\n        this.emit(\"change\", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit(\"update\", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit(\"update\", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { Buffer };\n//# sourceMappingURL=Buffer.mjs.map\n","\"use strict\";\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n  BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n  BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n  BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n  BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n  BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n  BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n  BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n  BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n  BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n  BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n  return BufferUsage2;\n})(BufferUsage || {});\n\nexport { BufferUsage };\n//# sourceMappingURL=const.mjs.map\n","\"use strict\";\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\nexport { fastCopy };\n//# sourceMappingURL=fastCopy.mjs.map\n","import { Buffer } from '../../buffer/Buffer.mjs';\nimport { BufferUsage } from '../../buffer/const.mjs';\n\n\"use strict\";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer)) {\n    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n      }\n    }\n    buffer = new Buffer({\n      data: buffer,\n      label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n      usage\n    });\n  }\n  return buffer;\n}\n\nexport { ensureIsBuffer };\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer.mjs';\nimport { getGeometryBounds } from './utils/getGeometryBounds.mjs';\n\n\"use strict\";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends EventEmitter {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options = {}) {\n    super();\n    /** The unique id of the geometry. */\n    this.uid = uid(\"geometry\");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n    const { attributes, indexBuffer, topology } = options;\n    this.buffers = [];\n    this.attributes = {};\n    if (attributes) {\n      for (const i in attributes) {\n        this.addAttribute(i, attributes[i]);\n      }\n    }\n    this.instanceCount = options.instanceCount ?? 1;\n    if (indexBuffer) {\n      this.addIndex(indexBuffer);\n    }\n    this.topology = topology || \"triangle-list\";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /**\n   * Adds an attribute to the geometry.\n   * @param name - The name of the attribute to add.\n   * @param attributeOption - The attribute option to add.\n   */\n  addAttribute(name, attributeOption) {\n    const attribute = ensureIsAttribute(attributeOption);\n    const bufferIndex = this.buffers.indexOf(attribute.buffer);\n    if (bufferIndex === -1) {\n      this.buffers.push(attribute.buffer);\n      attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n      attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n    }\n    this.attributes[name] = attribute;\n  }\n  /**\n   * Adds an index buffer to the geometry.\n   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n   */\n  addIndex(indexBuffer) {\n    this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n    this.buffers.push(this.indexBuffer);\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, \"aPosition\", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\nexport { Geometry };\n//# sourceMappingURL=Geometry.mjs.map\n","\"use strict\";\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\nexport { getGeometryBounds };\n//# sourceMappingURL=getGeometryBounds.mjs.map\n","\"use strict\";\nconst attributeFormatData = {\n  uint8x2: { size: 2, stride: 2, normalised: false },\n  uint8x4: { size: 4, stride: 4, normalised: false },\n  sint8x2: { size: 2, stride: 2, normalised: false },\n  sint8x4: { size: 4, stride: 4, normalised: false },\n  unorm8x2: { size: 2, stride: 2, normalised: true },\n  unorm8x4: { size: 4, stride: 4, normalised: true },\n  snorm8x2: { size: 2, stride: 2, normalised: true },\n  snorm8x4: { size: 4, stride: 4, normalised: true },\n  uint16x2: { size: 2, stride: 4, normalised: false },\n  uint16x4: { size: 4, stride: 8, normalised: false },\n  sint16x2: { size: 2, stride: 4, normalised: false },\n  sint16x4: { size: 4, stride: 8, normalised: false },\n  unorm16x2: { size: 2, stride: 4, normalised: true },\n  unorm16x4: { size: 4, stride: 8, normalised: true },\n  snorm16x2: { size: 2, stride: 4, normalised: true },\n  snorm16x4: { size: 4, stride: 8, normalised: true },\n  float16x2: { size: 2, stride: 4, normalised: false },\n  float16x4: { size: 4, stride: 8, normalised: false },\n  float32: { size: 1, stride: 4, normalised: false },\n  float32x2: { size: 2, stride: 8, normalised: false },\n  float32x3: { size: 3, stride: 12, normalised: false },\n  float32x4: { size: 4, stride: 16, normalised: false },\n  uint32: { size: 1, stride: 4, normalised: false },\n  uint32x2: { size: 2, stride: 8, normalised: false },\n  uint32x3: { size: 3, stride: 12, normalised: false },\n  uint32x4: { size: 4, stride: 16, normalised: false },\n  sint32: { size: 1, stride: 4, normalised: false },\n  sint32x2: { size: 2, stride: 8, normalised: false },\n  sint32x3: { size: 3, stride: 12, normalised: false },\n  sint32x4: { size: 4, stride: 16, normalised: false }\n};\nfunction getAttributeInfoFromFormat(format) {\n  return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n\nexport { getAttributeInfoFromFormat };\n//# sourceMappingURL=getAttributeInfoFromFormat.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nlet _tick = 0;\nclass InstructionSet {\n  constructor() {\n    /** a unique id for this instruction set used through the renderer */\n    this.uid = uid(\"instructionSet\");\n    /** the array of instructions */\n    this.instructions = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    this.instructionSize = 0;\n    this.renderables = [];\n    this.tick = 0;\n  }\n  /** reset the instruction set so it can be reused set size back to 0 */\n  reset() {\n    this.instructionSize = 0;\n    this.tick = _tick++;\n  }\n  /**\n   * Add an instruction to the set\n   * @param instruction - add an instruction to the set\n   */\n  add(instruction) {\n    this.instructions[this.instructionSize++] = instruction;\n  }\n  /**\n   * Log the instructions to the console (for debugging)\n   * @internal\n   * @ignore\n   */\n  log() {\n    this.instructions.length = this.instructionSize;\n    console.table(this.instructions, [\"type\", \"action\"]);\n  }\n}\n\nexport { InstructionSet };\n//# sourceMappingURL=InstructionSet.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\n\n\"use strict\";\nclass Shader extends EventEmitter {\n  constructor(options) {\n    super();\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= RendererType.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= RendererType.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error(\"[Shader] Cannot have both resources and groups\");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      groups = {};\n      groupMap = {};\n      if (gpuProgram) {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      let bindTick = 0;\n      for (const i in resources) {\n        if (nameHash[i])\n          continue;\n        if (!groups[99]) {\n          groups[99] = new BindGroup();\n          this._ownedBindGroups.push(groups[99]);\n        }\n        nameHash[i] = { group: 99, binding: bindTick, name: i };\n        groupMap[99] = groupMap[99] || {};\n        groupMap[99][bindTick] = i;\n        bindTick++;\n      }\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new UniformGroup(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new BindGroup();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new BindGroup();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    this.emit(\"destroy\", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\nexport { Shader };\n//# sourceMappingURL=Shader.mjs.map\n","\"use strict\";\nconst UNIFORM_TYPES_VALUES = [\n  \"f32\",\n  \"i32\",\n  \"vec2<f32>\",\n  \"vec3<f32>\",\n  \"vec4<f32>\",\n  \"mat2x2<f32>\",\n  \"mat3x3<f32>\",\n  \"mat4x4<f32>\",\n  \"mat3x2<f32>\",\n  \"mat4x2<f32>\",\n  \"mat2x3<f32>\",\n  \"mat4x3<f32>\",\n  \"mat2x4<f32>\",\n  \"mat3x4<f32>\",\n  \"vec2<i32>\",\n  \"vec3<i32>\",\n  \"vec4<i32>\"\n];\nconst UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {\n  acc[type] = true;\n  return acc;\n}, {});\n\nexport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES };\n//# sourceMappingURL=types.mjs.map\n","\"use strict\";\nfunction getDefaultUniformValue(type, size) {\n  switch (type) {\n    case \"f32\":\n      return 0;\n    case \"vec2<f32>\":\n      return new Float32Array(2 * size);\n    case \"vec3<f32>\":\n      return new Float32Array(3 * size);\n    case \"vec4<f32>\":\n      return new Float32Array(4 * size);\n    case \"mat2x2<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3x3<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4x4<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexport { getDefaultUniformValue };\n//# sourceMappingURL=getDefaultUniformValue.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { createIdFromString } from '../utils/createIdFromString.mjs';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES } from './types.mjs';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue.mjs';\n\n\"use strict\";\nconst _UniformGroup = class _UniformGroup {\n  /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */\n  constructor(uniformStructures, options) {\n    /** used internally to know if a uniform group was used in the last render pass */\n    this._touched = 0;\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"uniform\");\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    this._resourceType = \"uniformGroup\";\n    /** the resource id used internally by the renderer to build bind group keys */\n    this._resourceId = uid(\"resource\");\n    /** used ito identify if this is a uniform group */\n    this.isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    this._dirtyId = 0;\n    // implementing the interface - UniformGroup are not destroyed\n    this.destroyed = false;\n    options = { ..._UniformGroup.defaultOptions, ...options };\n    this.uniformStructures = uniformStructures;\n    const uniforms = {};\n    for (const i in uniformStructures) {\n      const uniformData = uniformStructures[i];\n      uniformData.name = i;\n      uniformData.size = uniformData.size ?? 1;\n      if (!UNIFORM_TYPES_MAP[uniformData.type]) {\n        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(\", \")}`);\n      }\n      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));\n      uniforms[i] = uniformData.value;\n    }\n    this.uniforms = uniforms;\n    this._dirtyId = 1;\n    this.ubo = options.ubo;\n    this.isStatic = options.isStatic;\n    this._signature = createIdFromString(Object.keys(uniforms).map(\n      (i) => `${i}-${uniformStructures[i].type}`\n    ).join(\"-\"), \"uniform-group\");\n  }\n  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n  update() {\n    this._dirtyId++;\n  }\n};\n/** The default options used by the uniform group. */\n_UniformGroup.defaultOptions = {\n  /** if true the UniformGroup is handled as an Uniform buffer object. */\n  ubo: false,\n  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n  isStatic: false\n};\nlet UniformGroup = _UniformGroup;\n\nexport { UniformGroup };\n//# sourceMappingURL=UniformGroup.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","\"use strict\";\nconst BLEND_TO_NPM = {\n  normal: \"normal-npm\",\n  add: \"add-npm\",\n  screen: \"screen-npm\"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n  STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"INVERSE_MASK_ACTIVE\"] = 3] = \"INVERSE_MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 4] = \"RENDERING_MASK_REMOVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 5] = \"NONE\";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\nexport { BLEND_TO_NPM, STENCIL_MODES };\n//# sourceMappingURL=const.mjs.map\n","import { BLEND_TO_NPM } from './const.mjs';\n\n\"use strict\";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === \"no-premultiply-alpha\") {\n    return BLEND_TO_NPM[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\nexport { getAdjustedBlendModeBlend };\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst environments = [];\nextensions.handleByNamedList(ExtensionType.Environment, environments);\nasync function loadEnvironmentExtensions(skip) {\n  if (skip)\n    return;\n  for (let i = 0; i < environments.length; i++) {\n    const env = environments[i];\n    if (env.value.test()) {\n      await env.value.load();\n      return;\n    }\n  }\n}\nasync function autoDetectEnvironment(add) {\n  return loadEnvironmentExtensions(!add);\n}\n\nexport { autoDetectEnvironment, loadEnvironmentExtensions };\n//# sourceMappingURL=autoDetectEnvironment.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport '../../../../utils/utils.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { SystemRunner } from './SystemRunner.mjs';\nimport EventEmitter from 'eventemitter3';\n\n\"use strict\";\nconst defaultRunners = [\n  \"init\",\n  \"destroy\",\n  \"contextChange\",\n  \"resolutionChange\",\n  \"reset\",\n  \"renderEnd\",\n  \"renderStart\",\n  \"render\",\n  \"update\",\n  \"postrender\",\n  \"prerender\"\n];\nconst _AbstractRenderer = class _AbstractRenderer extends EventEmitter {\n  /**\n   * Set up a system with a collection of SystemClasses and runners.\n   * Systems are attached dynamically to this class when added.\n   * @param config - the config for the system manager\n   */\n  constructor(config) {\n    super();\n    this.runners = /* @__PURE__ */ Object.create(null);\n    this.renderPipes = /* @__PURE__ */ Object.create(null);\n    this._initOptions = {};\n    this._systemsHash = /* @__PURE__ */ Object.create(null);\n    this.type = config.type;\n    this.name = config.name;\n    this.config = config;\n    const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];\n    this._addRunners(...combinedRunners);\n    this._unsafeEvalCheck();\n  }\n  /**\n   * Initialize the renderer.\n   * @param options - The options to use to create the renderer.\n   */\n  async init(options = {}) {\n    const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n    await loadEnvironmentExtensions(skip);\n    this._addSystems(this.config.systems);\n    this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n    for (const systemName in this._systemsHash) {\n      const system = this._systemsHash[systemName];\n      const defaultSystemOptions = system.constructor.defaultOptions;\n      options = { ...defaultSystemOptions, ...options };\n    }\n    options = { ..._AbstractRenderer.defaultOptions, ...options };\n    this._roundPixels = options.roundPixels ? 1 : 0;\n    for (let i = 0; i < this.runners.init.items.length; i++) {\n      await this.runners.init.items[i].init(options);\n    }\n    this._initOptions = options;\n  }\n  render(args, deprecated) {\n    let options = args;\n    if (options instanceof Container) {\n      options = { container: options };\n      if (deprecated) {\n        deprecation(v8_0_0, \"passing a second argument is deprecated, please use render options instead\");\n        options.target = deprecated.renderTexture;\n      }\n    }\n    options.target || (options.target = this.view.renderTarget);\n    if (options.target === this.view.renderTarget) {\n      this._lastObjectRendered = options.container;\n      options.clearColor = this.background.colorRgba;\n    }\n    if (options.clearColor) {\n      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n      options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n    }\n    if (!options.transform) {\n      options.container.updateLocalTransform();\n      options.transform = options.container.localTransform;\n    }\n    options.container.enableRenderGroup();\n    this.runners.prerender.emit(options);\n    this.runners.renderStart.emit(options);\n    this.runners.render.emit(options);\n    this.runners.renderEnd.emit(options);\n    this.runners.postrender.emit(options);\n  }\n  /**\n   * Resizes the WebGL view to the specified width and height.\n   * @param desiredScreenWidth - The desired width of the screen.\n   * @param desiredScreenHeight - The desired height of the screen.\n   * @param resolution - The resolution / device pixel ratio of the renderer.\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    const previousResolution = this.view.resolution;\n    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.emit(\"resize\", this.view.screen.width, this.view.screen.height, this.view.resolution);\n    if (resolution !== void 0 && resolution !== previousResolution) {\n      this.runners.resolutionChange.emit(resolution);\n    }\n  }\n  clear(options = {}) {\n    const renderer = this;\n    options.target || (options.target = renderer.renderTarget.renderTarget);\n    options.clearColor || (options.clearColor = this.background.colorRgba);\n    options.clear ?? (options.clear = CLEAR.ALL);\n    const { clear, clearColor, target } = options;\n    Color.shared.setValue(clearColor ?? this.background.colorRgba);\n    renderer.renderTarget.clear(target, clear, Color.shared.toArray());\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.view.resolution;\n  }\n  set resolution(value) {\n    this.view.resolution = value;\n    this.runners.resolutionChange.emit(value);\n  }\n  /**\n   * Same as view.width, actual number of pixels in the canvas by horizontal.\n   * @member {number}\n   * @readonly\n   * @default 800\n   */\n  get width() {\n    return this.view.texture.frame.width;\n  }\n  /**\n   * Same as view.height, actual number of pixels in the canvas by vertical.\n   * @default 600\n   */\n  get height() {\n    return this.view.texture.frame.height;\n  }\n  // NOTE: this was `view` in v7\n  /**\n   * The canvas element that everything is drawn to.\n   * @type {environment.ICanvas}\n   */\n  get canvas() {\n    return this.view.canvas;\n  }\n  /**\n   * the last object rendered by the renderer. Useful for other plugins like interaction managers\n   * @readonly\n   */\n  get lastObjectRendered() {\n    return this._lastObjectRendered;\n  }\n  /**\n   * Flag if we are rendering to the screen vs renderTexture\n   * @readonly\n   * @default true\n   */\n  get renderingToScreen() {\n    const renderer = this;\n    return renderer.renderTarget.renderingToScreen;\n  }\n  /**\n   * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n   *\n   * Its safe to use as filterArea or hitArea for the whole stage.\n   */\n  get screen() {\n    return this.view.screen;\n  }\n  /**\n   * Create a bunch of runners based of a collection of ids\n   * @param runnerIds - the runner ids to add\n   */\n  _addRunners(...runnerIds) {\n    runnerIds.forEach((runnerId) => {\n      this.runners[runnerId] = new SystemRunner(runnerId);\n    });\n  }\n  _addSystems(systems) {\n    let i;\n    for (i in systems) {\n      const val = systems[i];\n      this._addSystem(val.value, val.name);\n    }\n  }\n  /**\n   * Add a new system to the renderer.\n   * @param ClassRef - Class reference\n   * @param name - Property name for system, if not specified\n   *        will use a static `name` property on the class itself. This\n   *        name will be assigned as s property on the Renderer so make\n   *        sure it doesn't collide with properties on Renderer.\n   * @returns Return instance of renderer\n   */\n  _addSystem(ClassRef, name) {\n    const system = new ClassRef(this);\n    if (this[name]) {\n      throw new Error(`Whoops! The name \"${name}\" is already in use`);\n    }\n    this[name] = system;\n    this._systemsHash[name] = system;\n    for (const i in this.runners) {\n      this.runners[i].add(system);\n    }\n    return this;\n  }\n  _addPipes(pipes, pipeAdaptors) {\n    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {\n      acc[adaptor.name] = adaptor.value;\n      return acc;\n    }, {});\n    pipes.forEach((pipe) => {\n      const PipeClass = pipe.value;\n      const name = pipe.name;\n      const Adaptor = adaptors[name];\n      this.renderPipes[name] = new PipeClass(\n        this,\n        Adaptor ? new Adaptor() : null\n      );\n    });\n  }\n  destroy(options = false) {\n    this.runners.destroy.items.reverse();\n    this.runners.destroy.emit(options);\n    Object.values(this.runners).forEach((runner) => {\n      runner.destroy();\n    });\n    this._systemsHash = null;\n    this.renderPipes = null;\n  }\n  /**\n   * Generate a texture from a container.\n   * @param options - options or container target to use when generating the texture\n   * @returns a texture\n   */\n  generateTexture(options) {\n    return this.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Whether the renderer will round coordinates to whole pixels when rendering.\n   * Can be overridden on a per scene item basis.\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   * @ignore\n   */\n  _unsafeEvalCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n};\n/** The default options for the renderer. */\n_AbstractRenderer.defaultOptions = {\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @default 1\n   */\n  resolution: 1,\n  /**\n   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n   * performance issues when using WebGL.\n   *\n   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n   * driver version blacklisted by the\n   * browser.\n   *\n   * If your application requires high performance rendering, you may wish to set this to false.\n   * We recommend one of two options if you decide to set this flag to false:\n   *\n   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n   *    not supported.\n   *\n   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n   *    device & browser combination does not support high performance WebGL.\n   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n   * @default false\n   */\n  failIfMajorPerformanceCaveat: false,\n  /**\n   * Should round pixels be forced when rendering?\n   * @default false\n   */\n  roundPixels: false\n};\nlet AbstractRenderer = _AbstractRenderer;\n\nexport { AbstractRenderer };\n//# sourceMappingURL=AbstractRenderer.mjs.map\n","\"use strict\";\nclass SystemRunner {\n  /**\n   * @param name - The function name that will be executed on the listeners added to this Runner.\n   */\n  constructor(name) {\n    this.items = [];\n    this._name = name;\n  }\n  /* jsdoc/check-param-names */\n  /**\n   * Dispatch/Broadcast Runner to all listeners added to the queue.\n   * @param {...any} params - (optional) parameters to pass to each listener\n   */\n  /* jsdoc/check-param-names */\n  emit(a0, a1, a2, a3, a4, a5, a6, a7) {\n    const { name, items } = this;\n    for (let i = 0, len = items.length; i < len; i++) {\n      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n    }\n    return this;\n  }\n  /**\n   * Add a listener to the Runner\n   *\n   * Runners do not need to have scope or functions passed to them.\n   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n   * as the name provided to the Runner when it was created.\n   *\n   * Eg A listener passed to this Runner will require a 'complete' function.\n   *\n   * ```\n   * import { Runner } from 'pixi.js';\n   *\n   * const complete = new Runner('complete');\n   * ```\n   *\n   * The scope used will be the object itself.\n   * @param {any} item - The object that will be listening.\n   */\n  add(item) {\n    if (item[this._name]) {\n      this.remove(item);\n      this.items.push(item);\n    }\n    return this;\n  }\n  /**\n   * Remove a single listener from the dispatch queue.\n   * @param {any} item - The listener that you would like to remove.\n   */\n  remove(item) {\n    const index = this.items.indexOf(item);\n    if (index !== -1) {\n      this.items.splice(index, 1);\n    }\n    return this;\n  }\n  /**\n   * Check to see if the listener is already in the Runner\n   * @param {any} item - The listener that you would like to check.\n   */\n  contains(item) {\n    return this.items.indexOf(item) !== -1;\n  }\n  /** Remove all listeners from the Runner */\n  removeAll() {\n    this.items.length = 0;\n    return this;\n  }\n  /** Remove all references, don't use after this. */\n  destroy() {\n    this.removeAll();\n    this.items = null;\n    this._name = null;\n  }\n  /**\n   * `true` if there are no this Runner contains no listeners\n   * @readonly\n   */\n  get empty() {\n    return this.items.length === 0;\n  }\n  /**\n   * The name of the runner.\n   * @readonly\n   */\n  get name() {\n    return this._name;\n  }\n}\n\nexport { SystemRunner };\n//# sourceMappingURL=SystemRunner.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { nextPow2 } from '../../../../maths/misc/pow2.mjs';\n\n\"use strict\";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext(\"2d\");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = nextPow2(minWidth);\n    minHeight = nextPow2(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const canvas = canvasAndContext.canvas;\n    const { width, height } = canvas;\n    const key = (width << 17) + (height << 1);\n    canvasAndContext.context.clearRect(0, 0, width, height);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\nexport { CanvasPool, CanvasPoolClass };\n//# sourceMappingURL=CanvasPool.mjs.map\n","\"use strict\";\nconst NOOP = () => {\n};\n\nexport { NOOP };\n//# sourceMappingURL=NOOP.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { NOOP } from '../../../../utils/misc/NOOP.mjs';\nimport { BufferImageSource } from './sources/BufferImageSource.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { TextureMatrix } from './TextureMatrix.mjs';\n\n\"use strict\";\nclass Texture extends EventEmitter {\n  /**\n   * @param {rendering.TextureOptions} options - Options for the texture\n   */\n  constructor({\n    source,\n    label,\n    frame,\n    orig,\n    trim,\n    defaultAnchor,\n    defaultBorders,\n    rotate,\n    dynamic\n  } = {}) {\n    super();\n    /** unique id for this texture */\n    this.uid = uid(\"texture\");\n    /** A uvs object based on the given frame and the texture source */\n    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    this.frame = new Rectangle();\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    this.noFrame = false;\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    this.dynamic = false;\n    /** is it a texture? yes! used for type checking */\n    this.isTexture = true;\n    this.label = label;\n    this.source = source?.source ?? new TextureSource();\n    this.noFrame = !frame;\n    if (frame) {\n      this.frame.copyFrom(frame);\n    } else {\n      const { width, height } = this._source;\n      this.frame.width = width;\n      this.frame.height = height;\n    }\n    this.orig = orig || this.frame;\n    this.trim = trim;\n    this.rotate = rotate ?? 0;\n    this.defaultAnchor = defaultAnchor;\n    this.defaultBorders = defaultBorders;\n    this.destroyed = false;\n    this.dynamic = dynamic || false;\n    this.updateUvs();\n  }\n  set source(value) {\n    if (this._source) {\n      this._source.off(\"resize\", this.update, this);\n    }\n    this._source = value;\n    value.on(\"resize\", this.update, this);\n    this.emit(\"update\", this);\n  }\n  /** the underlying source of the texture (equivalent of baseTexture in v7) */\n  get source() {\n    return this._source;\n  }\n  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n  get textureMatrix() {\n    if (!this._textureMatrix) {\n      this._textureMatrix = new TextureMatrix(this);\n    }\n    return this._textureMatrix;\n  }\n  /** The width of the Texture in pixels. */\n  get width() {\n    return this.orig.width;\n  }\n  /** The height of the Texture in pixels. */\n  get height() {\n    return this.orig.height;\n  }\n  /** Call this function when you have modified the frame of this texture. */\n  updateUvs() {\n    const { uvs, frame } = this;\n    const { width, height } = this._source;\n    const nX = frame.x / width;\n    const nY = frame.y / height;\n    const nW = frame.width / width;\n    const nH = frame.height / height;\n    let rotate = this.rotate;\n    if (rotate) {\n      const w2 = nW / 2;\n      const h2 = nH / 2;\n      const cX = nX + w2;\n      const cY = nY + h2;\n      rotate = groupD8.add(rotate, groupD8.NW);\n      uvs.x0 = cX + w2 * groupD8.uX(rotate);\n      uvs.y0 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x1 = cX + w2 * groupD8.uX(rotate);\n      uvs.y1 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x2 = cX + w2 * groupD8.uX(rotate);\n      uvs.y2 = cY + h2 * groupD8.uY(rotate);\n      rotate = groupD8.add(rotate, 2);\n      uvs.x3 = cX + w2 * groupD8.uX(rotate);\n      uvs.y3 = cY + h2 * groupD8.uY(rotate);\n    } else {\n      uvs.x0 = nX;\n      uvs.y0 = nY;\n      uvs.x1 = nX + nW;\n      uvs.y1 = nY;\n      uvs.x2 = nX + nW;\n      uvs.y2 = nY + nH;\n      uvs.x3 = nX;\n      uvs.y3 = nY + nH;\n    }\n  }\n  /**\n   * Destroys this texture\n   * @param destroySource - Destroy the source when the texture is destroyed.\n   */\n  destroy(destroySource = false) {\n    if (this._source) {\n      if (destroySource) {\n        this._source.destroy();\n        this._source = null;\n      }\n    }\n    this._textureMatrix = null;\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n  }\n  /**\n   * Call this if you have modified the `texture outside` of the constructor.\n   *\n   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n   */\n  update() {\n    if (this.noFrame) {\n      this.frame.width = this._source.width;\n      this.frame.height = this._source.height;\n    }\n    this.updateUvs();\n    this.emit(\"update\", this);\n  }\n  /** @deprecated since 8.0.0 */\n  get baseTexture() {\n    deprecation(v8_0_0, \"Texture.baseTexture is now Texture.source\");\n    return this._source;\n  }\n}\nTexture.EMPTY = new Texture({\n  label: \"EMPTY\",\n  source: new TextureSource({\n    label: \"EMPTY\"\n  })\n});\nTexture.EMPTY.destroy = NOOP;\nTexture.WHITE = new Texture({\n  source: new BufferImageSource({\n    resource: new Uint8Array([255, 255, 255, 255]),\n    width: 1,\n    height: 1,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    label: \"WHITE\"\n  }),\n  label: \"WHITE\"\n});\nTexture.WHITE.destroy = NOOP;\n\nexport { Texture };\n//# sourceMappingURL=Texture.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\n\n\"use strict\";\nconst tempMat = new Matrix();\nclass TextureMatrix {\n  /**\n   * @param texture - observed texture\n   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   */\n  constructor(texture, clampMargin) {\n    this.mapCoord = new Matrix();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._textureID = -1;\n    this._updateID = 0;\n    this.clampOffset = 0;\n    if (typeof clampMargin === \"undefined\") {\n      this.clampMargin = texture.width < 10 ? 0 : 0.5;\n    } else {\n      this.clampMargin = clampMargin;\n    }\n    this.isSimple = false;\n    this.texture = texture;\n  }\n  /** Texture property. */\n  get texture() {\n    return this._texture;\n  }\n  set texture(value) {\n    if (this.texture === value)\n      return;\n    this._texture?.removeListener(\"update\", this.update, this);\n    this._texture = value;\n    this._texture.addListener(\"update\", this.update, this);\n    this.update();\n  }\n  /**\n   * Multiplies uvs array to transform\n   * @param uvs - mesh uvs\n   * @param [out=uvs] - output\n   * @returns - output\n   */\n  multiplyUvs(uvs, out) {\n    if (out === void 0) {\n      out = uvs;\n    }\n    const mat = this.mapCoord;\n    for (let i = 0; i < uvs.length; i += 2) {\n      const x = uvs[i];\n      const y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n    return out;\n  }\n  /**\n   * Updates matrices if texture was changed\n   * @returns - whether or not it was updated\n   */\n  update() {\n    const tex = this._texture;\n    this._updateID++;\n    const uvs = tex.uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    const orig = tex.orig;\n    const trim = tex.trim;\n    if (trim) {\n      tempMat.set(\n        orig.width / trim.width,\n        0,\n        0,\n        orig.height / trim.height,\n        -trim.x / trim.width,\n        -trim.y / trim.height\n      );\n      this.mapCoord.append(tempMat);\n    }\n    const texBase = tex.source;\n    const frame = this.uClampFrame;\n    const margin = this.clampMargin / texBase._resolution;\n    const offset = this.clampOffset / texBase._resolution;\n    frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n    this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;\n    return true;\n  }\n}\n\nexport { TextureMatrix };\n//# sourceMappingURL=TextureMatrix.mjs.map\n","import { nextPow2 } from '../../../../maths/misc/pow2.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nlet count = 0;\nclass TexturePoolClass {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */\n  constructor(textureOptions) {\n    this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n    this._texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */\n  createTexture(pixelWidth, pixelHeight, antialias) {\n    const textureSource = new TextureSource({\n      ...this.textureOptions,\n      width: pixelWidth,\n      height: pixelHeight,\n      resolution: 1,\n      antialias,\n      autoGarbageCollect: true\n    });\n    return new Texture({\n      source: textureSource,\n      label: `texturePool_${count++}`\n    });\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */\n  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n    po2Width = nextPow2(po2Width);\n    po2Height = nextPow2(po2Height);\n    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n    if (!this._texturePool[key]) {\n      this._texturePool[key] = [];\n    }\n    let texture = this._texturePool[key].pop();\n    if (!texture) {\n      texture = this.createTexture(po2Width, po2Height, antialias);\n    }\n    texture.source._resolution = resolution;\n    texture.source.width = po2Width / resolution;\n    texture.source.height = po2Height / resolution;\n    texture.source.pixelWidth = po2Width;\n    texture.source.pixelHeight = po2Height;\n    texture.frame.x = 0;\n    texture.frame.y = 0;\n    texture.frame.width = frameWidth;\n    texture.frame.height = frameHeight;\n    texture.updateUvs();\n    this._poolKeyHash[texture.uid] = key;\n    return texture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */\n  getSameSizeTexture(texture, antialias = false) {\n    const source = texture.source;\n    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = this._poolKeyHash[renderTexture.uid];\n    this._texturePool[key].push(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this._texturePool) {\n        const textures = this._texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this._texturePool = {};\n  }\n}\nconst TexturePool = new TexturePoolClass();\n\nexport { TexturePool, TexturePoolClass };\n//# sourceMappingURL=TexturePool.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createResourceIdFromString(value) {\n  const id = idHash[value];\n  if (id === void 0) {\n    idHash[value] = uid(\"resource\");\n  }\n  return id;\n}\nconst _TextureStyle = class _TextureStyle extends EventEmitter {\n  /**\n   * @param options - options for the style\n   */\n  constructor(options = {}) {\n    super();\n    this._resourceType = \"textureSampler\";\n    this._touched = 0;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    this._maxAnisotropy = 1;\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    options = { ..._TextureStyle.defaultOptions, ...options };\n    this.addressMode = options.addressMode;\n    this.addressModeU = options.addressModeU ?? this.addressModeU;\n    this.addressModeV = options.addressModeV ?? this.addressModeV;\n    this.addressModeW = options.addressModeW ?? this.addressModeW;\n    this.scaleMode = options.scaleMode;\n    this.magFilter = options.magFilter ?? this.magFilter;\n    this.minFilter = options.minFilter ?? this.minFilter;\n    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n    this.lodMinClamp = options.lodMinClamp;\n    this.lodMaxClamp = options.lodMaxClamp;\n    this.compare = options.compare;\n    this.maxAnisotropy = options.maxAnisotropy ?? 1;\n  }\n  set addressMode(value) {\n    this.addressModeU = value;\n    this.addressModeV = value;\n    this.addressModeW = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this.addressModeU;\n  }\n  set wrapMode(value) {\n    deprecation(v8_0_0, \"TextureStyle.wrapMode is now TextureStyle.addressMode\");\n    this.addressMode = value;\n  }\n  get wrapMode() {\n    return this.addressMode;\n  }\n  set scaleMode(value) {\n    this.magFilter = value;\n    this.minFilter = value;\n    this.mipmapFilter = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this.magFilter;\n  }\n  /** Specifies the maximum anisotropy value clamp used by the sampler. */\n  set maxAnisotropy(value) {\n    this._maxAnisotropy = Math.min(value, 16);\n    if (this._maxAnisotropy > 1) {\n      this.scaleMode = \"linear\";\n    }\n  }\n  get maxAnisotropy() {\n    return this._maxAnisotropy;\n  }\n  // TODO - move this to WebGL?\n  get _resourceId() {\n    return this._sharedResourceId || this._generateResourceId();\n  }\n  update() {\n    this.emit(\"change\", this);\n    this._sharedResourceId = null;\n  }\n  _generateResourceId() {\n    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n    this._sharedResourceId = createResourceIdFromString(bigKey);\n    return this._resourceId;\n  }\n  /** Destroys the style */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this.removeAllListeners();\n  }\n};\n/** default options for the style */\n_TextureStyle.defaultOptions = {\n  addressMode: \"clamp-to-edge\",\n  scaleMode: \"linear\"\n};\nlet TextureStyle = _TextureStyle;\n\nexport { TextureStyle };\n//# sourceMappingURL=TextureStyle.mjs.map\n","import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass BufferImageSource extends TextureSource {\n  constructor(options) {\n    const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n    let format = options.format;\n    if (!format) {\n      if (buffer instanceof Float32Array) {\n        format = \"rgba32float\";\n      } else if (buffer instanceof Int32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Uint32Array) {\n        format = \"rgba32uint\";\n      } else if (buffer instanceof Int16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Uint16Array) {\n        format = \"rgba16uint\";\n      } else if (buffer instanceof Int8Array) {\n        format = \"bgra8unorm\";\n      } else {\n        format = \"bgra8unorm\";\n      }\n    }\n    super({\n      ...options,\n      resource: buffer,\n      format\n    });\n    this.uploadMethodId = \"buffer\";\n  }\n  static test(resource) {\n    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;\n  }\n}\nBufferImageSource.extension = ExtensionType.TextureSource;\n\nexport { BufferImageSource };\n//# sourceMappingURL=BufferImageSource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass CanvasSource extends TextureSource {\n  constructor(options) {\n    if (!options.resource) {\n      options.resource = DOMAdapter.get().createCanvas();\n    }\n    if (!options.width) {\n      options.width = options.resource.width;\n      if (!options.autoDensity) {\n        options.width /= options.resolution;\n      }\n    }\n    if (!options.height) {\n      options.height = options.resource.height;\n      if (!options.autoDensity) {\n        options.height /= options.resolution;\n      }\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoDensity = options.autoDensity;\n    this.resizeCanvas();\n    this.transparent = !!options.transparent;\n  }\n  resizeCanvas() {\n    if (this.autoDensity) {\n      this.resource.style.width = `${this.width}px`;\n      this.resource.style.height = `${this.height}px`;\n    }\n    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {\n      this.resource.width = this.pixelWidth;\n      this.resource.height = this.pixelHeight;\n    }\n  }\n  resize(width = this.width, height = this.height, resolution = this._resolution) {\n    const didResize = super.resize(width, height, resolution);\n    if (didResize) {\n      this.resizeCanvas();\n    }\n    return didResize;\n  }\n  static test(resource) {\n    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;\n  }\n  /**\n   * Returns the 2D rendering context for the canvas.\n   * Caches the context after creating it.\n   * @returns The 2D rendering context of the canvas.\n   */\n  get context2D() {\n    return this._context2D || (this._context2D = this.resource.getContext(\"2d\"));\n  }\n}\nCanvasSource.extension = ExtensionType.TextureSource;\n\nexport { CanvasSource };\n//# sourceMappingURL=CanvasSource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nclass ImageSource extends TextureSource {\n  constructor(options) {\n    if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {\n      const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);\n      options.resource = canvas;\n      warn(\"ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.\");\n    }\n    super(options);\n    this.uploadMethodId = \"image\";\n    this.autoGarbageCollect = true;\n  }\n  static test(resource) {\n    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== \"undefined\" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;\n  }\n}\nImageSource.extension = ExtensionType.TextureSource;\n\nexport { ImageSource };\n//# sourceMappingURL=ImageSource.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2.mjs';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps.mjs';\nimport { uid } from '../../../../../utils/data/uid.mjs';\nimport { TextureStyle } from '../TextureStyle.mjs';\n\n\"use strict\";\nconst _TextureSource = class _TextureSource extends EventEmitter {\n  /**\n   * @param options - options for creating a new TextureSource\n   */\n  constructor(options = {}) {\n    super();\n    this.options = options;\n    /** unique id for this Texture source */\n    this.uid = uid(\"textureSource\");\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    this._resourceType = \"textureSource\";\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    this.uploadMethodId = \"unknown\";\n    // dimensions\n    this._resolution = 1;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    this.pixelHeight = 1;\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    this.width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    this.height = 1;\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    this.sampleCount = 1;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    this.mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    this.autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    this.format = \"rgba8unorm\";\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    this.dimension = \"2d\";\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    this.antialias = false;\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    this._touched = 0;\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    this._batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    this._textureBindLocation = -1;\n    options = { ..._TextureSource.defaultOptions, ...options };\n    this.label = options.label ?? \"\";\n    this.resource = options.resource;\n    this.autoGarbageCollect = options.autoGarbageCollect;\n    this._resolution = options.resolution;\n    if (options.width) {\n      this.pixelWidth = options.width * this._resolution;\n    } else {\n      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;\n    }\n    if (options.height) {\n      this.pixelHeight = options.height * this._resolution;\n    } else {\n      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;\n    }\n    this.width = this.pixelWidth / this._resolution;\n    this.height = this.pixelHeight / this._resolution;\n    this.format = options.format;\n    this.dimension = options.dimensions;\n    this.mipLevelCount = options.mipLevelCount;\n    this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n    this.sampleCount = options.sampleCount;\n    this.antialias = options.antialias;\n    this.alphaMode = options.alphaMode;\n    this.style = new TextureStyle(definedProps(options));\n    this.destroyed = false;\n    this._refreshPOT();\n  }\n  /** returns itself */\n  get source() {\n    return this;\n  }\n  /** the style of the texture */\n  get style() {\n    return this._style;\n  }\n  set style(value) {\n    if (this.style === value)\n      return;\n    this._style?.off(\"change\", this._onStyleChange, this);\n    this._style = value;\n    this._style?.on(\"change\", this._onStyleChange, this);\n    this._onStyleChange();\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get addressMode() {\n    return this._style.addressMode;\n  }\n  set addressMode(value) {\n    this._style.addressMode = value;\n  }\n  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n  get repeatMode() {\n    return this._style.addressMode;\n  }\n  set repeatMode(value) {\n    this._style.addressMode = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n  get magFilter() {\n    return this._style.magFilter;\n  }\n  set magFilter(value) {\n    this._style.magFilter = value;\n  }\n  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n  get minFilter() {\n    return this._style.minFilter;\n  }\n  set minFilter(value) {\n    this._style.minFilter = value;\n  }\n  /** Specifies behavior for sampling between mipmap levels. */\n  get mipmapFilter() {\n    return this._style.mipmapFilter;\n  }\n  set mipmapFilter(value) {\n    this._style.mipmapFilter = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMinClamp() {\n    return this._style.lodMinClamp;\n  }\n  set lodMinClamp(value) {\n    this._style.lodMinClamp = value;\n  }\n  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n  get lodMaxClamp() {\n    return this._style.lodMaxClamp;\n  }\n  set lodMaxClamp(value) {\n    this._style.lodMaxClamp = value;\n  }\n  _onStyleChange() {\n    this.emit(\"styleChange\", this);\n  }\n  /** call this if you have modified the texture outside of the constructor */\n  update() {\n    if (this.resource) {\n      const resolution = this._resolution;\n      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n      if (didResize)\n        return;\n    }\n    this.emit(\"update\", this);\n  }\n  /** Destroys this texture source */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    if (this._style) {\n      this._style.destroy();\n      this._style = null;\n    }\n    this.uploadMethodId = null;\n    this.resource = null;\n    this.removeAllListeners();\n  }\n  /**\n   * This will unload the Texture source from the GPU. This will free up the GPU memory\n   * As soon as it is required fore rendering, it will be re-uploaded.\n   */\n  unload() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    this.emit(\"unload\", this);\n  }\n  /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n  get resourceWidth() {\n    const { resource } = this;\n    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n  }\n  /** the height of the resource. This is the REAL pure number, not accounting resolution */\n  get resourceHeight() {\n    const { resource } = this;\n    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n  }\n  /**\n   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n   * but will the size of the texture when rendered.\n   *\n   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n   * density will have increased)\n   */\n  get resolution() {\n    return this._resolution;\n  }\n  set resolution(resolution) {\n    if (this._resolution === resolution)\n      return;\n    this._resolution = resolution;\n    this.width = this.pixelWidth / resolution;\n    this.height = this.pixelHeight / resolution;\n  }\n  /**\n   * Resize the texture, this is handy if you want to use the texture as a render texture\n   * @param width - the new width of the texture\n   * @param height - the new height of the texture\n   * @param resolution - the new resolution of the texture\n   * @returns - if the texture was resized\n   */\n  resize(width, height, resolution) {\n    resolution || (resolution = this._resolution);\n    width || (width = this.width);\n    height || (height = this.height);\n    const newPixelWidth = Math.round(width * resolution);\n    const newPixelHeight = Math.round(height * resolution);\n    this.width = newPixelWidth / resolution;\n    this.height = newPixelHeight / resolution;\n    this._resolution = resolution;\n    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {\n      return false;\n    }\n    this._refreshPOT();\n    this.pixelWidth = newPixelWidth;\n    this.pixelHeight = newPixelHeight;\n    this.emit(\"resize\", this);\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n    return true;\n  }\n  /**\n   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n   * This is only important for RenderTexture instances, as standard Texture instances will have their\n   * mipmaps generated on upload. You should call this method after you make any change to the texture\n   *\n   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n   * We want you, the developer to specify when this action should happen.\n   *\n   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n   */\n  updateMipmaps() {\n    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {\n      this.emit(\"updateMipmaps\", this);\n    }\n  }\n  set wrapMode(value) {\n    this._style.wrapMode = value;\n  }\n  get wrapMode() {\n    return this._style.wrapMode;\n  }\n  set scaleMode(value) {\n    this._style.scaleMode = value;\n  }\n  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n  get scaleMode() {\n    return this._style.scaleMode;\n  }\n  /**\n   * Refresh check for isPowerOfTwo texture based on size\n   * @private\n   */\n  _refreshPOT() {\n    this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n  }\n  static test(_resource) {\n    throw new Error(\"Unimplemented\");\n  }\n};\n/** The default options used when creating a new TextureSource. override these to add your own defaults */\n_TextureSource.defaultOptions = {\n  resolution: 1,\n  format: \"bgra8unorm\",\n  alphaMode: \"premultiply-alpha-on-upload\",\n  dimensions: \"2d\",\n  mipLevelCount: 1,\n  autoGenerateMipmaps: false,\n  sampleCount: 1,\n  antialias: false,\n  autoGarbageCollect: false\n};\nlet TextureSource = _TextureSource;\n\nexport { TextureSource };\n//# sourceMappingURL=TextureSource.mjs.map\n","\"use strict\";\nfunction definedProps(obj) {\n  const result = {};\n  for (const key in obj) {\n    if (obj[key] !== void 0) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\nexport { definedProps };\n//# sourceMappingURL=definedProps.mjs.map\n","import { ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../../../ticker/Ticker.mjs';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { TextureSource } from './TextureSource.mjs';\n\n\"use strict\";\nconst _VideoSource = class _VideoSource extends TextureSource {\n  constructor(options) {\n    super(options);\n    // Public\n    /** Whether or not the video is ready to play. */\n    this.isReady = false;\n    /** The upload method for this texture. */\n    this.uploadMethodId = \"video\";\n    options = {\n      ..._VideoSource.defaultOptions,\n      ...options\n    };\n    this._autoUpdate = true;\n    this._isConnectedToTicker = false;\n    this._updateFPS = options.updateFPS || 0;\n    this._msToNextUpdate = 0;\n    this.autoPlay = options.autoPlay !== false;\n    this.alphaMode = options.alphaMode ?? \"premultiply-alpha-on-upload\";\n    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n    this._videoFrameRequestCallbackHandle = null;\n    this._load = null;\n    this._resolve = null;\n    this._reject = null;\n    this._onCanPlay = this._onCanPlay.bind(this);\n    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n    this._onError = this._onError.bind(this);\n    this._onPlayStart = this._onPlayStart.bind(this);\n    this._onPlayStop = this._onPlayStop.bind(this);\n    this._onSeeked = this._onSeeked.bind(this);\n    if (options.autoLoad !== false) {\n      void this.load();\n    }\n  }\n  /** Update the video frame if the source is not destroyed and meets certain conditions. */\n  updateFrame() {\n    if (this.destroyed) {\n      return;\n    }\n    if (this._updateFPS) {\n      const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n    }\n    if (!this._updateFPS || this._msToNextUpdate <= 0) {\n      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;\n    }\n    if (this.isValid) {\n      this.update();\n    }\n  }\n  /** Callback to update the video frame and potentially request the next frame update. */\n  _videoFrameRequestCallback() {\n    this.updateFrame();\n    if (this.destroyed) {\n      this._videoFrameRequestCallbackHandle = null;\n    } else {\n      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n        this._videoFrameRequestCallback\n      );\n    }\n  }\n  /**\n   * Checks if the resource has valid dimensions.\n   * @returns {boolean} True if width and height are set, otherwise false.\n   */\n  get isValid() {\n    return !!this.resource.videoWidth && !!this.resource.videoHeight;\n  }\n  /**\n   * Start preloading the video resource.\n   * @returns {Promise<this>} Handle the validate event\n   */\n  async load() {\n    if (this._load) {\n      return this._load;\n    }\n    const source = this.resource;\n    const options = this.options;\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n    source.addEventListener(\"play\", this._onPlayStart);\n    source.addEventListener(\"pause\", this._onPlayStop);\n    source.addEventListener(\"seeked\", this._onSeeked);\n    if (!this._isSourceReady()) {\n      if (!options.preload) {\n        source.addEventListener(\"canplay\", this._onCanPlay);\n      }\n      source.addEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.addEventListener(\"error\", this._onError, true);\n    } else {\n      this._mediaReady();\n    }\n    this.alphaMode = await detectVideoAlphaMode();\n    this._load = new Promise((resolve, reject) => {\n      if (this.isValid) {\n        resolve(this);\n      } else {\n        this._resolve = resolve;\n        this._reject = reject;\n        if (options.preloadTimeoutMs !== void 0) {\n          this._preloadTimeout = setTimeout(() => {\n            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n          });\n        }\n        source.load();\n      }\n    });\n    return this._load;\n  }\n  /**\n   * Handle video error events.\n   * @param event - The error event\n   */\n  _onError(event) {\n    this.resource.removeEventListener(\"error\", this._onError, true);\n    this.emit(\"error\", event);\n    if (this._reject) {\n      this._reject(event);\n      this._reject = null;\n      this._resolve = null;\n    }\n  }\n  /**\n   * Checks if the underlying source is playing.\n   * @returns True if playing.\n   */\n  _isSourcePlaying() {\n    const source = this.resource;\n    return !source.paused && !source.ended;\n  }\n  /**\n   * Checks if the underlying source is ready for playing.\n   * @returns True if ready.\n   */\n  _isSourceReady() {\n    const source = this.resource;\n    return source.readyState > 2;\n  }\n  /** Runs the update loop when the video is ready to play. */\n  _onPlayStart() {\n    if (!this.isValid) {\n      this._mediaReady();\n    }\n    this._configureAutoUpdate();\n  }\n  /** Stops the update loop when a pause event is triggered. */\n  _onPlayStop() {\n    this._configureAutoUpdate();\n  }\n  /** Handles behavior when the video completes seeking to the current playback position. */\n  _onSeeked() {\n    if (this._autoUpdate && !this._isSourcePlaying()) {\n      this._msToNextUpdate = 0;\n      this.updateFrame();\n      this._msToNextUpdate = 0;\n    }\n  }\n  _onCanPlay() {\n    const source = this.resource;\n    source.removeEventListener(\"canplay\", this._onCanPlay);\n    this._mediaReady();\n  }\n  _onCanPlayThrough() {\n    const source = this.resource;\n    source.removeEventListener(\"canplaythrough\", this._onCanPlay);\n    if (this._preloadTimeout) {\n      clearTimeout(this._preloadTimeout);\n      this._preloadTimeout = void 0;\n    }\n    this._mediaReady();\n  }\n  /** Fired when the video is loaded and ready to play. */\n  _mediaReady() {\n    const source = this.resource;\n    if (this.isValid) {\n      this.isReady = true;\n      this.resize(source.videoWidth, source.videoHeight);\n    }\n    this._msToNextUpdate = 0;\n    this.updateFrame();\n    this._msToNextUpdate = 0;\n    if (this._resolve) {\n      this._resolve(this);\n      this._resolve = null;\n      this._reject = null;\n    }\n    if (this._isSourcePlaying()) {\n      this._onPlayStart();\n    } else if (this.autoPlay) {\n      void this.resource.play();\n    }\n  }\n  /** Cleans up resources and event listeners associated with this texture. */\n  destroy() {\n    this._configureAutoUpdate();\n    const source = this.resource;\n    if (source) {\n      source.removeEventListener(\"play\", this._onPlayStart);\n      source.removeEventListener(\"pause\", this._onPlayStop);\n      source.removeEventListener(\"seeked\", this._onSeeked);\n      source.removeEventListener(\"canplay\", this._onCanPlay);\n      source.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n      source.removeEventListener(\"error\", this._onError, true);\n      source.pause();\n      source.src = \"\";\n      source.load();\n    }\n    super.destroy();\n  }\n  /** Should the base texture automatically update itself, set to true by default. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * How many times a second to update the texture from the video.\n   * Leave at 0 to update at every render.\n   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n   */\n  get updateFPS() {\n    return this._updateFPS;\n  }\n  set updateFPS(value) {\n    if (value !== this._updateFPS) {\n      this._updateFPS = value;\n      this._configureAutoUpdate();\n    }\n  }\n  /**\n   * Configures the updating mechanism based on the current state and settings.\n   *\n   * This method decides between using the browser's native video frame callback or a custom ticker\n   * for updating the video frame. It ensures optimal performance and responsiveness\n   * based on the video's state, playback status, and the desired frames-per-second setting.\n   *\n   * - If `_autoUpdate` is enabled and the video source is playing:\n   *   - It will prefer the native video frame callback if available and no specific FPS is set.\n   *   - Otherwise, it will use a custom ticker for manual updates.\n   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n   */\n  _configureAutoUpdate() {\n    if (this._autoUpdate && this._isSourcePlaying()) {\n      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {\n        if (this._isConnectedToTicker) {\n          Ticker.shared.remove(this.updateFrame, this);\n          this._isConnectedToTicker = false;\n          this._msToNextUpdate = 0;\n        }\n        if (this._videoFrameRequestCallbackHandle === null) {\n          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n            this._videoFrameRequestCallback\n          );\n        }\n      } else {\n        if (this._videoFrameRequestCallbackHandle !== null) {\n          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n          this._videoFrameRequestCallbackHandle = null;\n        }\n        if (!this._isConnectedToTicker) {\n          Ticker.shared.add(this.updateFrame, this);\n          this._isConnectedToTicker = true;\n          this._msToNextUpdate = 0;\n        }\n      }\n    } else {\n      if (this._videoFrameRequestCallbackHandle !== null) {\n        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n        this._videoFrameRequestCallbackHandle = null;\n      }\n      if (this._isConnectedToTicker) {\n        Ticker.shared.remove(this.updateFrame, this);\n        this._isConnectedToTicker = false;\n        this._msToNextUpdate = 0;\n      }\n    }\n  }\n  static test(resource) {\n    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;\n  }\n};\n_VideoSource.extension = ExtensionType.TextureSource;\n/** The default options for video sources. */\n_VideoSource.defaultOptions = {\n  ...TextureSource.defaultOptions,\n  /** If true, the video will start loading immediately. */\n  autoLoad: true,\n  /** If true, the video will start playing as soon as it is loaded. */\n  autoPlay: true,\n  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n  updateFPS: 0,\n  /** If true, the video will be loaded with the `crossorigin` attribute. */\n  crossorigin: true,\n  /** If true, the video will loop when it ends. */\n  loop: false,\n  /** If true, the video will be muted. */\n  muted: true,\n  /** If true, the video will play inline. */\n  playsinline: true,\n  /** If true, the video will be preloaded. */\n  preload: false\n};\n/**\n * Map of video MIME types that can't be directly derived from file extensions.\n * @readonly\n */\n_VideoSource.MIME_TYPES = {\n  ogv: \"video/ogg\",\n  mov: \"video/quicktime\",\n  m4v: \"video/mp4\"\n};\nlet VideoSource = _VideoSource;\n\nexport { VideoSource };\n//# sourceMappingURL=VideoSource.mjs.map\n","import { Cache } from '../../../../../assets/cache/Cache.mjs';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from '../sources/TextureSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst sources = [];\nextensions.handleByList(ExtensionType.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  return textureSourceFrom(options);\n}\nfunction textureSourceFrom(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : { resource: options };\n  if (!skipCache && Cache.has(resource)) {\n    return Cache.get(resource);\n  }\n  const texture = new Texture({ source: textureSourceFrom(opts) });\n  texture.on(\"destroy\", () => {\n    if (Cache.has(resource)) {\n      Cache.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    Cache.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === \"string\") {\n    return Cache.get(id);\n  } else if (id instanceof TextureSource) {\n    return new Texture({ source: id });\n  }\n  return resourceToTexture(id, skipCache);\n}\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n\nexport { autoDetectSource, resourceToTexture, textureFrom };\n//# sourceMappingURL=textureFrom.mjs.map\n","\"use strict\";\nconst idCounts = /* @__PURE__ */ Object.create(null);\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createIdFromString(value, groupId) {\n  let id = idHash[value];\n  if (id === void 0) {\n    if (idCounts[groupId] === void 0) {\n      idCounts[groupId] = 1;\n    }\n    idHash[value] = id = idCounts[groupId]++;\n  }\n  return id;\n}\n\nexport { createIdFromString };\n//# sourceMappingURL=createIdFromString.mjs.map\n","\"use strict\";\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n  RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n  return RendererType2;\n})(RendererType || {});\n\nexport { RendererType };\n//# sourceMappingURL=types.mjs.map\n","import { deprecation } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst cacheAsTextureMixin = {\n  /**\n   * Is this container cached as a texture?\n   * @readonly\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  get isCachedAsTexture() {\n    return !!this.renderGroup?.isCachedAsTexture;\n  },\n  cacheAsTexture(val) {\n    if (typeof val === \"boolean\" && val === false) {\n      this.disableRenderGroup();\n    } else {\n      this.enableRenderGroup();\n      this.renderGroup.enableCacheAsTexture(val === true ? {} : val);\n    }\n  },\n  /**\n   * Updates the cached texture. Will flag that this container's cached texture needs to be redrawn.\n   * This will happen on the next render.\n   * @memberof scene.Container#\n   */\n  updateCacheTexture() {\n    this.renderGroup?.updateCacheTexture();\n  },\n  /**\n   * Allows backwards compatibility with pixi.js below version v8. Use `cacheAsTexture` instead.\n   * @deprecated\n   */\n  get cacheAsBitmap() {\n    return this.isCachedAsTexture;\n  },\n  /**\n   * @deprecated\n   */\n  set cacheAsBitmap(val) {\n    deprecation(\"v8.6.0\", \"cacheAsBitmap is deprecated, use cacheAsTexture instead.\");\n    this.cacheAsTexture(val);\n  }\n};\n\nexport { cacheAsTextureMixin };\n//# sourceMappingURL=cacheAsTextureMixin.mjs.map\n","import { removeItems } from '../../../utils/data/removeItems.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        removed.push(child);\n        child.parent = null;\n      }\n      removeItems(this.children, beginIndex, end);\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.removeChildren(removed);\n      }\n      for (let i = 0; i < removed.length; ++i) {\n        this.emit(\"childRemoved\", removed[i], this, i);\n        removed[i].emit(\"removed\", this);\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  },\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  /**\n   * Changes the position of an existing child in the container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error(\"The supplied Container must be a child of the caller\");\n    }\n    return index;\n  },\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit(\"childAdded\", child, this, index);\n    child.emit(\"added\", this);\n    return child;\n  },\n  /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   * @memberof scene.Container#\n   */\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._didContainerChangeTick++;\n  },\n  /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  },\n  /**\n   * Reparent the child to this container, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @returns The first child that was reparented.\n   * @memberof scene.Container#\n   */\n  reparentChild(...child) {\n    if (child.length === 1) {\n      return this.reparentChildAt(child[0], this.children.length);\n    }\n    child.forEach((c) => this.reparentChildAt(c, this.children.length));\n    return child[0];\n  },\n  /**\n   * Reparent the child to this container at the specified index, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @param index - The index to reparent the child to\n   * @memberof scene.Container#\n   */\n  reparentChildAt(child, index) {\n    if (child.parent === this) {\n      this.setChildIndex(child, index);\n      return child;\n    }\n    const childMat = child.worldTransform.clone();\n    child.removeFromParent();\n    this.addChildAt(child, index);\n    const newMatrix = this.worldTransform.clone();\n    newMatrix.invert();\n    childMat.prepend(newMatrix);\n    child.setFromMatrix(childMat);\n    return child;\n  }\n};\n\nexport { childrenHelperMixin };\n//# sourceMappingURL=childrenHelperMixin.mjs.map\n","import { extensions, ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\n\n\"use strict\";\nclass MaskEffectManagerClass {\n  constructor() {\n    /**\n     * @private\n     */\n    this._effectClasses = [];\n    this._tests = [];\n    this._initialized = false;\n  }\n  init() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n    this._effectClasses.forEach((test) => {\n      this.add({\n        test: test.test,\n        maskClass: test\n      });\n    });\n  }\n  add(test) {\n    this._tests.push(test);\n  }\n  getMaskEffect(item) {\n    if (!this._initialized)\n      this.init();\n    for (let i = 0; i < this._tests.length; i++) {\n      const test = this._tests[i];\n      if (test.test(item)) {\n        return BigPool.get(test.maskClass, item);\n      }\n    }\n    return item;\n  }\n  returnMaskEffect(effect) {\n    BigPool.return(effect);\n  }\n}\nconst MaskEffectManager = new MaskEffectManagerClass();\nextensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n\nexport { MaskEffectManager, MaskEffectManagerClass };\n//# sourceMappingURL=MaskEffectManager.mjs.map\n","import { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager.mjs';\n\n\"use strict\";\nconst effectsMixin = {\n  _maskEffect: null,\n  _maskOptions: {\n    inverse: false\n  },\n  _filterEffect: null,\n  /**\n   * @todo Needs docs.\n   * @memberof scene.Container#\n   * @type {Array<Effect>}\n   */\n  effects: [],\n  _markStructureAsChanged() {\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to add.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  addEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index !== -1)\n      return;\n    this.effects.push(effect);\n    this.effects.sort((a, b) => a.priority - b.priority);\n    this._markStructureAsChanged();\n    this._updateIsSimple();\n  },\n  /**\n   * @todo Needs docs.\n   * @param effect - The effect to remove.\n   * @memberof scene.Container#\n   * @ignore\n   */\n  removeEffect(effect) {\n    const index = this.effects.indexOf(effect);\n    if (index === -1)\n      return;\n    this.effects.splice(index, 1);\n    this._markStructureAsChanged();\n    this._updateIsSimple();\n  },\n  set mask(value) {\n    const effect = this._maskEffect;\n    if (effect?.mask === value)\n      return;\n    if (effect) {\n      this.removeEffect(effect);\n      MaskEffectManager.returnMaskEffect(effect);\n      this._maskEffect = null;\n    }\n    if (value === null || value === void 0)\n      return;\n    this._maskEffect = MaskEffectManager.getMaskEffect(value);\n    this.addEffect(this._maskEffect);\n  },\n  /**\n   * Used to set mask and control mask options.\n   * @param options\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.setMask({\n   *     mask: graphics,\n   *     inverse: true,\n   * });\n   * @memberof scene.Container#\n   */\n  setMask(options) {\n    this._maskOptions = {\n      ...this._maskOptions,\n      ...options\n    };\n    if (options.mask) {\n      this.mask = options.mask;\n    }\n    this._markStructureAsChanged();\n  },\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n   * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n   * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n   * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n   * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n   * To remove a mask, set this property to `null`.\n   *\n   * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n   * @example\n   * import { Graphics, Sprite } from 'pixi.js';\n   *\n   * const graphics = new Graphics();\n   * graphics.beginFill(0xFF3300);\n   * graphics.drawRect(50, 250, 100, 100);\n   * graphics.endFill();\n   *\n   * const sprite = new Sprite(texture);\n   * sprite.mask = graphics;\n   * @memberof scene.Container#\n   */\n  get mask() {\n    return this._maskEffect?.mask;\n  },\n  set filters(value) {\n    if (!Array.isArray(value) && value)\n      value = [value];\n    const effect = this._filterEffect || (this._filterEffect = new FilterEffect());\n    value = value;\n    const hasFilters = value?.length > 0;\n    const hadFilters = effect.filters?.length > 0;\n    const didChange = hasFilters !== hadFilters;\n    value = Array.isArray(value) ? value.slice(0) : value;\n    effect.filters = Object.freeze(value);\n    if (didChange) {\n      if (hasFilters) {\n        this.addEffect(effect);\n      } else {\n        this.removeEffect(effect);\n        effect.filters = value ?? null;\n      }\n    }\n  },\n  /**\n   * Sets the filters for the displayObject.\n   * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to `'null'`.\n   * @memberof scene.Container#\n   */\n  get filters() {\n    return this._filterEffect?.filters;\n  },\n  set filterArea(value) {\n    this._filterEffect || (this._filterEffect = new FilterEffect());\n    this._filterEffect.filterArea = value;\n  },\n  /**\n   * The area the filter is applied to. This is used as more of an optimization\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n   *\n   * Also works as an interaction mask.\n   * @memberof scene.Container#\n   */\n  get filterArea() {\n    return this._filterEffect?.filterArea;\n  }\n};\n\nexport { effectsMixin };\n//# sourceMappingURL=effectsMixin.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst findMixin = {\n  /**\n   * The instance label of the object.\n   * @memberof scene.Container#\n   * @member {string} label\n   */\n  label: null,\n  /**\n   * The instance name of the object.\n   * @deprecated since 8.0.0\n   * @see scene.Container#label\n   * @member {string} name\n   * @memberof scene.Container#\n   */\n  get name() {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    return this.label;\n  },\n  set name(value) {\n    deprecation(v8_0_0, \"Container.name property has been removed, use Container.label instead\");\n    this.label = value;\n  },\n  /**\n   * @method getChildByName\n   * @deprecated since 8.0.0\n   * @param {string} name - Instance name.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified name.\n   * @see scene.Container#getChildByLabel\n   * @memberof scene.Container#\n   */\n  getChildByName(name, deep = false) {\n    return this.getChildByLabel(name, deep);\n  },\n  /**\n   * Returns the first child in the container with the specified label.\n   *\n   * Recursive searches are done in a pre-order traversal.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @returns {Container} The child with the specified label.\n   */\n  getChildByLabel(label, deep = false) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label))\n        return child;\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const found = child.getChildByLabel(label, true);\n        if (found) {\n          return found;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Returns all children in the container with the specified label.\n   * @memberof scene.Container#\n   * @param {string|RegExp} label - Instance label.\n   * @param {boolean}[deep=false] - Whether to search recursively\n   * @param {Container[]} [out=[]] - The array to store matching children in.\n   * @returns {Container[]} An array of children with the specified label.\n   */\n  getChildrenByLabel(label, deep = false, out = []) {\n    const children = this.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if (child.label === label || label instanceof RegExp && label.test(child.label)) {\n        out.push(child);\n      }\n    }\n    if (deep) {\n      for (let i = 0; i < children.length; i++) {\n        children[i].getChildrenByLabel(label, true, out);\n      }\n    }\n    return out;\n  }\n};\n\nexport { findMixin };\n//# sourceMappingURL=findMixin.mjs.map\n","import { updateTransformBackwards } from '../bounds/getGlobalBounds.mjs';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool.mjs';\nimport { multiplyColors } from '../utils/multiplyColors.mjs';\n\n\"use strict\";\nfunction bgr2rgb(color) {\n  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);\n}\nconst getGlobalMixin = {\n  /**\n   * Returns the global (compound) alpha of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n   *   - If true: Uses cached worldAlpha from the last render pass for better performance\n   * @returns The resulting alpha value (between 0 and 1)\n   * @example\n   * // Accurate but slower - recalculates entire alpha chain\n   * const preciseAlpha = container.getGlobalAlpha();\n   *\n   * // Faster but may be outdated - uses cached alpha\n   * const cachedAlpha = container.getGlobalAlpha(true);\n   */\n  getGlobalAlpha(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return this.renderGroup.worldAlpha;\n      }\n      if (this.parentRenderGroup) {\n        return this.parentRenderGroup.worldAlpha * this.alpha;\n      }\n      return this.alpha;\n    }\n    let alpha = this.alpha;\n    let current = this.parent;\n    while (current) {\n      alpha *= current.alpha;\n      current = current.parent;\n    }\n    return alpha;\n  },\n  /**\n   * Returns the global transform matrix of the container within the scene.\n   * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire transform chain for accuracy\n   *   - If true: Uses cached worldTransform from the last render pass for better performance\n   * @returns The resulting transformation matrix (either the input matrix or a new one)\n   * @example\n   * // Accurate but slower - recalculates entire transform chain\n   * const preciseTransform = container.getGlobalTransform();\n   *\n   * // Faster but may be outdated - uses cached transform\n   * const cachedTransform = container.getGlobalTransform(undefined, true);\n   *\n   * // Reuse existing matrix\n   * const existingMatrix = new Matrix();\n   * container.getGlobalTransform(existingMatrix);\n   */\n  getGlobalTransform(matrix, skipUpdate) {\n    if (skipUpdate) {\n      return matrix.copyFrom(this.worldTransform);\n    }\n    this.updateLocalTransform();\n    const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());\n    matrix.appendFrom(this.localTransform, parentTransform);\n    matrixPool.return(parentTransform);\n    return matrix;\n  },\n  /**\n   * Returns the global (compound) tint color of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n   *   - If true: Uses cached worldColor from the last render pass for better performance\n   * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n   * @example\n   * // Accurate but slower - recalculates entire tint chain\n   * const preciseTint = container.getGlobalTint();\n   *\n   * // Faster but may be outdated - uses cached tint\n   * const cachedTint = container.getGlobalTint(true);\n   */\n  getGlobalTint(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return bgr2rgb(this.renderGroup.worldColor);\n      }\n      if (this.parentRenderGroup) {\n        return bgr2rgb(\n          multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n        );\n      }\n      return this.tint;\n    }\n    let color = this.localColor;\n    let parent = this.parent;\n    while (parent) {\n      color = multiplyColors(color, parent.localColor);\n      parent = parent.parent;\n    }\n    return bgr2rgb(color);\n  }\n};\n\nexport { bgr2rgb, getGlobalMixin };\n//# sourceMappingURL=getGlobalMixin.mjs.map\n","\"use strict\";\nfunction checkChildrenDidChange(container, previousData) {\n  const children = container.children;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    const uid = child.uid;\n    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;\n    const index = previousData.index;\n    if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {\n      previousData.data[previousData.index] = uid;\n      previousData.data[previousData.index + 1] = didChange;\n      previousData.didChange = true;\n    }\n    previousData.index = index + 2;\n    if (child.children.length) {\n      checkChildrenDidChange(child, previousData);\n    }\n  }\n  return previousData.didChange;\n}\n\nexport { checkChildrenDidChange };\n//# sourceMappingURL=checkChildrenDidChange.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Bounds } from '../bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds.mjs';\nimport { getLocalBounds } from '../bounds/getLocalBounds.mjs';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nconst measureMixin = {\n  _localBoundsCacheId: -1,\n  _localBoundsCacheData: null,\n  _setWidth(value, localWidth) {\n    const sign = Math.sign(this.scale.x) || 1;\n    if (localWidth !== 0) {\n      this.scale.x = value / localWidth * sign;\n    } else {\n      this.scale.x = sign;\n    }\n  },\n  _setHeight(value, localHeight) {\n    const sign = Math.sign(this.scale.y) || 1;\n    if (localHeight !== 0) {\n      this.scale.y = value / localHeight * sign;\n    } else {\n      this.scale.y = sign;\n    }\n  },\n  /**\n   * Retrieves the local bounds of the container as a Bounds object.\n   * @returns - The bounding area.\n   * @memberof scene.Container#\n   */\n  getLocalBounds() {\n    if (!this._localBoundsCacheData) {\n      this._localBoundsCacheData = {\n        data: [],\n        index: 1,\n        didChange: false,\n        localBounds: new Bounds()\n      };\n    }\n    const localBoundsCacheData = this._localBoundsCacheData;\n    localBoundsCacheData.index = 1;\n    localBoundsCacheData.didChange = false;\n    if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {\n      localBoundsCacheData.didChange = true;\n      localBoundsCacheData.data[0] = this._didViewChangeTick;\n    }\n    checkChildrenDidChange(this, localBoundsCacheData);\n    if (localBoundsCacheData.didChange) {\n      getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n    }\n    return localBoundsCacheData.localBounds;\n  },\n  /**\n   * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n   * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost.\n   * @param bounds - Optional bounds to store the result of the bounds calculation.\n   * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n   * @memberof scene.Container#\n   */\n  getBounds(skipUpdate, bounds) {\n    return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n  }\n};\n\nexport { measureMixin };\n//# sourceMappingURL=measureMixin.mjs.map\n","\"use strict\";\nconst onRenderMixin = {\n  _onRender: null,\n  set onRender(func) {\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (!func) {\n      if (this._onRender) {\n        renderGroup?.removeOnRender(this);\n      }\n      this._onRender = null;\n      return;\n    }\n    if (!this._onRender) {\n      renderGroup?.addOnRender(this);\n    }\n    this._onRender = func;\n  },\n  /**\n   * This callback is used when the container is rendered. This is where you should add your custom\n   * logic that is needed to be run every frame.\n   *\n   * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n   * and \"updateTransform\" is no longer called every frame\n   * @example\n   * const container = new Container();\n   * container.onRender = () => {\n   *    container.rotation += 0.01;\n   * };\n   * @memberof scene.Container#\n   */\n  get onRender() {\n    return this._onRender;\n  }\n};\n\nexport { onRenderMixin };\n//# sourceMappingURL=onRenderMixin.mjs.map\n","\"use strict\";\nconst sortMixin = {\n  _zIndex: 0,\n  /**\n   * Should children be sorted by zIndex at the next render call.\n   *\n   * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortDirty: false,\n  /**\n   * If set to true, the container will sort its children by `zIndex` value\n   * when the next render is called, or manually if `sortChildren()` is called.\n   *\n   * This actually changes the order of elements in the array, so should be treated\n   * as a basic solution that is not performant compared to other solutions,\n   * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n   *\n   * Also be aware of that this may not work nicely with the `addChildAt()` function,\n   * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n   * @type {boolean}\n   * @memberof scene.Container#\n   */\n  sortableChildren: false,\n  /**\n   * The zIndex of the container.\n   *\n   * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n   * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n   * and thus rendered on top of other display objects within the same container.\n   * @see scene.Container#sortableChildren\n   * @memberof scene.Container#\n   */\n  get zIndex() {\n    return this._zIndex;\n  },\n  set zIndex(value) {\n    if (this._zIndex === value)\n      return;\n    this._zIndex = value;\n    this.depthOfChildModified();\n  },\n  depthOfChildModified() {\n    if (this.parent) {\n      this.parent.sortableChildren = true;\n      this.parent.sortDirty = true;\n    }\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n  },\n  /**\n   * Sorts children by zIndex.\n   * @memberof scene.Container#\n   */\n  sortChildren() {\n    if (!this.sortDirty)\n      return;\n    this.sortDirty = false;\n    this.children.sort(sortChildren);\n  }\n};\nfunction sortChildren(a, b) {\n  return a._zIndex - b._zIndex;\n}\n\nexport { sortMixin };\n//# sourceMappingURL=sortMixin.mjs.map\n","import { Point } from '../../../maths/point/Point.mjs';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nconst toLocalGlobalMixin = {\n  /**\n   * Returns the global position of the container.\n   * @param point - The optional point to write the global value to.\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - The updated point.\n   * @memberof scene.Container#\n   */\n  getGlobalPosition(point = new Point(), skipUpdate = false) {\n    if (this.parent) {\n      this.parent.toGlobal(this._position, point, skipUpdate);\n    } else {\n      point.x = this._position.x;\n      point.y = this._position.y;\n    }\n    return point;\n  },\n  /**\n   * Calculates the global position of the container.\n   * @param position - The world origin to calculate from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform.\n   * @returns - A point object representing the position of this object.\n   * @memberof scene.Container#\n   */\n  toGlobal(position, point, skipUpdate = false) {\n    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n    point = globalMatrix.apply(position, point);\n    matrixPool.return(globalMatrix);\n    return point;\n  },\n  /**\n   * Calculates the local position of the container relative to another point.\n   * @param position - The world origin to calculate from.\n   * @param from - The Container to calculate the global position from.\n   * @param point - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point).\n   * @param skipUpdate - Should we skip the update transform\n   * @returns - A point object representing the position of this object\n   * @memberof scene.Container#\n   */\n  toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n    point = globalMatrix.applyInverse(position, point);\n    matrixPool.return(globalMatrix);\n    return point;\n  }\n};\n\nexport { toLocalGlobalMixin };\n//# sourceMappingURL=toLocalGlobalMixin.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\n\n\"use strict\";\nclass RenderGroup {\n  constructor() {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this.worldTransform = new Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = { list: [], index: 0 };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet();\n    this._onRenderContainers = [];\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    this.textureNeedsUpdate = true;\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    this.isCachedAsTexture = false;\n    this._matrixDirty = 7;\n  }\n  init(root) {\n    this.root = root;\n    if (root._onRender)\n      this.addOnRender(root);\n    root.didChange = true;\n    const children = root.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  enableCacheAsTexture(options = {}) {\n    this.textureOptions = options;\n    this.isCachedAsTexture = true;\n    this.textureNeedsUpdate = true;\n  }\n  disableCacheAsTexture() {\n    this.isCachedAsTexture = false;\n    if (this.texture) {\n      TexturePool.returnTexture(this.texture);\n      this.texture = null;\n    }\n  }\n  updateCacheTexture() {\n    this.textureNeedsUpdate = true;\n  }\n  reset() {\n    this.renderGroupChildren.length = 0;\n    for (const i in this.childrenToUpdate) {\n      const childrenAtDepth = this.childrenToUpdate[i];\n      childrenAtDepth.list.fill(null);\n      childrenAtDepth.index = 0;\n    }\n    this.childrenRenderablesToUpdate.index = 0;\n    this.childrenRenderablesToUpdate.list.fill(null);\n    this.root = null;\n    this.updateTick = 0;\n    this.structureDidChange = true;\n    this._onRenderContainers.length = 0;\n    this.renderGroupParent = null;\n    this.disableCacheAsTexture();\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    child.parentRenderGroup = this;\n    child.updateTick = -1;\n    if (child.parent === this.root) {\n      child.relativeRenderGroupDepth = 1;\n    } else {\n      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n    }\n    child.didChange = true;\n    this.onChildUpdate(child);\n    if (child.renderGroup) {\n      this.addRenderGroupChild(child.renderGroup);\n      return;\n    }\n    if (child._onRender)\n      this.addOnRender(child);\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.renderGroup) {\n        this.removeOnRender(child);\n      }\n    }\n    child.parentRenderGroup = null;\n    if (child.renderGroup) {\n      this._removeRenderGroupChild(child.renderGroup);\n      return;\n    }\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  removeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  updateRenderable(renderable) {\n    if (renderable.globalDisplayStatus < 7)\n      return;\n    this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n    renderable.didViewUpdate = false;\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n  destroy() {\n    this.disableCacheAsTexture();\n    this.renderGroupParent = null;\n    this.root = null;\n    this.childrenRenderablesToUpdate = null;\n    this.childrenToUpdate = null;\n    this.renderGroupChildren = null;\n    this._onRenderContainers = null;\n    this.instructionSet = null;\n  }\n  getChildren(out = []) {\n    const children = this.root.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  _getChildren(container, out = []) {\n    out.push(container);\n    if (container.renderGroup)\n      return out;\n    const children = container.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  invalidateMatrices() {\n    this._matrixDirty = 7;\n  }\n  /**\n   * Returns the inverse of the world transform matrix.\n   * @returns {Matrix} The inverse of the world transform matrix.\n   */\n  get inverseWorldTransform() {\n    if ((this._matrixDirty & 1) === 0)\n      return this._inverseWorldTransform;\n    this._matrixDirty &= ~1;\n    this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix());\n    return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();\n  }\n  /**\n   * Returns the inverse of the texture offset transform matrix.\n   * @returns {Matrix} The inverse of the texture offset transform matrix.\n   */\n  get textureOffsetInverseTransform() {\n    if ((this._matrixDirty & 2) === 0)\n      return this._textureOffsetInverseTransform;\n    this._matrixDirty &= ~2;\n    this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix());\n    return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(\n      -this._textureBounds.x,\n      -this._textureBounds.y\n    );\n  }\n  /**\n   * Returns the inverse of the parent texture transform matrix.\n   * This is used to properly transform coordinates when rendering into cached textures.\n   * @returns {Matrix} The inverse of the parent texture transform matrix.\n   */\n  get inverseParentTextureTransform() {\n    if ((this._matrixDirty & 4) === 0)\n      return this._inverseParentTextureTransform;\n    this._matrixDirty &= ~4;\n    const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n    if (parentCacheAsTexture) {\n      this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix());\n      return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(\n        -parentCacheAsTexture._textureBounds.x,\n        -parentCacheAsTexture._textureBounds.y\n      );\n    }\n    return this.worldTransform;\n  }\n  /**\n   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n   * or null if no parent is cached as texture.\n   */\n  get cacheToLocalTransform() {\n    if (!this._parentCacheAsTextureRenderGroup)\n      return null;\n    return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n  }\n}\n\nexport { RenderGroup };\n//# sourceMappingURL=RenderGroup.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { cullingMixin } from '../../culling/cullingMixin.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { RAD_TO_DEG, DEG_TO_RAD } from '../../maths/misc/const.mjs';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { uid } from '../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { cacheAsTextureMixin } from './container-mixins/cacheAsTextureMixin.mjs';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin.mjs';\nimport { effectsMixin } from './container-mixins/effectsMixin.mjs';\nimport { findMixin } from './container-mixins/findMixin.mjs';\nimport { bgr2rgb, getGlobalMixin } from './container-mixins/getGlobalMixin.mjs';\nimport { measureMixin } from './container-mixins/measureMixin.mjs';\nimport { onRenderMixin } from './container-mixins/onRenderMixin.mjs';\nimport { sortMixin } from './container-mixins/sortMixin.mjs';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin.mjs';\nimport { RenderGroup } from './RenderGroup.mjs';\nimport { assignWithIgnore } from './utils/assignWithIgnore.mjs';\n\n\"use strict\";\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\nconst UPDATE_COLOR = 1;\nconst UPDATE_BLEND = 2;\nconst UPDATE_VISIBLE = 4;\nconst UPDATE_TRANSFORM = 8;\nclass Container extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    /** unique id for this container */\n    this.uid = uid(\"renderable\");\n    /** @private */\n    this._updateFlags = 15;\n    // the render group this container owns\n    /** @private */\n    this.renderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    this.parentRenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    this.parentRenderGroupIndex = 0;\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    this.didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    this.didViewUpdate = false;\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    this.relativeRenderGroupDepth = 0;\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    this.children = [];\n    /** The display object container that contains this display object. */\n    this.parent = null;\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    this.includeInBuild = true;\n    /** @private */\n    this.measurable = true;\n    /** @private */\n    this.isSimple = true;\n    // / /////////////Transform related props//////////////\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    this.updateTick = -1;\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    this.localTransform = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    this.relativeGroupTransform = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    this.groupTransform = this.relativeGroupTransform;\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    this.destroyed = false;\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    this._position = new ObservablePoint(this, 0, 0);\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    this._scale = defaultScale;\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    this._pivot = defaultPivot;\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    this._skew = defaultSkew;\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cx = 1;\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sx = 0;\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._cy = 0;\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    this._sy = 1;\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    this._rotation = 0;\n    // / COLOR related props //////////////\n    // color stored as ABGR\n    this.localColor = 16777215;\n    this.localAlpha = 1;\n    this.groupAlpha = 1;\n    // A\n    this.groupColor = 16777215;\n    // BGR\n    this.groupColorAlpha = 4294967295;\n    // ABGR\n    // / BLEND related props //////////////\n    /**\n     * @internal\n     * @ignore\n     */\n    this.localBlendMode = \"inherit\";\n    /**\n     * @internal\n     * @ignore\n     */\n    this.groupBlendMode = \"normal\";\n    // / VISIBILITY related props //////////////\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    this.localDisplayStatus = 7;\n    // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    this.globalDisplayStatus = 7;\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    this._didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    this._didViewChangeTick = 0;\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    this._didLocalTransformChangeId = -1;\n    this.effects = [];\n    assignWithIgnore(this, options, {\n      children: true,\n      parent: true,\n      effects: true\n    });\n    options.children?.forEach((child) => this.addChild(child));\n    options.parent?.addChild(this);\n  }\n  /**\n   * Mixes all enumerable properties and methods from a source object to Container.\n   * @param source - The source of properties and methods to mix in.\n   */\n  static mixin(source) {\n    Object.defineProperties(Container.prototype, Object.getOwnPropertyDescriptors(source));\n  }\n  /**\n   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n   * @deprecated since 8.2.6\n   * @ignore\n   */\n  set _didChangeId(value) {\n    this._didViewChangeTick = value >> 12 & 4095;\n    this._didContainerChangeTick = value & 4095;\n  }\n  get _didChangeId() {\n    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;\n  }\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   * @param {...Container} children - The Container(s) to add to the container\n   * @returns {Container} - The first child that was added.\n   */\n  addChild(...children) {\n    if (!this.allowChildren) {\n      deprecation(v8_0_0, \"addChild: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.addChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (child.parent === this) {\n      this.children.splice(this.children.indexOf(child), 1);\n      this.children.push(child);\n      if (renderGroup) {\n        renderGroup.structureDidChange = true;\n      }\n      return child;\n    }\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    this.children.push(child);\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    child.parent = this;\n    child.didChange = true;\n    child._updateFlags = 15;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    this.emit(\"childAdded\", child, this, this.children.length - 1);\n    child.emit(\"added\", this);\n    this._didViewChangeTick++;\n    if (child._zIndex !== 0) {\n      child.depthOfChildModified();\n    }\n    return child;\n  }\n  /**\n   * Removes one or more children from the container.\n   * @param {...Container} children - The Container(s) to remove\n   * @returns {Container} The first child that was removed.\n   */\n  removeChild(...children) {\n    if (children.length > 1) {\n      for (let i = 0; i < children.length; i++) {\n        this.removeChild(children[i]);\n      }\n      return children[0];\n    }\n    const child = children[0];\n    const index = this.children.indexOf(child);\n    if (index > -1) {\n      this._didViewChangeTick++;\n      this.children.splice(index, 1);\n      if (this.renderGroup) {\n        this.renderGroup.removeChild(child);\n      } else if (this.parentRenderGroup) {\n        this.parentRenderGroup.removeChild(child);\n      }\n      child.parent = null;\n      this.emit(\"childRemoved\", child, this, index);\n      child.emit(\"removed\", this);\n    }\n    return child;\n  }\n  /** @ignore */\n  _onUpdate(point) {\n    if (point) {\n      if (point === this._skew) {\n        this._updateSkew();\n      }\n    }\n    this._didContainerChangeTick++;\n    if (this.didChange)\n      return;\n    this.didChange = true;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.onChildUpdate(this);\n    }\n  }\n  set isRenderGroup(value) {\n    if (!!this.renderGroup === value)\n      return;\n    if (value) {\n      this.enableRenderGroup();\n    } else {\n      this.disableRenderGroup();\n    }\n  }\n  /**\n   * Returns true if this container is a render group.\n   * This means that it will be rendered as a separate pass, with its own set of instructions\n   */\n  get isRenderGroup() {\n    return !!this.renderGroup;\n  }\n  /**\n   * Calling this enables a render group for this container.\n   * This means it will be rendered as a separate set of instructions.\n   * The transform of the container will also be handled on the GPU rather than the CPU.\n   */\n  enableRenderGroup() {\n    if (this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    this.renderGroup = BigPool.get(RenderGroup, this);\n    this.groupTransform = Matrix.IDENTITY;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** This will disable the render group for this container. */\n  disableRenderGroup() {\n    if (!this.renderGroup)\n      return;\n    const parentRenderGroup = this.parentRenderGroup;\n    parentRenderGroup?.removeChild(this);\n    BigPool.return(this.renderGroup);\n    this.renderGroup = null;\n    this.groupTransform = this.relativeGroupTransform;\n    parentRenderGroup?.addChild(this);\n    this._updateIsSimple();\n  }\n  /** @ignore */\n  _updateIsSimple() {\n    this.isSimple = !this.renderGroup && this.effects.length === 0;\n  }\n  /**\n   * Current transform of the object based on world (parent) factors.\n   * @readonly\n   */\n  get worldTransform() {\n    this._worldTransform || (this._worldTransform = new Matrix());\n    if (this.renderGroup) {\n      this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n    } else if (this.parentRenderGroup) {\n      this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n    }\n    return this._worldTransform;\n  }\n  /**\n   * The position of the container on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   */\n  get x() {\n    return this._position.x;\n  }\n  set x(value) {\n    this._position.x = value;\n  }\n  /**\n   * The position of the container on the y axis relative to the local coordinates of the parent.\n   * An alias to position.y\n   */\n  get y() {\n    return this._position.y;\n  }\n  set y(value) {\n    this._position.y = value;\n  }\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   * @since 4.0.0\n   */\n  get position() {\n    return this._position;\n  }\n  set position(value) {\n    this._position.copyFrom(value);\n  }\n  /**\n   * The rotation of the object in radians.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get rotation() {\n    return this._rotation;\n  }\n  set rotation(value) {\n    if (this._rotation !== value) {\n      this._rotation = value;\n      this._onUpdate(this._skew);\n    }\n  }\n  /**\n   * The angle of the object in degrees.\n   * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n   */\n  get angle() {\n    return this.rotation * RAD_TO_DEG;\n  }\n  set angle(value) {\n    this.rotation = value * DEG_TO_RAD;\n  }\n  /**\n   * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n   * is the projection of `pivot` in the parent's local space.\n   *\n   * By default, the pivot is the origin (0, 0).\n   * @since 4.0.0\n   */\n  get pivot() {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    return this._pivot;\n  }\n  set pivot(value) {\n    if (this._pivot === defaultPivot) {\n      this._pivot = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._pivot.set(value) : this._pivot.copyFrom(value);\n  }\n  /**\n   * The skew factor for the object in radians.\n   * @since 4.0.0\n   */\n  get skew() {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    return this._skew;\n  }\n  set skew(value) {\n    if (this._skew === defaultSkew) {\n      this._skew = new ObservablePoint(this, 0, 0);\n    }\n    this._skew.copyFrom(value);\n  }\n  /**\n   * The scale factors of this object along the local coordinate axes.\n   *\n   * The default scale is (1, 1).\n   * @since 4.0.0\n   */\n  get scale() {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 1, 1);\n    }\n    return this._scale;\n  }\n  set scale(value) {\n    if (this._scale === defaultScale) {\n      this._scale = new ObservablePoint(this, 0, 0);\n    }\n    typeof value === \"number\" ? this._scale.set(value) : this._scale.copyFrom(value);\n  }\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get width() {\n    return Math.abs(this.scale.x * this.getLocalBounds().width);\n  }\n  set width(value) {\n    const localWidth = this.getLocalBounds().width;\n    this._setWidth(value, localWidth);\n  }\n  /**\n   * The height of the Container, setting this will actually modify the scale to achieve the value set.\n   * @memberof scene.Container#\n   */\n  get height() {\n    return Math.abs(this.scale.y * this.getLocalBounds().height);\n  }\n  set height(value) {\n    const localHeight = this.getLocalBounds().height;\n    this._setHeight(value, localHeight);\n  }\n  /**\n   * Retrieves the size of the container as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the container.\n   * @memberof scene.Container#\n   */\n  getSize(out) {\n    if (!out) {\n      out = {};\n    }\n    const bounds = this.getLocalBounds();\n    out.width = Math.abs(this.scale.x * bounds.width);\n    out.height = Math.abs(this.scale.y * bounds.height);\n    return out;\n  }\n  /**\n   * Sets the size of the container to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   * @memberof scene.Container#\n   */\n  setSize(value, height) {\n    const size = this.getLocalBounds();\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, size.width);\n    height !== void 0 && this._setHeight(height, size.height);\n  }\n  /** Called when the skew or the rotation changes. */\n  _updateSkew() {\n    const rotation = this._rotation;\n    const skew = this._skew;\n    this._cx = Math.cos(rotation + skew._y);\n    this._sx = Math.sin(rotation + skew._y);\n    this._cy = -Math.sin(rotation - skew._x);\n    this._sy = Math.cos(rotation - skew._x);\n  }\n  /**\n   * Updates the transform properties of the container (accepts partial values).\n   * @param {object} opts - The options for updating the transform.\n   * @param {number} opts.x - The x position of the container.\n   * @param {number} opts.y - The y position of the container.\n   * @param {number} opts.scaleX - The scale factor on the x-axis.\n   * @param {number} opts.scaleY - The scale factor on the y-axis.\n   * @param {number} opts.rotation - The rotation of the container, in radians.\n   * @param {number} opts.skewX - The skew factor on the x-axis.\n   * @param {number} opts.skewY - The skew factor on the y-axis.\n   * @param {number} opts.pivotX - The x coordinate of the pivot point.\n   * @param {number} opts.pivotY - The y coordinate of the pivot point.\n   */\n  updateTransform(opts) {\n    this.position.set(\n      typeof opts.x === \"number\" ? opts.x : this.position.x,\n      typeof opts.y === \"number\" ? opts.y : this.position.y\n    );\n    this.scale.set(\n      typeof opts.scaleX === \"number\" ? opts.scaleX || 1 : this.scale.x,\n      typeof opts.scaleY === \"number\" ? opts.scaleY || 1 : this.scale.y\n    );\n    this.rotation = typeof opts.rotation === \"number\" ? opts.rotation : this.rotation;\n    this.skew.set(\n      typeof opts.skewX === \"number\" ? opts.skewX : this.skew.x,\n      typeof opts.skewY === \"number\" ? opts.skewY : this.skew.y\n    );\n    this.pivot.set(\n      typeof opts.pivotX === \"number\" ? opts.pivotX : this.pivot.x,\n      typeof opts.pivotY === \"number\" ? opts.pivotY : this.pivot.y\n    );\n    return this;\n  }\n  /**\n   * Updates the local transform using the given matrix.\n   * @param matrix - The matrix to use for updating the transform.\n   */\n  setFromMatrix(matrix) {\n    matrix.decompose(this);\n  }\n  /** Updates the local transform. */\n  updateLocalTransform() {\n    const localTransformChangeId = this._didContainerChangeTick;\n    if (this._didLocalTransformChangeId === localTransformChangeId)\n      return;\n    this._didLocalTransformChangeId = localTransformChangeId;\n    const lt = this.localTransform;\n    const scale = this._scale;\n    const pivot = this._pivot;\n    const position = this._position;\n    const sx = scale._x;\n    const sy = scale._y;\n    const px = pivot._x;\n    const py = pivot._y;\n    lt.a = this._cx * sx;\n    lt.b = this._sx * sx;\n    lt.c = this._cy * sy;\n    lt.d = this._sy * sy;\n    lt.tx = position._x - (px * lt.a + py * lt.c);\n    lt.ty = position._y - (px * lt.b + py * lt.d);\n  }\n  // / ///// color related stuff\n  set alpha(value) {\n    if (value === this.localAlpha)\n      return;\n    this.localAlpha = value;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /** The opacity of the object. */\n  get alpha() {\n    return this.localAlpha;\n  }\n  set tint(value) {\n    const tempColor = Color.shared.setValue(value ?? 16777215);\n    const bgr = tempColor.toBgrNumber();\n    if (bgr === this.localColor)\n      return;\n    this.localColor = bgr;\n    this._updateFlags |= UPDATE_COLOR;\n    this._onUpdate();\n  }\n  /**\n   * The tint applied to the sprite. This is a hex value.\n   *\n   * A value of 0xFFFFFF will remove any tint effect.\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return bgr2rgb(this.localColor);\n  }\n  // / //////////////// blend related stuff\n  set blendMode(value) {\n    if (this.localBlendMode === value)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_BLEND;\n    this.localBlendMode = value;\n    this._onUpdate();\n  }\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this.localBlendMode;\n  }\n  // / ///////// VISIBILITY / RENDERABLE /////////////////\n  /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n  get visible() {\n    return !!(this.localDisplayStatus & 2);\n  }\n  set visible(value) {\n    const valueNumber = value ? 2 : 0;\n    if ((this.localDisplayStatus & 2) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 2;\n    this._onUpdate();\n  }\n  /** @ignore */\n  get culled() {\n    return !(this.localDisplayStatus & 4);\n  }\n  /** @ignore */\n  set culled(value) {\n    const valueNumber = value ? 0 : 4;\n    if ((this.localDisplayStatus & 4) === valueNumber)\n      return;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 4;\n    this._onUpdate();\n  }\n  /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n  get renderable() {\n    return !!(this.localDisplayStatus & 1);\n  }\n  set renderable(value) {\n    const valueNumber = value ? 1 : 0;\n    if ((this.localDisplayStatus & 1) === valueNumber)\n      return;\n    this._updateFlags |= UPDATE_VISIBLE;\n    this.localDisplayStatus ^= 1;\n    if (this.parentRenderGroup) {\n      this.parentRenderGroup.structureDidChange = true;\n    }\n    this._onUpdate();\n  }\n  /** Whether or not the object should be rendered. */\n  get isRenderable() {\n    return this.localDisplayStatus === 7 && this.groupAlpha > 0;\n  }\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n   * is set to true it should destroy the texture of the child sprite\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true it should destroy the texture source of the child sprite\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true it should destroy the context of the child graphics\n   */\n  destroy(options = false) {\n    if (this.destroyed)\n      return;\n    this.destroyed = true;\n    let oldChildren;\n    if (this.children.length) {\n      oldChildren = this.removeChildren(0, this.children.length);\n    }\n    this.removeFromParent();\n    this.parent = null;\n    this._maskEffect = null;\n    this._filterEffect = null;\n    this.effects = null;\n    this._position = null;\n    this._scale = null;\n    this._pivot = null;\n    this._skew = null;\n    this.emit(\"destroyed\", this);\n    this.removeAllListeners();\n    const destroyChildren = typeof options === \"boolean\" ? options : options?.children;\n    if (destroyChildren && oldChildren) {\n      for (let i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n    this.renderGroup?.destroy();\n    this.renderGroup = null;\n  }\n}\nContainer.mixin(childrenHelperMixin);\nContainer.mixin(toLocalGlobalMixin);\nContainer.mixin(onRenderMixin);\nContainer.mixin(measureMixin);\nContainer.mixin(effectsMixin);\nContainer.mixin(findMixin);\nContainer.mixin(sortMixin);\nContainer.mixin(cullingMixin);\nContainer.mixin(cacheAsTextureMixin);\nContainer.mixin(getGlobalMixin);\n\nexport { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_TRANSFORM, UPDATE_VISIBLE };\n//# sourceMappingURL=Container.mjs.map\n","\"use strict\";\nfunction assignWithIgnore(target, options, ignore = {}) {\n  for (const key in options) {\n    if (!ignore[key] && options[key] !== void 0) {\n      target[key] = options[key];\n    }\n  }\n}\n\nexport { assignWithIgnore };\n//# sourceMappingURL=assignWithIgnore.mjs.map\n","\"use strict\";\nconst cullingMixin = {\n  cullArea: null,\n  cullable: false,\n  cullableChildren: true\n};\n\nexport { cullingMixin };\n//# sourceMappingURL=cullingMixin.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../maths/shapes/Rectangle.mjs';\n\n\"use strict\";\nconst defaultMatrix = new Matrix();\nclass Bounds {\n  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {\n    /** @default Infinity */\n    this.minX = Infinity;\n    /** @default Infinity */\n    this.minY = Infinity;\n    /** @default -Infinity */\n    this.maxX = -Infinity;\n    /** @default -Infinity */\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if bounds are empty.\n   * @returns - True if empty.\n   */\n  isEmpty() {\n    return this.minX > this.maxX || this.minY > this.maxY;\n  }\n  /** The bounding rectangle of the bounds. */\n  get rectangle() {\n    if (!this._rectangle) {\n      this._rectangle = new Rectangle();\n    }\n    const rectangle = this._rectangle;\n    if (this.minX > this.maxX || this.minY > this.maxY) {\n      rectangle.x = 0;\n      rectangle.y = 0;\n      rectangle.width = 0;\n      rectangle.height = 0;\n    } else {\n      rectangle.copyFromBounds(this);\n    }\n    return rectangle;\n  }\n  /** Clears the bounds and resets. */\n  clear() {\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = -Infinity;\n    this.maxY = -Infinity;\n    this.matrix = defaultMatrix;\n    return this;\n  }\n  /**\n   * Sets the bounds.\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   */\n  set(x0, y0, x1, y1) {\n    this.minX = x0;\n    this.minY = y0;\n    this.maxX = x1;\n    this.maxY = y1;\n  }\n  /**\n   * Adds sprite frame\n   * @param x0 - left X of frame\n   * @param y0 - top Y of frame\n   * @param x1 - right X of frame\n   * @param y1 - bottom Y of frame\n   * @param matrix\n   */\n  addFrame(x0, y0, x1, y1, matrix) {\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    let x = a * x0 + c * y0 + tx;\n    let y = b * x0 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y0 + tx;\n    y = b * x1 + d * y0 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x0 + c * y1 + tx;\n    y = b * x0 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    x = a * x1 + c * y1 + tx;\n    y = b * x1 + d * y1 + ty;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Adds a rectangle to the bounds.\n   * @param rect - The rectangle to be added.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  addRect(rect, matrix) {\n    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n  }\n  /**\n   * Adds other {@link Bounds}.\n   * @param bounds - The Bounds to be added\n   * @param matrix\n   */\n  addBounds(bounds, matrix) {\n    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n  }\n  /**\n   * Adds other Bounds, masked with Bounds.\n   * @param mask - The Bounds to be added.\n   */\n  addBoundsMask(mask) {\n    this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n    this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n  }\n  /**\n   * Adds other Bounds, multiplied with matrix.\n   * @param matrix - The matrix to apply to the bounds.\n   */\n  applyMatrix(matrix) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    const { a, b, c, d, tx, ty } = matrix;\n    let x = a * minX + c * minY + tx;\n    let y = b * minX + d * minY + ty;\n    this.minX = x;\n    this.minY = y;\n    this.maxX = x;\n    this.maxY = y;\n    x = a * maxX + c * minY + tx;\n    y = b * maxX + d * minY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * minX + c * maxY + tx;\n    y = b * minX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n    x = a * maxX + c * maxY + tx;\n    y = b * maxX + d * maxY + ty;\n    this.minX = x < this.minX ? x : this.minX;\n    this.minY = y < this.minY ? y : this.minY;\n    this.maxX = x > this.maxX ? x : this.maxX;\n    this.maxY = y > this.maxY ? y : this.maxY;\n  }\n  /**\n   * Resizes the bounds object to include the given rectangle.\n   * @param rect - The rectangle to be included.\n   */\n  fit(rect) {\n    if (this.minX < rect.left)\n      this.minX = rect.left;\n    if (this.maxX > rect.right)\n      this.maxX = rect.right;\n    if (this.minY < rect.top)\n      this.minY = rect.top;\n    if (this.maxY > rect.bottom)\n      this.maxY = rect.bottom;\n    return this;\n  }\n  /**\n   * Resizes the bounds object to include the given bounds.\n   * @param left - The left value of the bounds.\n   * @param right - The right value of the bounds.\n   * @param top - The top value of the bounds.\n   * @param bottom - The bottom value of the bounds.\n   */\n  fitBounds(left, right, top, bottom) {\n    if (this.minX < left)\n      this.minX = left;\n    if (this.maxX > right)\n      this.maxX = right;\n    if (this.minY < top)\n      this.minY = top;\n    if (this.maxY > bottom)\n      this.maxY = bottom;\n    return this;\n  }\n  /**\n   * Pads bounds object, making it grow in all directions.\n   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n   * @param paddingX - The horizontal padding amount.\n   * @param paddingY - The vertical padding amount.\n   */\n  pad(paddingX, paddingY = paddingX) {\n    this.minX -= paddingX;\n    this.maxX += paddingX;\n    this.minY -= paddingY;\n    this.maxY += paddingY;\n    return this;\n  }\n  /** Ceils the bounds. */\n  ceil() {\n    this.minX = Math.floor(this.minX);\n    this.minY = Math.floor(this.minY);\n    this.maxX = Math.ceil(this.maxX);\n    this.maxY = Math.ceil(this.maxY);\n    return this;\n  }\n  /** Clones the bounds. */\n  clone() {\n    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n  }\n  /**\n   * Scales the bounds by the given values\n   * @param x - The X value to scale by.\n   * @param y - The Y value to scale by.\n   */\n  scale(x, y = x) {\n    this.minX *= x;\n    this.minY *= y;\n    this.maxX *= x;\n    this.maxY *= y;\n    return this;\n  }\n  /** the x value of the bounds. */\n  get x() {\n    return this.minX;\n  }\n  set x(value) {\n    const width = this.maxX - this.minX;\n    this.minX = value;\n    this.maxX = value + width;\n  }\n  /** the y value of the bounds. */\n  get y() {\n    return this.minY;\n  }\n  set y(value) {\n    const height = this.maxY - this.minY;\n    this.minY = value;\n    this.maxY = value + height;\n  }\n  /** the width value of the bounds. */\n  get width() {\n    return this.maxX - this.minX;\n  }\n  set width(value) {\n    this.maxX = this.minX + value;\n  }\n  /** the height value of the bounds. */\n  get height() {\n    return this.maxY - this.minY;\n  }\n  set height(value) {\n    this.maxY = this.minY + value;\n  }\n  /** the left value of the bounds. */\n  get left() {\n    return this.minX;\n  }\n  /** the right value of the bounds. */\n  get right() {\n    return this.maxX;\n  }\n  /** the top value of the bounds. */\n  get top() {\n    return this.minY;\n  }\n  /** the bottom value of the bounds. */\n  get bottom() {\n    return this.maxY;\n  }\n  /** Is the bounds positive. */\n  get isPositive() {\n    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;\n  }\n  get isValid() {\n    return this.minX + this.minY !== Infinity;\n  }\n  /**\n   * Adds screen vertices from array\n   * @param vertexData - calculated vertices\n   * @param beginOffset - begin offset\n   * @param endOffset - end offset, excluded\n   * @param matrix\n   */\n  addVertexData(vertexData, beginOffset, endOffset, matrix) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    matrix || (matrix = this.matrix);\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    for (let i = beginOffset; i < endOffset; i += 2) {\n      const localX = vertexData[i];\n      const localY = vertexData[i + 1];\n      const x = a * localX + c * localY + tx;\n      const y = b * localX + d * localY + ty;\n      minX = x < minX ? x : minX;\n      minY = y < minY ? y : minY;\n      maxX = x > maxX ? x : maxX;\n      maxY = y > maxY ? y : maxY;\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /**\n   * Checks if the point is contained within the bounds.\n   * @param x - x coordinate\n   * @param y - y coordinate\n   */\n  containsPoint(x, y) {\n    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n  }\n  /**\n   * Copies the bounds from another bounds object.\n   * @param bounds - The bounds to copy from.\n   * @returns - This bounds object.\n   */\n  copyFrom(bounds) {\n    this.minX = bounds.minX;\n    this.minY = bounds.minY;\n    this.maxX = bounds.maxX;\n    this.maxY = bounds.maxY;\n    return this;\n  }\n}\n\nexport { Bounds };\n//# sourceMappingURL=Bounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nfunction getGlobalBounds(target, skipUpdateTransform, bounds) {\n  bounds.clear();\n  let parentTransform;\n  let pooledMatrix;\n  if (target.parent) {\n    if (!skipUpdateTransform) {\n      pooledMatrix = matrixPool.get().identity();\n      parentTransform = updateTransformBackwards(target, pooledMatrix);\n    } else {\n      parentTransform = target.parent.worldTransform;\n    }\n  } else {\n    parentTransform = Matrix.IDENTITY;\n  }\n  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n  if (pooledMatrix) {\n    matrixPool.return(pooledMatrix);\n  }\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {\n  if (!target.visible || !target.measurable)\n    return;\n  let worldTransform;\n  if (!skipUpdateTransform) {\n    target.updateLocalTransform();\n    worldTransform = matrixPool.get();\n    worldTransform.appendFrom(target.localTransform, parentTransform);\n  } else {\n    worldTransform = target.worldTransform;\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, worldTransform);\n  } else {\n    if (target.bounds) {\n      bounds.matrix = worldTransform;\n      bounds.addBounds(target.bounds);\n    }\n    for (let i = 0; i < target.children.length; i++) {\n      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addBounds?.(bounds);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  if (!skipUpdateTransform) {\n    matrixPool.return(worldTransform);\n  }\n}\nfunction updateTransformBackwards(target, parentTransform) {\n  const parent = target.parent;\n  if (parent) {\n    updateTransformBackwards(parent, parentTransform);\n    parent.updateLocalTransform();\n    parentTransform.append(parent.localTransform);\n  }\n  return parentTransform;\n}\n\nexport { _getGlobalBounds, getGlobalBounds, updateTransformBackwards };\n//# sourceMappingURL=getGlobalBounds.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\nimport { matrixPool, boundsPool } from './utils/matrixAndBoundsPool.mjs';\n\n\"use strict\";\nfunction getLocalBounds(target, bounds, relativeMatrix) {\n  bounds.clear();\n  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);\n  _getLocalBounds(target, bounds, relativeMatrix, target, true);\n  if (!bounds.isValid) {\n    bounds.set(0, 0, 0, 0);\n  }\n  return bounds;\n}\nfunction _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {\n  let relativeTransform;\n  if (!isRoot) {\n    if (!target.visible || !target.measurable)\n      return;\n    target.updateLocalTransform();\n    const localTransform = target.localTransform;\n    relativeTransform = matrixPool.get();\n    relativeTransform.appendFrom(localTransform, parentTransform);\n  } else {\n    relativeTransform = matrixPool.get();\n    relativeTransform = parentTransform.copyTo(relativeTransform);\n  }\n  const parentBounds = bounds;\n  const preserveBounds = !!target.effects.length;\n  if (preserveBounds) {\n    bounds = boundsPool.get().clear();\n  }\n  if (target.boundsArea) {\n    bounds.addRect(target.boundsArea, relativeTransform);\n  } else {\n    if (target.renderPipeId) {\n      bounds.matrix = relativeTransform;\n      bounds.addBounds(target.bounds);\n    }\n    const children = target.children;\n    for (let i = 0; i < children.length; i++) {\n      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n    }\n  }\n  if (preserveBounds) {\n    for (let i = 0; i < target.effects.length; i++) {\n      target.effects[i].addLocalBounds?.(bounds, rootContainer);\n    }\n    parentBounds.addBounds(bounds, Matrix.IDENTITY);\n    boundsPool.return(bounds);\n  }\n  matrixPool.return(relativeTransform);\n}\nfunction getParent(target, root, matrix) {\n  const parent = target.parent;\n  if (!parent) {\n    warn(\"Item is not inside the root container\");\n    return;\n  }\n  if (parent !== root) {\n    getParent(parent, root, matrix);\n    parent.updateLocalTransform();\n    matrix.append(parent.localTransform);\n  }\n}\n\nexport { getLocalBounds, getParent };\n//# sourceMappingURL=getLocalBounds.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Pool } from '../../../../utils/pool/Pool.mjs';\nimport { Bounds } from '../Bounds.mjs';\n\n\"use strict\";\nconst matrixPool = new Pool(Matrix);\nconst boundsPool = new Pool(Bounds);\n\nexport { boundsPool, matrixPool };\n//# sourceMappingURL=matrixAndBoundsPool.mjs.map\n","import { multiplyHexColors } from './multiplyHexColors.mjs';\n\n\"use strict\";\nconst WHITE_BGR = 16777215;\nfunction multiplyColors(localBGRColor, parentBGRColor) {\n  if (localBGRColor === WHITE_BGR) {\n    return parentBGRColor;\n  }\n  if (parentBGRColor === WHITE_BGR) {\n    return localBGRColor;\n  }\n  return multiplyHexColors(localBGRColor, parentBGRColor);\n}\n\nexport { multiplyColors };\n//# sourceMappingURL=multiplyColors.mjs.map\n","\"use strict\";\nfunction multiplyHexColors(color1, color2) {\n  if (color1 === 16777215 || !color2)\n    return color2;\n  if (color2 === 16777215 || !color1)\n    return color1;\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 * r2 / 255 | 0;\n  const g = g1 * g2 / 255 | 0;\n  const b = b1 * b2 / 255 | 0;\n  return (r << 16) + (g << 8) + b;\n}\n\nexport { multiplyHexColors };\n//# sourceMappingURL=multiplyHexColors.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors.mjs';\n\n\"use strict\";\nconst identityMatrix = new Matrix();\nclass BatchableGraphics {\n  constructor() {\n    this.packAsQuad = false;\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    this.applyTransform = true;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n  }\n  get uvs() {\n    return this.geometryData.uvs;\n  }\n  get positions() {\n    return this.geometryData.vertices;\n  }\n  get indices() {\n    return this.geometryData.indices;\n  }\n  get blendMode() {\n    if (this.applyTransform) {\n      return this.renderable.groupBlendMode;\n    }\n    return \"normal\";\n  }\n  get color() {\n    const rgb = this.baseColor;\n    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;\n    const renderable = this.renderable;\n    if (renderable) {\n      return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);\n    }\n    return bgr + (this.alpha * 255 << 24);\n  }\n  get transform() {\n    return this.renderable?.groupTransform || identityMatrix;\n  }\n  copyTo(gpuBuffer) {\n    gpuBuffer.indexOffset = this.indexOffset;\n    gpuBuffer.indexSize = this.indexSize;\n    gpuBuffer.attributeOffset = this.attributeOffset;\n    gpuBuffer.attributeSize = this.attributeSize;\n    gpuBuffer.baseColor = this.baseColor;\n    gpuBuffer.alpha = this.alpha;\n    gpuBuffer.texture = this.texture;\n    gpuBuffer.geometryData = this.geometryData;\n    gpuBuffer.topology = this.topology;\n  }\n  reset() {\n    this.applyTransform = true;\n    this.renderable = null;\n    this.topology = \"triangle-list\";\n  }\n}\n\nexport { BatchableGraphics };\n//# sourceMappingURL=BatchableGraphics.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../../view/ViewContainer.mjs';\nimport { GraphicsContext } from './GraphicsContext.mjs';\n\n\"use strict\";\nclass Graphics extends ViewContainer {\n  /**\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    this.renderPipeId = \"graphics\";\n    if (!context) {\n      this._context = this._ownedContext = new GraphicsContext();\n    } else {\n      this._context = context;\n    }\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    this._context.off(\"update\", this.onViewUpdate, this);\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphic.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Graphics objects do not need to update their bounds as the context handles this.\n   * @private\n   */\n  updateBounds() {\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context\n   * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context\n   * @param {boolean} [options.context=false] - Should destroy the context\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or\n   * pattern object, or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   * or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more\n   * complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * The fill style to use.\n   * @type {ConvertedFillStyle}\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * The stroke style to use.\n   * @type {ConvertedStrokeStyle}\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object.\n   * Note that only the context of the object is cloned, not its transform (position,scale,etc)\n   * @param deep - Whether to create a deep clone of the graphics object. If false, the context\n   * will be shared between the two objects (default false). If true, the context will be\n   * cloned (recommended if you need to modify the context in any way).\n   * @returns - A clone of the graphics object\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation(v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation(v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    if (color !== void 0)\n      fillStyle.color = color;\n    if (alpha !== void 0)\n      fillStyle.alpha = alpha;\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation(v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation(v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation(v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation(v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation(v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexport { Graphics };\n//# sourceMappingURL=Graphics.mjs.map\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Circle {\n  /**\n   * @param x - The X coordinate of the center of this circle\n   * @param y - The Y coordinate of the center of this circle\n   * @param radius - The radius of the circle\n   */\n  constructor(x = 0, y = 0, radius = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'circle'\n     */\n    this.type = \"circle\";\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n  }\n  /**\n   * Creates a clone of this Circle instance\n   * @returns A copy of the Circle\n   */\n  clone() {\n    return new Circle(this.x, this.y, this.radius);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  contains(x, y) {\n    if (this.radius <= 0)\n      return false;\n    const r2 = this.radius * this.radius;\n    let dx = this.x - x;\n    let dy = this.y - y;\n    dx *= dx;\n    dy *= dy;\n    return dx + dy <= r2;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width - The width of the line to check\n   * @returns Whether the x/y coordinates are within this Circle\n   */\n  strokeContains(x, y, width) {\n    if (this.radius === 0)\n      return false;\n    const dx = this.x - x;\n    const dy = this.y - y;\n    const r = this.radius;\n    const w2 = width / 2;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance < r + w2 && distance > r - w2;\n  }\n  /**\n   * Returns the framing rectangle of the circle as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.x = this.x - this.radius;\n    out.y = this.y - this.radius;\n    out.width = this.radius * 2;\n    out.height = this.radius * 2;\n    return out;\n  }\n  /**\n   * Copies another circle to this one.\n   * @param circle - The circle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(circle) {\n    this.x = circle.x;\n    this.y = circle.y;\n    this.radius = circle.radius;\n    return this;\n  }\n  /**\n   * Copies this circle to another one.\n   * @param circle - The circle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(circle) {\n    circle.copyFrom(this);\n    return circle;\n  }\n  toString() {\n    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n  }\n}\n\nexport { Circle };\n//# sourceMappingURL=Circle.mjs.map\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Ellipse {\n  /**\n   * @param x - The X coordinate of the center of this ellipse\n   * @param y - The Y coordinate of the center of this ellipse\n   * @param halfWidth - The half width of this ellipse\n   * @param halfHeight - The half height of this ellipse\n   */\n  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'ellipse'\n     */\n    this.type = \"ellipse\";\n    this.x = x;\n    this.y = y;\n    this.halfWidth = halfWidth;\n    this.halfHeight = halfHeight;\n  }\n  /**\n   * Creates a clone of this Ellipse instance\n   * @returns {Ellipse} A copy of the ellipse\n   */\n  clone() {\n    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  contains(x, y) {\n    if (this.halfWidth <= 0 || this.halfHeight <= 0) {\n      return false;\n    }\n    let normx = (x - this.x) / this.halfWidth;\n    let normy = (y - this.y) / this.halfHeight;\n    normx *= normx;\n    normy *= normy;\n    return normx + normy <= 1;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this ellipse including stroke\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param width\n   * @returns Whether the x/y coords are within this ellipse\n   */\n  strokeContains(x, y, width) {\n    const { halfWidth, halfHeight } = this;\n    if (halfWidth <= 0 || halfHeight <= 0) {\n      return false;\n    }\n    const halfStrokeWidth = width / 2;\n    const innerA = halfWidth - halfStrokeWidth;\n    const innerB = halfHeight - halfStrokeWidth;\n    const outerA = halfWidth + halfStrokeWidth;\n    const outerB = halfHeight + halfStrokeWidth;\n    const normalizedX = x - this.x;\n    const normalizedY = y - this.y;\n    const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);\n    const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);\n    return innerEllipse > 1 && outerEllipse <= 1;\n  }\n  /**\n   * Returns the framing rectangle of the ellipse as a Rectangle object\n   * @param out\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.x = this.x - this.halfWidth;\n    out.y = this.y - this.halfHeight;\n    out.width = this.halfWidth * 2;\n    out.height = this.halfHeight * 2;\n    return out;\n  }\n  /**\n   * Copies another ellipse to this one.\n   * @param ellipse - The ellipse to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(ellipse) {\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    this.halfWidth = ellipse.halfWidth;\n    this.halfHeight = ellipse.halfHeight;\n    return this;\n  }\n  /**\n   * Copies this ellipse to another one.\n   * @param ellipse - The ellipse to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(ellipse) {\n    ellipse.copyFrom(this);\n    return ellipse;\n  }\n  toString() {\n    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n  }\n}\n\nexport { Ellipse };\n//# sourceMappingURL=Ellipse.mjs.map\n","\"use strict\";\nfunction squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {\n  const a = x - x1;\n  const b = y - y1;\n  const c = x2 - x1;\n  const d = y2 - y1;\n  const dot = a * c + b * d;\n  const lenSq = c * c + d * d;\n  let param = -1;\n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  let xx;\n  let yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * c;\n    yy = y1 + param * d;\n  }\n  const dx = x - xx;\n  const dy = y - yy;\n  return dx * dx + dy * dy;\n}\n\nexport { squaredDistanceToLineSegment };\n//# sourceMappingURL=squaredDistanceToLineSegment.mjs.map\n","import { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment.mjs';\nimport { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    this.type = \"polygon\";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== \"number\") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth) {\n    const halfStrokeWidth = strokeWidth / 2;\n    const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;\n    const { points } = this;\n    const iterationLength = points.length - (this.closePath ? 0 : 2);\n    for (let i = 0; i < iterationLength; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSqrd = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      if (distanceSqrd <= halfStrokeWidthSqrd) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, \"\")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\nexport { Polygon };\n//# sourceMappingURL=Polygon.mjs.map\n","import { Rectangle } from './Rectangle.mjs';\n\n\"use strict\";\nconst isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {\n  const dx = pX - cornerX;\n  const dy = pY - cornerY;\n  const distance = Math.sqrt(dx * dx + dy * dy);\n  return distance >= radius - halfStrokeWidth && distance <= radius + halfStrokeWidth;\n};\nclass RoundedRectangle {\n  /**\n   * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n   * @param width - The overall width of this rounded rectangle\n   * @param height - The overall height of this rounded rectangle\n   * @param radius - Controls the radius of the rounded corners\n   */\n  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'roundedRectangle'\n     */\n    this.type = \"roundedRectangle\";\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.radius = radius;\n  }\n  /**\n   * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle());\n    out.x = this.x;\n    out.y = this.y;\n    out.width = this.width;\n    out.height = this.height;\n    return out;\n  }\n  /**\n   * Creates a clone of this Rounded Rectangle.\n   * @returns - A copy of the rounded rectangle.\n   */\n  clone() {\n    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n  }\n  /**\n   * Copies another rectangle to this one.\n   * @param rectangle - The rectangle to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(rectangle) {\n    this.x = rectangle.x;\n    this.y = rectangle.y;\n    this.width = rectangle.width;\n    this.height = rectangle.height;\n    return this;\n  }\n  /**\n   * Copies this rectangle to another one.\n   * @param rectangle - The rectangle to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(rectangle) {\n    rectangle.copyFrom(this);\n    return rectangle;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this Rounded Rectangle.\n   */\n  contains(x, y) {\n    if (this.width <= 0 || this.height <= 0) {\n      return false;\n    }\n    if (x >= this.x && x <= this.x + this.width) {\n      if (y >= this.y && y <= this.y + this.height) {\n        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {\n          return true;\n        }\n        let dx = x - (this.x + radius);\n        let dy = y - (this.y + radius);\n        const radius2 = radius * radius;\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + this.width - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dy = y - (this.y + this.height - radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n        dx = x - (this.x + radius);\n        if (dx * dx + dy * dy <= radius2) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n   * @param pX - The X coordinate of the point to test\n   * @param pY - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @returns Whether the x/y coordinates are within this rectangle\n   */\n  strokeContains(pX, pY, strokeWidth) {\n    const { x, y, width, height, radius } = this;\n    const halfStrokeWidth = strokeWidth / 2;\n    const innerX = x + radius;\n    const innerY = y + radius;\n    const innerWidth = width - radius * 2;\n    const innerHeight = height - radius * 2;\n    const rightBound = x + width;\n    const bottomBound = y + height;\n    if ((pX >= x - halfStrokeWidth && pX <= x + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {\n      return true;\n    }\n    if ((pY >= y - halfStrokeWidth && pY <= y + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {\n      return true;\n    }\n    return (\n      // Top-left\n      pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)\n    );\n  }\n  toString() {\n    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;\n  }\n}\n\nexport { RoundedRectangle };\n//# sourceMappingURL=RoundedRectangle.mjs.map\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\nfunction buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {\n  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x34 = (x3 + x4) / 2;\n  const y34 = (y3 + y4) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  const x234 = (x23 + x34) / 2;\n  const y234 = (y23 + y34) / 2;\n  const x1234 = (x123 + x234) / 2;\n  const y1234 = (y123 + y234) / 2;\n  if (level > 0) {\n    let dx = x4 - x1;\n    let dy = y4 - y1;\n    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);\n    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);\n    let da1;\n    let da2;\n    if (d2 > FLT_EPSILON && d3 > FLT_EPSILON) {\n      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        const a23 = Math.atan2(y3 - y2, x3 - x2);\n        da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n        da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da2 >= pi)\n          da2 = 2 * pi - da2;\n        if (da1 + da2 < mAngleTolerance) {\n          points.push(x1234, y1234);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n          if (da2 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else if (d2 > FLT_EPSILON) {\n      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x2, y2);\n            return;\n          }\n        }\n      }\n    } else if (d3 > FLT_EPSILON) {\n      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {\n        if (mAngleTolerance < curveAngleToleranceEpsilon) {\n          points.push(x1234, y1234);\n          return;\n        }\n        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n        if (da1 >= pi)\n          da1 = 2 * pi - da1;\n        if (da1 < mAngleTolerance) {\n          points.push(x2, y2);\n          points.push(x3, y3);\n          return;\n        }\n        if (mCuspLimit !== 0) {\n          if (da1 > mCuspLimit) {\n            points.push(x3, y3);\n            return;\n          }\n        }\n      }\n    } else {\n      dx = x1234 - (x1 + x4) / 2;\n      dy = y1234 - (y1 + y4) / 2;\n      if (dx * dx + dy * dy <= distanceTolerance) {\n        points.push(x1234, y1234);\n        return;\n      }\n    }\n  }\n  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n  recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveBezier };\n//# sourceMappingURL=buildAdaptiveBezier.mjs.map\n","import { GraphicsContextSystem } from '../GraphicsContextSystem.mjs';\n\n\"use strict\";\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 11920929e-14;\nconst PATH_DISTANCE_EPSILON = 1;\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nfunction buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {\n  const scale = 1;\n  const smoothing = Math.min(\n    0.99,\n    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n  );\n  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n  distanceTolerance *= distanceTolerance;\n  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n  return points;\n}\nfunction begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {\n  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n  points.push(eX, eY);\n}\nfunction recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {\n  if (level > RECURSION_LIMIT) {\n    return;\n  }\n  const pi = Math.PI;\n  const x12 = (x1 + x2) / 2;\n  const y12 = (y1 + y2) / 2;\n  const x23 = (x2 + x3) / 2;\n  const y23 = (y2 + y3) / 2;\n  const x123 = (x12 + x23) / 2;\n  const y123 = (y12 + y23) / 2;\n  let dx = x3 - x1;\n  let dy = y3 - y1;\n  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);\n  if (d > FLT_EPSILON) {\n    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {\n      if (mAngleTolerance < curveAngleToleranceEpsilon) {\n        points.push(x123, y123);\n        return;\n      }\n      let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n      if (da >= pi)\n        da = 2 * pi - da;\n      if (da < mAngleTolerance) {\n        points.push(x123, y123);\n        return;\n      }\n    }\n  } else {\n    dx = x123 - (x1 + x3) / 2;\n    dy = y123 - (y1 + y3) / 2;\n    if (dx * dx + dy * dy <= distanceTolerance) {\n      points.push(x123, y123);\n      return;\n    }\n  }\n  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\nexport { buildAdaptiveQuadratic };\n//# sourceMappingURL=buildAdaptiveQuadratic.mjs.map\n","\"use strict\";\nfunction buildArc(points, x, y, radius, start, end, clockwise, steps) {\n  let dist = Math.abs(start - end);\n  if (!clockwise && start > end) {\n    dist = 2 * Math.PI - dist;\n  } else if (clockwise && end > start) {\n    dist = 2 * Math.PI - dist;\n  }\n  steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));\n  steps = Math.max(steps, 3);\n  let f = dist / steps;\n  let t = start;\n  f *= clockwise ? -1 : 1;\n  for (let i = 0; i < steps + 1; i++) {\n    const cs = Math.cos(t);\n    const sn = Math.sin(t);\n    const nx = x + cs * radius;\n    const ny = y + sn * radius;\n    points.push(nx, ny);\n    t += f;\n  }\n}\n\nexport { buildArc };\n//# sourceMappingURL=buildArc.mjs.map\n","import { buildAdaptiveBezier } from './buildAdaptiveBezier.mjs';\n\n\"use strict\";\nconst TAU = Math.PI * 2;\nconst out = {\n  centerX: 0,\n  centerY: 0,\n  ang1: 0,\n  ang2: 0\n};\nconst mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {\n  x *= rx;\n  y *= ry;\n  const xp = cosPhi * x - sinPhi * y;\n  const yp = sinPhi * x + cosPhi * y;\n  out2.x = xp + centerX;\n  out2.y = yp + centerY;\n  return out2;\n};\nfunction approxUnitArc(ang1, ang2) {\n  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n  const x1 = Math.cos(ang1);\n  const y1 = Math.sin(ang1);\n  const x2 = Math.cos(ang1 + ang2);\n  const y2 = Math.sin(ang1 + ang2);\n  return [\n    {\n      x: x1 - y1 * a,\n      y: y1 + x1 * a\n    },\n    {\n      x: x2 + y2 * a,\n      y: y2 - x2 * a\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ];\n}\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  let dot = ux * vx + uy * vy;\n  if (dot > 1) {\n    dot = 1;\n  }\n  if (dot < -1) {\n    dot = -1;\n  }\n  return sign * Math.acos(dot);\n};\nconst getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {\n  const rxSq = Math.pow(rx, 2);\n  const rySq = Math.pow(ry, 2);\n  const pxpSq = Math.pow(pxp, 2);\n  const pypSq = Math.pow(pyp, 2);\n  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;\n  if (radicant < 0) {\n    radicant = 0;\n  }\n  radicant /= rxSq * pypSq + rySq * pxpSq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  const centerXp = radicant * rx / ry * pyp;\n  const centerYp = radicant * -ry / rx * pxp;\n  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;\n  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;\n  const vx1 = (pxp - centerXp) / rx;\n  const vy1 = (pyp - centerYp) / ry;\n  const vx2 = (-pxp - centerXp) / rx;\n  const vy2 = (-pyp - centerYp) / ry;\n  const ang1 = vectorAngle(1, 0, vx1, vy1);\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n  out2.centerX = centerX;\n  out2.centerY = centerY;\n  out2.ang1 = ang1;\n  out2.ang2 = ang2;\n};\nfunction buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {\n  if (rx === 0 || ry === 0) {\n    return;\n  }\n  const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n  const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;\n  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;\n  if (pxp === 0 && pyp === 0) {\n    return;\n  }\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n  getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinPhi,\n    cosPhi,\n    pxp,\n    pyp,\n    out\n  );\n  let { ang1, ang2 } = out;\n  const { centerX, centerY } = out;\n  let ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1 - ratio) < 1e-7) {\n    ratio = 1;\n  }\n  const segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n  let lastX = points[points.length - 2];\n  let lastY = points[points.length - 1];\n  const outCurvePoint = { x: 0, y: 0 };\n  for (let i = 0; i < segments; i++) {\n    const curve = approxUnitArc(ang1, ang2);\n    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n    buildAdaptiveBezier(\n      points,\n      lastX,\n      lastY,\n      x1,\n      y1,\n      x2,\n      y2,\n      x,\n      y\n    );\n    lastX = x;\n    lastY = y;\n    ang1 += ang2;\n  }\n}\n\nexport { buildArcToSvg };\n//# sourceMappingURL=buildArcToSvg.mjs.map\n","import { Circle } from '../../../../maths/shapes/Circle.mjs';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse.mjs';\nimport { Polygon } from '../../../../maths/shapes/Polygon.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle.mjs';\nimport { Bounds } from '../../../container/bounds/Bounds.mjs';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier.mjs';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic.mjs';\nimport { buildArc } from '../buildCommands/buildArc.mjs';\nimport { buildArcTo } from '../buildCommands/buildArcTo.mjs';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg.mjs';\nimport { roundedShapeQuadraticCurve, roundedShapeArc } from './roundShape.mjs';\n\n\"use strict\";\nconst tempRectangle = new Rectangle();\nclass ShapePath {\n  constructor(graphicsPath2D) {\n    /** The list of shape primitives that make up the path. */\n    this.shapePrimitives = [];\n    this._currentPoly = null;\n    this._bounds = new Bounds();\n    this._graphicsPath2D = graphicsPath2D;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this.startPoly(x, y);\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n    return this;\n  }\n  /**\n   * Adds an arc to the path. The arc is centered at (x, y)\n   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The radius of the arc.\n   * @param startAngle - The starting angle of the arc, in radians.\n   * @param endAngle - The ending angle of the arc, in radians.\n   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._ensurePoly(false);\n    const points = this._currentPoly.points;\n    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n    return this;\n  }\n  /**\n   * Adds an arc to the path with the arc tangent to the line joining two specified points.\n   * The arc radius is specified by `radius`.\n   * @param x1 - The x-coordinate of the first point.\n   * @param y1 - The y-coordinate of the first point.\n   * @param x2 - The x-coordinate of the second point.\n   * @param y2 - The y-coordinate of the second point.\n   * @param radius - The radius of the arc.\n   * @returns The instance of the current object for chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._ensurePoly();\n    const points = this._currentPoly.points;\n    buildArcTo(points, x1, y1, x2, y2, radius);\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    const points = this._currentPoly.points;\n    buildArcToSvg(\n      points,\n      this._currentPoly.lastX,\n      this._currentPoly.lastY,\n      x,\n      y,\n      rx,\n      ry,\n      xAxisRotation,\n      largeArcFlag,\n      sweepFlag\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveBezier(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      cp2x,\n      cp2y,\n      x,\n      y,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the control point.\n   * @param cp1y - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {\n    this._ensurePoly();\n    const currentPoly = this._currentPoly;\n    buildAdaptiveQuadratic(\n      this._currentPoly.points,\n      currentPoly.lastX,\n      currentPoly.lastY,\n      cp1x,\n      cp1y,\n      x,\n      y,\n      smoothing\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.endPoly(true);\n    return this;\n  }\n  /**\n   * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n   * @param path - The `GraphicsPath` object representing the path to add.\n   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    this.endPoly();\n    if (transform && !transform.isIdentity()) {\n      path = path.clone(true);\n      path.transform(transform);\n    }\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    return this;\n  }\n  /**\n   * Finalizes the drawing of the current path. Optionally, it can close the path.\n   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n   */\n  finish(closePath = false) {\n    this.endPoly(closePath);\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.drawShape(new Rectangle(x, y, w, h), transform);\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.drawShape(new Circle(x, y, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  poly(points, close, transform) {\n    const polygon = new Polygon(points);\n    polygon.closePath = close;\n    this.drawShape(polygon, transform);\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    sides = Math.max(sides | 0, 3);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const polygon = [];\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + radius * Math.cos(angle),\n        y + radius * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {\n    sides = Math.max(sides | 0, 3);\n    if (corner <= 0) {\n      return this.regularPoly(x, y, radius, sides, rotation);\n    }\n    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;\n    corner = Math.min(corner, sideLength);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const delta = Math.PI * 2 / sides;\n    const internalAngle = (sides - 2) * Math.PI / sides / 2;\n    for (let i = 0; i < sides; i++) {\n      const angle = i * delta + startAngle;\n      const x0 = x + radius * Math.cos(angle);\n      const y0 = y + radius * Math.sin(angle);\n      const a1 = angle + Math.PI + internalAngle;\n      const a2 = angle - Math.PI - internalAngle;\n      const x1 = x0 + corner * Math.cos(a1);\n      const y1 = y0 + corner * Math.sin(a1);\n      const x3 = x0 + corner * Math.cos(a2);\n      const y3 = y0 + corner * Math.sin(a2);\n      if (i === 0) {\n        this.moveTo(x1, y1);\n      } else {\n        this.lineTo(x1, y1);\n      }\n      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic = false, smoothness) {\n    if (points.length < 3) {\n      return this;\n    }\n    if (useQuadratic) {\n      roundedShapeQuadraticCurve(this, points, radius, smoothness);\n    } else {\n      roundedShapeArc(this, points, radius);\n    }\n    return this.closePath();\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    if (fillet === 0) {\n      return this.rect(x, y, width, height);\n    }\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    if (chamfer <= 0) {\n      return this.rect(x, y, width, height);\n    }\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n      x + inset,\n      y,\n      right - inset,\n      y,\n      right,\n      y + inset,\n      right,\n      bottom - inset,\n      right - inset,\n      bottom,\n      x + inset,\n      bottom,\n      x,\n      bottom - inset,\n      x,\n      y + inset\n    ];\n    for (let i = points.length - 1; i >= 2; i -= 2) {\n      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {\n        points.splice(i - 1, 2);\n      }\n    }\n    return this.poly(points, true, transform);\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY, transform) {\n    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius, transform) {\n    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n    return this;\n  }\n  /**\n   * Draws a given shape on the canvas.\n   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n   * scaling, and translations.\n   * @returns The instance of the current object for chaining.\n   */\n  drawShape(shape, matrix) {\n    this.endPoly();\n    this.shapePrimitives.push({ shape, transform: matrix });\n    return this;\n  }\n  /**\n   * Starts a new polygon path from the specified starting point.\n   * This method initializes a new polygon or ends the current one if it exists.\n   * @param x - The x-coordinate of the starting point of the new polygon.\n   * @param y - The y-coordinate of the starting point of the new polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  startPoly(x, y) {\n    let currentPoly = this._currentPoly;\n    if (currentPoly) {\n      this.endPoly();\n    }\n    currentPoly = new Polygon();\n    currentPoly.points.push(x, y);\n    this._currentPoly = currentPoly;\n    return this;\n  }\n  /**\n   * Ends the current polygon path. If `closePath` is set to true,\n   * the path is closed by connecting the last point to the first one.\n   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n   *  back to the starting point. False by default.\n   * @returns The instance of the current object for chaining.\n   */\n  endPoly(closePath = false) {\n    const shape = this._currentPoly;\n    if (shape && shape.points.length > 2) {\n      shape.closePath = closePath;\n      this.shapePrimitives.push({ shape });\n    }\n    this._currentPoly = null;\n    return this;\n  }\n  _ensurePoly(start = true) {\n    if (this._currentPoly)\n      return;\n    this._currentPoly = new Polygon();\n    if (start) {\n      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n      if (lastShape) {\n        let lx = lastShape.shape.x;\n        let ly = lastShape.shape.y;\n        if (lastShape.transform && !lastShape.transform.isIdentity()) {\n          const t = lastShape.transform;\n          const tempX = lx;\n          lx = t.a * lx + t.c * ly + t.tx;\n          ly = t.b * tempX + t.d * ly + t.ty;\n        }\n        this._currentPoly.points.push(lx, ly);\n      } else {\n        this._currentPoly.points.push(0, 0);\n      }\n    }\n  }\n  /** Builds the path. */\n  buildPath() {\n    const path = this._graphicsPath2D;\n    this.shapePrimitives.length = 0;\n    this._currentPoly = null;\n    for (let i = 0; i < path.instructions.length; i++) {\n      const instruction = path.instructions[i];\n      this[instruction.action](...instruction.data);\n    }\n    this.finish();\n  }\n  /** Gets the bounds of the path. */\n  get bounds() {\n    const bounds = this._bounds;\n    bounds.clear();\n    const shapePrimitives = this.shapePrimitives;\n    for (let i = 0; i < shapePrimitives.length; i++) {\n      const shapePrimitive = shapePrimitives[i];\n      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n      if (shapePrimitive.transform) {\n        bounds.addRect(boundsRect, shapePrimitive.transform);\n      } else {\n        bounds.addRect(boundsRect);\n      }\n    }\n    return bounds;\n  }\n}\n\nexport { ShapePath };\n//# sourceMappingURL=ShapePath.mjs.map\n","import { buildArc } from './buildArc.mjs';\n\n\"use strict\";\nfunction buildArcTo(points, x1, y1, x2, y2, radius) {\n  const fromX = points[points.length - 2];\n  const fromY = points[points.length - 1];\n  const a1 = fromY - y1;\n  const b1 = fromX - x1;\n  const a2 = y2 - y1;\n  const b2 = x2 - x1;\n  const mm = Math.abs(a1 * b2 - b1 * a2);\n  if (mm < 1e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n    return;\n  }\n  const dd = a1 * a1 + b1 * b1;\n  const cc = a2 * a2 + b2 * b2;\n  const tt = a1 * a2 + b1 * b2;\n  const k1 = radius * Math.sqrt(dd) / mm;\n  const k2 = radius * Math.sqrt(cc) / mm;\n  const j1 = k1 * tt / dd;\n  const j2 = k2 * tt / cc;\n  const cx = k1 * b2 + k2 * b1;\n  const cy = k1 * a2 + k2 * a1;\n  const px = b1 * (k2 + j1);\n  const py = a1 * (k2 + j1);\n  const qx = b2 * (k1 + j2);\n  const qy = a2 * (k1 + j2);\n  const startAngle = Math.atan2(py - cy, px - cx);\n  const endAngle = Math.atan2(qy - cy, qx - cx);\n  buildArc(\n    points,\n    cx + x1,\n    cy + y1,\n    radius,\n    startAngle,\n    endAngle,\n    b1 * a2 > b2 * a1\n  );\n}\n\nexport { buildArcTo };\n//# sourceMappingURL=buildArcTo.mjs.map\n","\"use strict\";\nfunction roundedShapeArc(g, points, radius) {\n  const vecFrom = (p, pp) => {\n    const x = pp.x - p.x;\n    const y = pp.y - p.y;\n    const len = Math.sqrt(x * x + y * y);\n    const nx = x / len;\n    const ny = y / len;\n    return { len, nx, ny };\n  };\n  const sharpCorner = (i, p) => {\n    if (i === 0) {\n      g.moveTo(p.x, p.y);\n    } else {\n      g.lineTo(p.x, p.y);\n    }\n  };\n  let p1 = points[points.length - 1];\n  for (let i = 0; i < points.length; i++) {\n    const p2 = points[i % points.length];\n    const pRadius = p2.radius ?? radius;\n    if (pRadius <= 0) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    const p3 = points[(i + 1) % points.length];\n    const v1 = vecFrom(p2, p1);\n    const v2 = vecFrom(p2, p3);\n    if (v1.len < 1e-4 || v2.len < 1e-4) {\n      sharpCorner(i, p2);\n      p1 = p2;\n      continue;\n    }\n    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);\n    let radDirection = 1;\n    let drawDirection = false;\n    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {\n      if (angle < 0) {\n        angle = Math.PI + angle;\n      } else {\n        angle = Math.PI - angle;\n        radDirection = -1;\n        drawDirection = true;\n      }\n    } else if (angle > 0) {\n      radDirection = -1;\n      drawDirection = true;\n    }\n    const halfAngle = angle / 2;\n    let cRadius;\n    let lenOut = Math.abs(\n      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)\n    );\n    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {\n      lenOut = Math.min(v1.len / 2, v2.len / 2);\n      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    } else {\n      cRadius = pRadius;\n    }\n    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;\n    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;\n    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;\n    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;\n    if (i === 0) {\n      g.moveTo(\n        cX + Math.cos(startAngle) * cRadius,\n        cY + Math.sin(startAngle) * cRadius\n      );\n    }\n    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n    p1 = p2;\n  }\n}\nfunction roundedShapeQuadraticCurve(g, points, radius, smoothness) {\n  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n  const pointLerp = (p1, p2, t) => ({\n    x: p1.x + (p2.x - p1.x) * t,\n    y: p1.y + (p2.y - p1.y) * t\n  });\n  const numPoints = points.length;\n  for (let i = 0; i < numPoints; i++) {\n    const thisPoint = points[(i + 1) % numPoints];\n    const pRadius = thisPoint.radius ?? radius;\n    if (pRadius <= 0) {\n      if (i === 0) {\n        g.moveTo(thisPoint.x, thisPoint.y);\n      } else {\n        g.lineTo(thisPoint.x, thisPoint.y);\n      }\n      continue;\n    }\n    const lastPoint = points[i];\n    const nextPoint = points[(i + 2) % numPoints];\n    const lastEdgeLength = distance(lastPoint, thisPoint);\n    let start;\n    if (lastEdgeLength < 1e-4) {\n      start = thisPoint;\n    } else {\n      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n      start = pointLerp(\n        thisPoint,\n        lastPoint,\n        lastOffsetDistance / lastEdgeLength\n      );\n    }\n    const nextEdgeLength = distance(nextPoint, thisPoint);\n    let end;\n    if (nextEdgeLength < 1e-4) {\n      end = thisPoint;\n    } else {\n      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n      end = pointLerp(\n        thisPoint,\n        nextPoint,\n        nextOffsetDistance / nextEdgeLength\n      );\n    }\n    if (i === 0) {\n      g.moveTo(start.x, start.y);\n    } else {\n      g.lineTo(start.x, start.y);\n    }\n    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n  }\n}\n\nexport { roundedShapeArc, roundedShapeQuadraticCurve };\n//# sourceMappingURL=roundShape.mjs.map\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { SVGToGraphicsPath } from '../svg/SVGToGraphicsPath.mjs';\nimport { ShapePath } from './ShapePath.mjs';\n\n\"use strict\";\nclass GraphicsPath {\n  /**\n   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n   * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n   */\n  constructor(instructions) {\n    this.instructions = [];\n    /** unique id for this graphics path */\n    this.uid = uid(\"graphicsPath\");\n    this._dirty = true;\n    if (typeof instructions === \"string\") {\n      SVGToGraphicsPath(instructions, this);\n    } else {\n      this.instructions = instructions?.slice() ?? [];\n    }\n  }\n  /**\n   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n   * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n   */\n  get shapePath() {\n    if (!this._shapePath) {\n      this._shapePath = new ShapePath(this);\n    }\n    if (this._dirty) {\n      this._dirty = false;\n      this._shapePath.buildPath();\n    }\n    return this._shapePath;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @param transform - An optional transformation to apply to the added path.\n   * @returns The instance of the current object for chaining.\n   */\n  addPath(path, transform) {\n    path = path.clone();\n    this.instructions.push({ action: \"addPath\", data: [path, transform] });\n    this._dirty = true;\n    return this;\n  }\n  arc(...args) {\n    this.instructions.push({ action: \"arc\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcTo(...args) {\n    this.instructions.push({ action: \"arcTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  arcToSvg(...args) {\n    this.instructions.push({ action: \"arcToSvg\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  bezierCurveTo(...args) {\n    this.instructions.push({ action: \"bezierCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires two points: the second control point and the end point. The first control point is assumed to be\n   * The starting point is the last point in the current path.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cp1x = 0;\n    let cp1y = 0;\n    if (!last || last.action !== \"bezierCurveTo\") {\n      cp1x = lastPoint.x;\n      cp1y = lastPoint.y;\n    } else {\n      cp1x = last.data[2];\n      cp1y = last.data[3];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cp1x = currentX + (currentX - cp1x);\n      cp1y = currentY + (currentY - cp1y);\n    }\n    this.instructions.push({ action: \"bezierCurveTo\", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this.instructions.push({ action: \"closePath\", data: [] });\n    this._dirty = true;\n    return this;\n  }\n  ellipse(...args) {\n    this.instructions.push({ action: \"ellipse\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  lineTo(...args) {\n    this.instructions.push({ action: \"lineTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  moveTo(...args) {\n    this.instructions.push({ action: \"moveTo\", data: args });\n    return this;\n  }\n  quadraticCurveTo(...args) {\n    this.instructions.push({ action: \"quadraticCurveTo\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It uses the previous point as the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveToShort(x, y, smoothness) {\n    const last = this.instructions[this.instructions.length - 1];\n    const lastPoint = this.getLastPoint(Point.shared);\n    let cpx1 = 0;\n    let cpy1 = 0;\n    if (!last || last.action !== \"quadraticCurveTo\") {\n      cpx1 = lastPoint.x;\n      cpy1 = lastPoint.y;\n    } else {\n      cpx1 = last.data[0];\n      cpy1 = last.data[1];\n      const currentX = lastPoint.x;\n      const currentY = lastPoint.y;\n      cpx1 = currentX + (currentX - cpx1);\n      cpy1 = currentY + (currentY - cpy1);\n    }\n    this.instructions.push({ action: \"quadraticCurveTo\", data: [cpx1, cpy1, x, y, smoothness] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h, transform) {\n    this.instructions.push({ action: \"rect\", data: [x, y, w, h, transform] });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius, transform) {\n    this.instructions.push({ action: \"circle\", data: [x, y, radius, transform] });\n    this._dirty = true;\n    return this;\n  }\n  roundRect(...args) {\n    this.instructions.push({ action: \"roundRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  poly(...args) {\n    this.instructions.push({ action: \"poly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  regularPoly(...args) {\n    this.instructions.push({ action: \"regularPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundPoly(...args) {\n    this.instructions.push({ action: \"roundPoly\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  roundShape(...args) {\n    this.instructions.push({ action: \"roundShape\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  filletRect(...args) {\n    this.instructions.push({ action: \"filletRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  chamferRect(...args) {\n    this.instructions.push({ action: \"chamferRect\", data: args });\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @param transform - An optional `Matrix` object to apply a transformation to the star.\n   * This can include rotations, scaling, and translations.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  // eslint-disable-next-line max-len\n  star(x, y, points, radius, innerRadius, rotation, transform) {\n    innerRadius || (innerRadius = radius / 2);\n    const startAngle = -1 * Math.PI / 2 + rotation;\n    const len = points * 2;\n    const delta = Math.PI * 2 / len;\n    const polygon = [];\n    for (let i = 0; i < len; i++) {\n      const r = i % 2 ? innerRadius : radius;\n      const angle = i * delta + startAngle;\n      polygon.push(\n        x + r * Math.cos(angle),\n        y + r * Math.sin(angle)\n      );\n    }\n    this.poly(polygon, true, transform);\n    return this;\n  }\n  /**\n   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n   * do not affect the original `GraphicsPath` and vice versa.\n   * @param deep - A boolean flag indicating whether the clone should be deep.\n   * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n   */\n  clone(deep = false) {\n    const newGraphicsPath2D = new GraphicsPath();\n    if (!deep) {\n      newGraphicsPath2D.instructions = this.instructions.slice();\n    } else {\n      for (let i = 0; i < this.instructions.length; i++) {\n        const instruction = this.instructions[i];\n        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n      }\n    }\n    return newGraphicsPath2D;\n  }\n  clear() {\n    this.instructions.length = 0;\n    this._dirty = true;\n    return this;\n  }\n  /**\n   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n   * This method enables the modification of the path's geometry according to the provided\n   * transformation matrix, which can include translations, rotations, scaling, and skewing.\n   *\n   * Each drawing instruction in the path is updated to reflect the transformation,\n   * ensuring the visual representation of the path is consistent with the applied matrix.\n   *\n   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n   * allowing for fine-grained control over the path's appearance.\n   * @param matrix - A `Matrix` object representing the transformation to apply.\n   * @returns The instance of the current object for chaining further operations.\n   */\n  transform(matrix) {\n    if (matrix.isIdentity())\n      return this;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    let x = 0;\n    let y = 0;\n    let cpx1 = 0;\n    let cpy1 = 0;\n    let cpx2 = 0;\n    let cpy2 = 0;\n    let rx = 0;\n    let ry = 0;\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const data = instruction.data;\n      switch (instruction.action) {\n        case \"moveTo\":\n        case \"lineTo\":\n          x = data[0];\n          y = data[1];\n          data[0] = a * x + c * y + tx;\n          data[1] = b * x + d * y + ty;\n          break;\n        case \"bezierCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          cpx2 = data[2];\n          cpy2 = data[3];\n          x = data[4];\n          y = data[5];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * cpx2 + c * cpy2 + tx;\n          data[3] = b * cpx2 + d * cpy2 + ty;\n          data[4] = a * x + c * y + tx;\n          data[5] = b * x + d * y + ty;\n          break;\n        case \"quadraticCurveTo\":\n          cpx1 = data[0];\n          cpy1 = data[1];\n          x = data[2];\n          y = data[3];\n          data[0] = a * cpx1 + c * cpy1 + tx;\n          data[1] = b * cpx1 + d * cpy1 + ty;\n          data[2] = a * x + c * y + tx;\n          data[3] = b * x + d * y + ty;\n          break;\n        case \"arcToSvg\":\n          x = data[5];\n          y = data[6];\n          rx = data[0];\n          ry = data[1];\n          data[0] = a * rx + c * ry;\n          data[1] = b * rx + d * ry;\n          data[5] = a * x + c * y + tx;\n          data[6] = b * x + d * y + ty;\n          break;\n        case \"circle\":\n          data[4] = adjustTransform(data[3], matrix);\n          break;\n        case \"rect\":\n          data[4] = adjustTransform(data[4], matrix);\n          break;\n        case \"ellipse\":\n          data[8] = adjustTransform(data[8], matrix);\n          break;\n        case \"roundRect\":\n          data[5] = adjustTransform(data[5], matrix);\n          break;\n        case \"addPath\":\n          data[0].transform(matrix);\n          break;\n        case \"poly\":\n          data[2] = adjustTransform(data[2], matrix);\n          break;\n        default:\n          warn(\"unknown transform action\", instruction.action);\n          break;\n      }\n    }\n    this._dirty = true;\n    return this;\n  }\n  get bounds() {\n    return this.shapePath.bounds;\n  }\n  /**\n   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n   * This method is useful for operations that depend on the path's current endpoint,\n   * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n   * ensuring the last point's position is accurately determined regardless of the path's complexity.\n   *\n   * If the last instruction is a `closePath`, the method iterates backward through the instructions\n   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n   * the last point from the nested path.\n   * @param out - A `Point` object where the last point's coordinates will be stored.\n   * This object is modified directly to contain the result.\n   * @returns The `Point` object containing the last point's coordinates.\n   */\n  getLastPoint(out) {\n    let index = this.instructions.length - 1;\n    let lastInstruction = this.instructions[index];\n    if (!lastInstruction) {\n      out.x = 0;\n      out.y = 0;\n      return out;\n    }\n    while (lastInstruction.action === \"closePath\") {\n      index--;\n      if (index < 0) {\n        out.x = 0;\n        out.y = 0;\n        return out;\n      }\n      lastInstruction = this.instructions[index];\n    }\n    switch (lastInstruction.action) {\n      case \"moveTo\":\n      case \"lineTo\":\n        out.x = lastInstruction.data[0];\n        out.y = lastInstruction.data[1];\n        break;\n      case \"quadraticCurveTo\":\n        out.x = lastInstruction.data[2];\n        out.y = lastInstruction.data[3];\n        break;\n      case \"bezierCurveTo\":\n        out.x = lastInstruction.data[4];\n        out.y = lastInstruction.data[5];\n        break;\n      case \"arc\":\n      case \"arcToSvg\":\n        out.x = lastInstruction.data[5];\n        out.y = lastInstruction.data[6];\n        break;\n      case \"addPath\":\n        lastInstruction.data[0].getLastPoint(out);\n        break;\n    }\n    return out;\n  }\n}\nfunction adjustTransform(currentMatrix, transform) {\n  if (currentMatrix) {\n    return currentMatrix.prepend(transform);\n  }\n  return transform.clone();\n}\n\nexport { GraphicsPath };\n//# sourceMappingURL=GraphicsPath.mjs.map\n","import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction SVGToGraphicsPath(svgPath, path) {\n  const commands = parse(svgPath);\n  const subpaths = [];\n  let currentSubPath = null;\n  let lastX = 0;\n  let lastY = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    const type = command[0];\n    const data = command;\n    switch (type) {\n      case \"M\":\n        lastX = data[1];\n        lastY = data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"m\":\n        lastX += data[1];\n        lastY += data[2];\n        path.moveTo(lastX, lastY);\n        break;\n      case \"H\":\n        lastX = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"h\":\n        lastX += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"V\":\n        lastY = data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"v\":\n        lastY += data[1];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"L\":\n        lastX = data[1];\n        lastY = data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"l\":\n        lastX += data[1];\n        lastY += data[2];\n        path.lineTo(lastX, lastY);\n        break;\n      case \"C\":\n        lastX = data[5];\n        lastY = data[6];\n        path.bezierCurveTo(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          lastX,\n          lastY\n        );\n        break;\n      case \"c\":\n        path.bezierCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4],\n          lastX + data[5],\n          lastY + data[6]\n        );\n        lastX += data[5];\n        lastY += data[6];\n        break;\n      case \"S\":\n        lastX = data[3];\n        lastY = data[4];\n        path.bezierCurveToShort(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case \"s\":\n        path.bezierCurveToShort(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"Q\":\n        lastX = data[3];\n        lastY = data[4];\n        path.quadraticCurveTo(\n          data[1],\n          data[2],\n          lastX,\n          lastY\n        );\n        break;\n      case \"q\":\n        path.quadraticCurveTo(\n          lastX + data[1],\n          lastY + data[2],\n          lastX + data[3],\n          lastY + data[4]\n        );\n        lastX += data[3];\n        lastY += data[4];\n        break;\n      case \"T\":\n        lastX = data[1];\n        lastY = data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case \"t\":\n        lastX += data[1];\n        lastY += data[2];\n        path.quadraticCurveToShort(\n          lastX,\n          lastY\n        );\n        break;\n      case \"A\":\n        lastX = data[6];\n        lastY = data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case \"a\":\n        lastX += data[6];\n        lastY += data[7];\n        path.arcToSvg(\n          data[1],\n          data[2],\n          data[3],\n          data[4],\n          data[5],\n          lastX,\n          lastY\n        );\n        break;\n      case \"Z\":\n      case \"z\":\n        path.closePath();\n        if (subpaths.length > 0) {\n          currentSubPath = subpaths.pop();\n          if (currentSubPath) {\n            lastX = currentSubPath.startX;\n            lastY = currentSubPath.startY;\n          } else {\n            lastX = 0;\n            lastY = 0;\n          }\n        }\n        currentSubPath = null;\n        break;\n      default:\n        warn(`Unknown SVG path command: ${type}`);\n    }\n    if (type !== \"Z\" && type !== \"z\") {\n      if (currentSubPath === null) {\n        currentSubPath = { startX: lastX, startY: lastY };\n        subpaths.push(currentSubPath);\n      }\n    }\n  }\n  return path;\n}\n\nexport { SVGToGraphicsPath };\n//# sourceMappingURL=SVGToGraphicsPath.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { GraphicsPath } from '../path/GraphicsPath.mjs';\n\n\"use strict\";\nfunction SVGParser(svg, graphicsContext) {\n  if (typeof svg === \"string\") {\n    const div = document.createElement(\"div\");\n    div.innerHTML = svg.trim();\n    svg = div.querySelector(\"svg\");\n  }\n  const session = {\n    context: graphicsContext,\n    path: new GraphicsPath()\n  };\n  renderChildren(svg, session, null, null);\n  return graphicsContext;\n}\nfunction renderChildren(svg, session, fillStyle, strokeStyle) {\n  const children = svg.children;\n  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);\n  if (f1 && fillStyle) {\n    fillStyle = { ...fillStyle, ...f1 };\n  } else if (f1) {\n    fillStyle = f1;\n  }\n  if (s1 && strokeStyle) {\n    strokeStyle = { ...strokeStyle, ...s1 };\n  } else if (s1) {\n    strokeStyle = s1;\n  }\n  session.context.fillStyle = fillStyle;\n  session.context.strokeStyle = strokeStyle;\n  let x;\n  let y;\n  let x1;\n  let y1;\n  let x2;\n  let y2;\n  let cx;\n  let cy;\n  let r;\n  let rx;\n  let ry;\n  let points;\n  let pointsString;\n  let d;\n  let graphicsPath;\n  let width;\n  let height;\n  switch (svg.nodeName.toLowerCase()) {\n    case \"path\":\n      d = svg.getAttribute(\"d\");\n      graphicsPath = new GraphicsPath(d);\n      session.context.path(graphicsPath);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"circle\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      r = parseFloatAttribute(svg, \"r\", 0);\n      session.context.ellipse(cx, cy, r, r);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"rect\":\n      x = parseFloatAttribute(svg, \"x\", 0);\n      y = parseFloatAttribute(svg, \"y\", 0);\n      width = parseFloatAttribute(svg, \"width\", 0);\n      height = parseFloatAttribute(svg, \"height\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      if (rx || ry) {\n        session.context.roundRect(x, y, width, height, rx || ry);\n      } else {\n        session.context.rect(x, y, width, height);\n      }\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"ellipse\":\n      cx = parseFloatAttribute(svg, \"cx\", 0);\n      cy = parseFloatAttribute(svg, \"cy\", 0);\n      rx = parseFloatAttribute(svg, \"rx\", 0);\n      ry = parseFloatAttribute(svg, \"ry\", 0);\n      session.context.beginPath();\n      session.context.ellipse(cx, cy, rx, ry);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"line\":\n      x1 = parseFloatAttribute(svg, \"x1\", 0);\n      y1 = parseFloatAttribute(svg, \"y1\", 0);\n      x2 = parseFloatAttribute(svg, \"x2\", 0);\n      y2 = parseFloatAttribute(svg, \"y2\", 0);\n      session.context.beginPath();\n      session.context.moveTo(x1, y1);\n      session.context.lineTo(x2, y2);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"polygon\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, true);\n      if (fillStyle)\n        session.context.fill();\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"polyline\":\n      pointsString = svg.getAttribute(\"points\");\n      points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n      session.context.poly(points, false);\n      if (strokeStyle)\n        session.context.stroke();\n      break;\n    case \"g\":\n    case \"svg\":\n      break;\n    default: {\n      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n      break;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    renderChildren(children[i], session, fillStyle, strokeStyle);\n  }\n}\nfunction parseFloatAttribute(svg, id, defaultValue) {\n  const value = svg.getAttribute(id);\n  return value ? Number(value) : defaultValue;\n}\nfunction parseStyle(svg) {\n  const style = svg.getAttribute(\"style\");\n  const strokeStyle = {};\n  const fillStyle = {};\n  let useFill = false;\n  let useStroke = false;\n  if (style) {\n    const styleParts = style.split(\";\");\n    for (let i = 0; i < styleParts.length; i++) {\n      const stylePart = styleParts[i];\n      const [key, value] = stylePart.split(\":\");\n      switch (key) {\n        case \"stroke\":\n          if (value !== \"none\") {\n            strokeStyle.color = Color.shared.setValue(value).toNumber();\n            useStroke = true;\n          }\n          break;\n        case \"stroke-width\":\n          strokeStyle.width = Number(value);\n          break;\n        case \"fill\":\n          if (value !== \"none\") {\n            useFill = true;\n            fillStyle.color = Color.shared.setValue(value).toNumber();\n          }\n          break;\n        case \"fill-opacity\":\n          fillStyle.alpha = Number(value);\n          break;\n        case \"stroke-opacity\":\n          strokeStyle.alpha = Number(value);\n          break;\n        case \"opacity\":\n          fillStyle.alpha = Number(value);\n          strokeStyle.alpha = Number(value);\n          break;\n      }\n    }\n  } else {\n    const stroke = svg.getAttribute(\"stroke\");\n    if (stroke && stroke !== \"none\") {\n      useStroke = true;\n      strokeStyle.color = Color.shared.setValue(stroke).toNumber();\n      strokeStyle.width = parseFloatAttribute(svg, \"stroke-width\", 1);\n    }\n    const fill = svg.getAttribute(\"fill\");\n    if (fill && fill !== \"none\") {\n      useFill = true;\n      fillStyle.color = Color.shared.setValue(fill).toNumber();\n    }\n  }\n  return {\n    strokeStyle: useStroke ? strokeStyle : null,\n    fillStyle: useFill ? fillStyle : null\n  };\n}\n\nexport { SVGParser };\n//# sourceMappingURL=SVGParser.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../../color/Color.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../maths/point/Point.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../utils/data/uid.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\nimport { GraphicsPath } from './path/GraphicsPath.mjs';\nimport { SVGParser } from './svg/SVGParser.mjs';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle.mjs';\n\n\"use strict\";\nconst tmpPoint = new Point();\nconst tempMatrix = new Matrix();\nconst _GraphicsContext = class _GraphicsContext extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /** unique id for this graphics context */\n    this.uid = uid(\"graphicsContext\");\n    this.dirty = true;\n    this.batchMode = \"auto\";\n    this.instructions = [];\n    this._activePath = new GraphicsPath();\n    this._transform = new Matrix();\n    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };\n    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };\n    this._stateStack = [];\n    this._tick = 0;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n  }\n  /**\n   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n   * including the current drawing state, transformations, styles, and instructions.\n   * @returns A new GraphicsContext instance with the same properties and state as this one.\n   */\n  clone() {\n    const clone = new _GraphicsContext();\n    clone.batchMode = this.batchMode;\n    clone.instructions = this.instructions.slice();\n    clone._activePath = this._activePath.clone();\n    clone._transform = this._transform.clone();\n    clone._fillStyle = { ...this._fillStyle };\n    clone._strokeStyle = { ...this._strokeStyle };\n    clone._stateStack = this._stateStack.slice();\n    clone._bounds = this._bounds.clone();\n    clone._boundsDirty = true;\n    return clone;\n  }\n  /**\n   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n   */\n  get fillStyle() {\n    return this._fillStyle;\n  }\n  set fillStyle(value) {\n    this._fillStyle = toFillStyle(value, _GraphicsContext.defaultFillStyle);\n  }\n  /**\n   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   */\n  get strokeStyle() {\n    return this._strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._strokeStyle = toStrokeStyle(value, _GraphicsContext.defaultStrokeStyle);\n  }\n  /**\n   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n   * pattern, or a more complex style defined by a FillStyle object.\n   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n   *                or a FillStyle or ConvertedFillStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setFillStyle(style) {\n    this._fillStyle = toFillStyle(style, _GraphicsContext.defaultFillStyle);\n    return this;\n  }\n  /**\n   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n   *                or a StrokeStyle or ConvertedStrokeStyle object.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  setStrokeStyle(style) {\n    this._strokeStyle = toFillStyle(style, _GraphicsContext.defaultStrokeStyle);\n    return this;\n  }\n  texture(texture, tint, dx, dy, dw, dh) {\n    this.instructions.push({\n      action: \"texture\",\n      data: {\n        image: texture,\n        dx: dx || 0,\n        dy: dy || 0,\n        dw: dw || texture.frame.width,\n        dh: dh || texture.frame.height,\n        transform: this._transform.clone(),\n        alpha: this._fillStyle.alpha,\n        style: tint ? Color.shared.setValue(tint).toNumber() : 16777215\n      }\n    });\n    this.onUpdate();\n    return this;\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  beginPath() {\n    this._activePath = new GraphicsPath();\n    return this;\n  }\n  fill(style, alpha) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"stroke\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      if (alpha !== void 0 && typeof style === \"number\") {\n        deprecation(v8_0_0, \"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead\");\n        style = { color: style, alpha };\n      }\n      this._fillStyle = toFillStyle(style, _GraphicsContext.defaultFillStyle);\n    }\n    this.instructions.push({\n      action: \"fill\",\n      // TODO copy fill style!\n      data: { style: this.fillStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  _initNextPathLocation() {\n    const { x, y } = this._activePath.getLastPoint(Point.shared);\n    this._activePath.clear();\n    this._activePath.moveTo(x, y);\n  }\n  /**\n   * Strokes the current path with the current stroke style. This method can take an optional\n   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  stroke(style) {\n    let path;\n    const lastInstruction = this.instructions[this.instructions.length - 1];\n    if (this._tick === 0 && lastInstruction && lastInstruction.action === \"fill\") {\n      path = lastInstruction.data.path;\n    } else {\n      path = this._activePath.clone();\n    }\n    if (!path)\n      return this;\n    if (style != null) {\n      this._strokeStyle = toStrokeStyle(style, _GraphicsContext.defaultStrokeStyle);\n    }\n    this.instructions.push({\n      action: \"stroke\",\n      // TODO copy fill style!\n      data: { style: this.strokeStyle, path }\n    });\n    this.onUpdate();\n    this._initNextPathLocation();\n    this._tick = 0;\n    return this;\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n   * fail to cut correctly!\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  cut() {\n    for (let i = 0; i < 2; i++) {\n      const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n      const holePath = this._activePath.clone();\n      if (lastInstruction) {\n        if (lastInstruction.action === \"stroke\" || lastInstruction.action === \"fill\") {\n          if (lastInstruction.data.hole) {\n            lastInstruction.data.hole.addPath(holePath);\n          } else {\n            lastInstruction.data.hole = holePath;\n            break;\n          }\n        }\n      }\n    }\n    this._initNextPathLocation();\n    return this;\n  }\n  /**\n   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n   * starting and ending angles, and direction.\n   * @param x - The x-coordinate of the arc's center.\n   * @param y - The y-coordinate of the arc's center.\n   * @param radius - The arc's radius.\n   * @param startAngle - The starting angle, in radians.\n   * @param endAngle - The ending angle, in radians.\n   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arc(x, y, radius, startAngle, endAngle, counterclockwise) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arc(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      radius,\n      startAngle,\n      endAngle,\n      counterclockwise\n    );\n    return this;\n  }\n  /**\n   * Adds an arc to the current path with the given control points and radius, connected to the previous point\n   * by a straight line if necessary.\n   * @param x1 - The x-coordinate of the first control point.\n   * @param y1 - The y-coordinate of the first control point.\n   * @param x2 - The x-coordinate of the second control point.\n   * @param y2 - The y-coordinate of the second control point.\n   * @param radius - The arc's radius.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  arcTo(x1, y1, x2, y2, radius) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcTo(\n      t.a * x1 + t.c * y1 + t.tx,\n      t.b * x1 + t.d * y1 + t.ty,\n      t.a * x2 + t.c * y2 + t.tx,\n      t.b * x2 + t.d * y2 + t.ty,\n      radius\n    );\n    return this;\n  }\n  /**\n   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n   * @param rx - The x-radius of the ellipse.\n   * @param ry - The y-radius of the ellipse.\n   * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n   * to the x-axis of the coordinate system, in degrees.\n   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n   * @param x - The x-coordinate of the arc's end point.\n   * @param y - The y-coordinate of the arc's end point.\n   * @returns The instance of the current object for chaining.\n   */\n  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.arcToSvg(\n      rx,\n      ry,\n      xAxisRotation,\n      // should we rotate this with transform??\n      largeArcFlag,\n      sweepFlag,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Adds a cubic Bezier curve to the path.\n   * It requires three points: the first two are control points and the third one is the end point.\n   * The starting point is the last point in the current path.\n   * @param cp1x - The x-coordinate of the first control point.\n   * @param cp1y - The y-coordinate of the first control point.\n   * @param cp2x - The x-coordinate of the second control point.\n   * @param cp2y - The y-coordinate of the second control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.bezierCurveTo(\n      t.a * cp1x + t.c * cp1y + t.tx,\n      t.b * cp1x + t.d * cp1y + t.ty,\n      t.a * cp2x + t.c * cp2y + t.tx,\n      t.b * cp2x + t.d * cp2y + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start.\n   * If the shape is already closed or there are no points in the path, this method does nothing.\n   * @returns The instance of the current object for chaining.\n   */\n  closePath() {\n    this._tick++;\n    this._activePath?.closePath();\n    return this;\n  }\n  /**\n   * Draws an ellipse at the specified location and with the given x and y radii.\n   * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n   * @param x - The x-coordinate of the center of the ellipse.\n   * @param y - The y-coordinate of the center of the ellipse.\n   * @param radiusX - The horizontal radius of the ellipse.\n   * @param radiusY - The vertical radius of the ellipse.\n   * @returns The instance of the current object for chaining.\n   */\n  ellipse(x, y, radiusX, radiusY) {\n    this._tick++;\n    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a circle shape. This method adds a new circle path to the current drawing.\n   * @param x - The x-coordinate of the center of the circle.\n   * @param y - The y-coordinate of the center of the circle.\n   * @param radius - The radius of the circle.\n   * @returns The instance of the current object for chaining.\n   */\n  circle(x, y, radius) {\n    this._tick++;\n    this._activePath.circle(x, y, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n   * @param path - The `GraphicsPath` to add.\n   * @returns The instance of the current object for chaining.\n   */\n  path(path) {\n    this._tick++;\n    this._activePath.addPath(path, this._transform.clone());\n    return this;\n  }\n  /**\n   * Connects the current point to a new point with a straight line. This method updates the current path.\n   * @param x - The x-coordinate of the new point to connect to.\n   * @param y - The y-coordinate of the new point to connect to.\n   * @returns The instance of the current object for chaining.\n   */\n  lineTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.lineTo(\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty\n    );\n    return this;\n  }\n  /**\n   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n   * @param x - The x-coordinate for the starting point.\n   * @param y - The y-coordinate for the starting point.\n   * @returns The instance of the current object for chaining.\n   */\n  moveTo(x, y) {\n    this._tick++;\n    const t = this._transform;\n    const instructions = this._activePath.instructions;\n    const transformedX = t.a * x + t.c * y + t.tx;\n    const transformedY = t.b * x + t.d * y + t.ty;\n    if (instructions.length === 1 && instructions[0].action === \"moveTo\") {\n      instructions[0].data[0] = transformedX;\n      instructions[0].data[1] = transformedY;\n      return this;\n    }\n    this._activePath.moveTo(\n      transformedX,\n      transformedY\n    );\n    return this;\n  }\n  /**\n   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n   * The starting point is the last point in the current path.\n   * @param cpx - The x-coordinate of the control point.\n   * @param cpy - The y-coordinate of the control point.\n   * @param x - The x-coordinate of the end point.\n   * @param y - The y-coordinate of the end point.\n   * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n   * @returns The instance of the current object for chaining.\n   */\n  quadraticCurveTo(cpx, cpy, x, y, smoothness) {\n    this._tick++;\n    const t = this._transform;\n    this._activePath.quadraticCurveTo(\n      t.a * cpx + t.c * cpy + t.tx,\n      t.b * cpx + t.d * cpy + t.ty,\n      t.a * x + t.c * y + t.tx,\n      t.b * x + t.d * y + t.ty,\n      smoothness\n    );\n    return this;\n  }\n  /**\n   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @returns The instance of the current object for chaining.\n   */\n  rect(x, y, w, h) {\n    this._tick++;\n    this._activePath.rect(x, y, w, h, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a rectangle with rounded corners.\n   * The corner radius can be specified to determine how rounded the corners should be.\n   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n   * @param x - The x-coordinate of the top-left corner of the rectangle.\n   * @param y - The y-coordinate of the top-left corner of the rectangle.\n   * @param w - The width of the rectangle.\n   * @param h - The height of the rectangle.\n   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n   * @returns The instance of the current object for chaining.\n   */\n  roundRect(x, y, w, h, radius) {\n    this._tick++;\n    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n   * rotated, or translated as needed.\n   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n   * representing the x and y coordinates, of the polygon's vertices, in sequence.\n   * @param close - A boolean indicating whether to close the polygon path. True by default.\n   */\n  poly(points, close) {\n    this._tick++;\n    this._activePath.poly(points, close, this._transform.clone());\n    return this;\n  }\n  /**\n   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n   * @returns The instance of the current object for chaining.\n   */\n  regularPoly(x, y, radius, sides, rotation = 0, transform) {\n    this._tick++;\n    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n    return this;\n  }\n  /**\n   * Draws a polygon with rounded corners.\n   * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n   * @param x - The x-coordinate of the center of the polygon.\n   * @param y - The y-coordinate of the center of the polygon.\n   * @param radius - The radius of the circumscribed circle of the polygon.\n   * @param sides - The number of sides of the polygon. Must be 3 or more.\n   * @param corner - The radius of the rounding of the corners.\n   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n   * @returns The instance of the current object for chaining.\n   */\n  roundPoly(x, y, radius, sides, corner, rotation) {\n    this._tick++;\n    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n    return this;\n  }\n  /**\n   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n   * A minimum of 3 points is required.\n   * @param radius - The default radius for the corners.\n   * This radius is applied to all corners unless overridden in `points`.\n   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n   *  method instead of an arc method. Defaults to false.\n   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n   * Higher values make the curve smoother.\n   * @returns The instance of the current object for chaining.\n   */\n  roundShape(points, radius, useQuadratic, smoothness) {\n    this._tick++;\n    this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n    return this;\n  }\n  /**\n   * Draw Rectangle with fillet corners. This is much like rounded rectangle\n   * however it support negative numbers as well for the corner radius.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param fillet - accept negative or positive values\n   */\n  filletRect(x, y, width, height, fillet) {\n    this._tick++;\n    this._activePath.filletRect(x, y, width, height, fillet);\n    return this;\n  }\n  /**\n   * Draw Rectangle with chamfer corners. These are angled corners.\n   * @param x - Upper left corner of rect\n   * @param y - Upper right corner of rect\n   * @param width - Width of rect\n   * @param height - Height of rect\n   * @param chamfer - non-zero real number, size of corner cutout\n   * @param transform\n   */\n  chamferRect(x, y, width, height, chamfer, transform) {\n    this._tick++;\n    this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n    return this;\n  }\n  /**\n   * Draws a star shape centered at a specified location. This method allows for the creation\n   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n   * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n   * @param x - The x-coordinate of the center of the star.\n   * @param y - The y-coordinate of the center of the star.\n   * @param points - The number of points of the star.\n   * @param radius - The outer radius of the star (distance from the center to the outer points).\n   * @param innerRadius - Optional. The inner radius of the star\n   * (distance from the center to the inner points between the outer points).\n   * If not provided, defaults to half of the `radius`.\n   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n   * Defaults to 0, meaning one point is directly upward.\n   * @returns The instance of the current object for chaining further drawing commands.\n   */\n  star(x, y, points, radius, innerRadius = 0, rotation = 0) {\n    this._tick++;\n    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n    return this;\n  }\n  /**\n   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n   * defined in SVG format to be drawn within the graphics context.\n   * @param svg - The SVG string to be parsed and rendered.\n   */\n  svg(svg) {\n    this._tick++;\n    SVGParser(svg, this);\n    return this;\n  }\n  /**\n   * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n   * This includes transformations, fill styles, and stroke styles.\n   */\n  restore() {\n    const state = this._stateStack.pop();\n    if (state) {\n      this._transform = state.transform;\n      this._fillStyle = state.fillStyle;\n      this._strokeStyle = state.strokeStyle;\n    }\n    return this;\n  }\n  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n  save() {\n    this._stateStack.push({\n      transform: this._transform.clone(),\n      fillStyle: { ...this._fillStyle },\n      strokeStyle: { ...this._strokeStyle }\n    });\n    return this;\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * @returns The current transformation matrix.\n   */\n  getTransform() {\n    return this._transform;\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  resetTransform() {\n    this._transform.identity();\n    return this;\n  }\n  /**\n   * Applies a rotation transformation to the graphics context around the current origin.\n   * @param angle - The angle of rotation in radians.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  rotate(angle) {\n    this._transform.rotate(angle);\n    return this;\n  }\n  /**\n   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n   * @param x - The scale factor in the horizontal direction.\n   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  scale(x, y = x) {\n    this._transform.scale(x, y);\n    return this;\n  }\n  setTransform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n      return this;\n    }\n    this._transform.set(a, b, c, d, dx, dy);\n    return this;\n  }\n  transform(a, b, c, d, dx, dy) {\n    if (a instanceof Matrix) {\n      this._transform.append(a);\n      return this;\n    }\n    tempMatrix.set(a, b, c, d, dx, dy);\n    this._transform.append(tempMatrix);\n    return this;\n  }\n  /**\n   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n   * @param x - The amount to translate in the horizontal direction.\n   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  translate(x, y = x) {\n    this._transform.translate(x, y);\n    return this;\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n   * and optionally resetting transformations to the identity matrix.\n   * @returns The instance of the current GraphicsContext for method chaining.\n   */\n  clear() {\n    this._activePath.clear();\n    this.instructions.length = 0;\n    this.resetTransform();\n    this.onUpdate();\n    return this;\n  }\n  onUpdate() {\n    if (this.dirty)\n      return;\n    this.emit(\"update\", this, 16);\n    this.dirty = true;\n    this._boundsDirty = true;\n  }\n  /** The bounds of the graphic shape. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    const bounds = this._bounds;\n    bounds.clear();\n    for (let i = 0; i < this.instructions.length; i++) {\n      const instruction = this.instructions[i];\n      const action = instruction.action;\n      if (action === \"fill\") {\n        const data = instruction.data;\n        bounds.addBounds(data.path.bounds);\n      } else if (action === \"texture\") {\n        const data = instruction.data;\n        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n      }\n      if (action === \"stroke\") {\n        const data = instruction.data;\n        const alignment = data.style.alignment;\n        const padding = data.style.width * (1 - alignment);\n        const _bounds = data.path.bounds;\n        bounds.addFrame(\n          _bounds.minX - padding,\n          _bounds.minY - padding,\n          _bounds.maxX + padding,\n          _bounds.maxY + padding\n        );\n      }\n    }\n    return bounds;\n  }\n  /**\n   * Check to see if a point is contained within this geometry.\n   * @param point - Point to check if it's contained.\n   * @returns {boolean} `true` if the point is contained within geometry.\n   */\n  containsPoint(point) {\n    if (!this.bounds.containsPoint(point.x, point.y))\n      return false;\n    const instructions = this.instructions;\n    let hasHit = false;\n    for (let k = 0; k < instructions.length; k++) {\n      const instruction = instructions[k];\n      const data = instruction.data;\n      const path = data.path;\n      if (!instruction.action || !path)\n        continue;\n      const style = data.style;\n      const shapes = path.shapePath.shapePrimitives;\n      for (let i = 0; i < shapes.length; i++) {\n        const shape = shapes[i].shape;\n        if (!style || !shape)\n          continue;\n        const transform = shapes[i].transform;\n        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n        if (instruction.action === \"fill\") {\n          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n        } else {\n          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);\n        }\n        const holes = data.hole;\n        if (holes) {\n          const holeShapes = holes.shapePath?.shapePrimitives;\n          if (holeShapes) {\n            for (let j = 0; j < holeShapes.length; j++) {\n              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {\n                hasHit = false;\n              }\n            }\n          }\n        }\n        if (hasHit) {\n          return true;\n        }\n      }\n    }\n    return hasHit;\n  }\n  /**\n   * Destroys the GraphicsData object.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?\n   * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?\n   */\n  destroy(options = false) {\n    this._stateStack.length = 0;\n    this._transform = null;\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fillStyle.texture) {\n        this._fillStyle.texture.destroy(destroyTextureSource);\n      }\n      if (this._strokeStyle.texture) {\n        this._strokeStyle.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fillStyle = null;\n    this._strokeStyle = null;\n    this.instructions = null;\n    this._activePath = null;\n    this._bounds = null;\n    this._stateStack = null;\n    this.customShader = null;\n    this._transform = null;\n  }\n};\n/** The default fill style to use when none is provided. */\n_GraphicsContext.defaultFillStyle = {\n  /** The color to use for the fill. */\n  color: 16777215,\n  /** The alpha value to use for the fill. */\n  alpha: 1,\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null\n};\n/** The default stroke style to use when none is provided. */\n_GraphicsContext.defaultStrokeStyle = {\n  /** The width of the stroke. */\n  width: 1,\n  /** The color to use for the stroke. */\n  color: 16777215,\n  /** The alpha value to use for the stroke. */\n  alpha: 1,\n  /** The alignment of the stroke. */\n  alignment: 0.5,\n  /** The miter limit to use. */\n  miterLimit: 10,\n  /** The line cap style to use. */\n  cap: \"butt\",\n  /** The line join style to use. */\n  join: \"miter\",\n  /** The texture to use for the fill. */\n  texture: Texture.WHITE,\n  /** The matrix to apply. */\n  matrix: null,\n  /** The fill pattern to use. */\n  fill: null,\n  /** If the stroke is a pixel line. */\n  pixelLine: false\n};\nlet GraphicsContext = _GraphicsContext;\n\nexport { GraphicsContext };\n//# sourceMappingURL=GraphicsContext.mjs.map\n","\"use strict\";\nfunction transformVertices(vertices, m, offset, stride, size) {\n  const a = m.a;\n  const b = m.b;\n  const c = m.c;\n  const d = m.d;\n  const tx = m.tx;\n  const ty = m.ty;\n  offset || (offset = 0);\n  stride || (stride = 2);\n  size || (size = vertices.length / stride - offset);\n  let index = offset * stride;\n  for (let i = 0; i < size; i++) {\n    const x = vertices[index];\n    const y = vertices[index + 1];\n    vertices[index] = a * x + c * y + tx;\n    vertices[index + 1] = b * x + d * y + ty;\n    index += stride;\n  }\n}\n\nexport { transformVertices };\n//# sourceMappingURL=transformVertices.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildCircle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"circle\"\n  },\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === \"circle\") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === \"ellipse\") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\nconst buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: \"ellipse\" } };\nconst buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: \"roundedRectangle\" } };\n\nexport { buildCircle, buildEllipse, buildRoundedRectangle };\n//# sourceMappingURL=buildCircle.mjs.map\n","\"use strict\";\nconst closePointEps = 1e-4;\nconst curveEps = 1e-4;\n\nexport { closePointEps, curveEps };\n//# sourceMappingURL=const.mjs.map\n","import { Point } from '../../../../maths/point/Point.mjs';\nimport { closePointEps, curveEps } from '../const.mjs';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints.mjs';\n\n\"use strict\";\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {\n  const ix = x - nx * innerWeight;\n  const iy = y - ny * innerWeight;\n  const ox = x + nx * outerWeight;\n  const oy = y + ny * outerWeight;\n  let exx;\n  let eyy;\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  const eix = ix + exx;\n  const eiy = iy + eyy;\n  const eox = ox + exx;\n  const eoy = oy + eyy;\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  const cx2p0x = sx - cx;\n  const cy2p0y = sy - cy;\n  let angle0 = Math.atan2(cx2p0x, cy2p0y);\n  let angle1 = Math.atan2(ex - cx, ey - cy);\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n  let startAngle = angle0;\n  const angleDiff = angle1 - angle0;\n  const absAngleDiff = Math.abs(angleDiff);\n  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  const angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n    }\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(\n        cx + Math.sin(angle) * radius,\n        cy + Math.cos(angle) * radius\n      );\n      verts.push(cx, cy);\n    }\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n  return segCount * 2;\n}\nfunction buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const style = lineStyle;\n  let alignment = style.alignment;\n  if (lineStyle.alignment !== 0.5) {\n    let orientation = getOrientationOfPoints(points);\n    if (flipAlignment)\n      orientation *= -1;\n    alignment = (alignment - 0.5) * orientation + 0.5;\n  }\n  const firstPoint = new Point(points[0], points[1]);\n  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  const closedShape = closed;\n  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;\n  if (closedShape) {\n    points = points.slice();\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n  const verts = vertices;\n  const length = points.length / 2;\n  let indexCount = points.length;\n  const indexStart = verts.length / 2;\n  const width = style.width / 2;\n  const widthSquared = width * width;\n  const miterLimitSquared = style.miterLimit * style.miterLimit;\n  let x0 = points[0];\n  let y0 = points[1];\n  let x1 = points[2];\n  let y1 = points[3];\n  let x2 = 0;\n  let y2 = 0;\n  let perpX = -(y0 - y1);\n  let perpY = x0 - x1;\n  let perp1x = 0;\n  let perp1y = 0;\n  let dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  const ratio = alignment;\n  const innerWeight = (1 - ratio) * 2;\n  const outerWeight = ratio * 2;\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x0 - perpX * (innerWeight - outerWeight) * 0.5,\n        y0 - perpY * (innerWeight - outerWeight) * 0.5,\n        x0 - perpX * innerWeight,\n        y0 - perpY * innerWeight,\n        x0 + perpX * outerWeight,\n        y0 + perpY * outerWeight,\n        verts,\n        true\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n    }\n  }\n  verts.push(\n    x0 - perpX * innerWeight,\n    y0 - perpY * innerWeight\n  );\n  verts.push(\n    x0 + perpX * outerWeight,\n    y0 + perpY * outerWeight\n  );\n  for (let i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n    dist = Math.sqrt(perpX * perpX + perpY * perpY);\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    const dx0 = x1 - x0;\n    const dy0 = y0 - y1;\n    const dx1 = x1 - x2;\n    const dy1 = y2 - y1;\n    const dot = dx0 * dx1 + dy0 * dy1;\n    const cross = dy0 * dx1 - dy1 * dx0;\n    const clockwise = cross < 0;\n    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {\n      verts.push(\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight\n      );\n      verts.push(\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight\n      );\n      if (dot >= 0) {\n        if (style.join === \"round\") {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n        } else {\n          indexCount += 2;\n        }\n        verts.push(\n          x1 - perp1x * outerWeight,\n          y1 - perp1y * outerWeight\n        );\n        verts.push(\n          x1 + perp1x * innerWeight,\n          y1 + perp1y * innerWeight\n        );\n      }\n      continue;\n    }\n    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);\n    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    const px = (dx0 * c2 - dx1 * c1) / cross;\n    const py = (dy1 * c1 - dy0 * c2) / cross;\n    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    const imx = x1 + (px - x1) * innerWeight;\n    const imy = y1 + (py - y1) * innerWeight;\n    const omx = x1 - (px - x1) * outerWeight;\n    const omy = y1 - (py - y1) * outerWeight;\n    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    const insideWeight = clockwise ? innerWeight : outerWeight;\n    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n    if (insideMiterOk) {\n      if (style.join === \"bevel\" || pDist / widthSquared > miterLimitSquared) {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n        indexCount += 2;\n      } else if (style.join === \"round\") {\n        if (clockwise) {\n          verts.push(imx, imy);\n          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 4;\n          verts.push(imx, imy);\n          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n        } else {\n          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n          verts.push(omx, omy);\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 4;\n          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n          verts.push(omx, omy);\n        }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else {\n      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n      if (style.join === \"round\") {\n        if (clockwise) {\n          indexCount += round(\n            x1,\n            y1,\n            x1 + perpX * outerWeight,\n            y1 + perpY * outerWeight,\n            x1 + perp1x * outerWeight,\n            y1 + perp1y * outerWeight,\n            verts,\n            true\n          ) + 2;\n        } else {\n          indexCount += round(\n            x1,\n            y1,\n            x1 - perpX * innerWeight,\n            y1 - perpY * innerWeight,\n            x1 - perp1x * innerWeight,\n            y1 - perp1y * innerWeight,\n            verts,\n            false\n          ) + 2;\n        }\n      } else if (style.join === \"miter\" && pDist / widthSquared <= miterLimitSquared) {\n        if (clockwise) {\n          verts.push(omx, omy);\n          verts.push(omx, omy);\n        } else {\n          verts.push(imx, imy);\n          verts.push(imx, imy);\n        }\n        indexCount += 2;\n      }\n      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n      indexCount += 2;\n    }\n  }\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpX = -(y0 - y1);\n  perpY = x0 - x1;\n  dist = Math.sqrt(perpX * perpX + perpY * perpY);\n  perpX /= dist;\n  perpY /= dist;\n  perpX *= width;\n  perpY *= width;\n  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);\n  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);\n  if (!closedShape) {\n    if (style.cap === \"round\") {\n      indexCount += round(\n        x1 - perpX * (innerWeight - outerWeight) * 0.5,\n        y1 - perpY * (innerWeight - outerWeight) * 0.5,\n        x1 - perpX * innerWeight,\n        y1 - perpY * innerWeight,\n        x1 + perpX * outerWeight,\n        y1 + perpY * outerWeight,\n        verts,\n        false\n      ) + 2;\n    } else if (style.cap === \"square\") {\n      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n    }\n  }\n  const eps2 = curveEps * curveEps;\n  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n    indices.push(i, i + 1, i + 2);\n  }\n}\n\nexport { buildLine };\n//# sourceMappingURL=buildLine.mjs.map\n","import earcut from 'earcut';\n\n\"use strict\";\nfunction triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n  const triangles = earcut(points, holes, 2);\n  if (!triangles) {\n    return;\n  }\n  for (let i = 0; i < triangles.length; i += 3) {\n    indices[indicesOffset++] = triangles[i] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;\n    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;\n  }\n  let index = verticesOffset * verticesStride;\n  for (let i = 0; i < points.length; i += 2) {\n    vertices[index] = points[i];\n    vertices[index + 1] = points[i + 1];\n    index += verticesStride;\n  }\n}\n\nexport { triangulateWithHoles };\n//# sourceMappingURL=triangulateWithHoles.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles.mjs';\n\n\"use strict\";\nconst emptyArray = [];\nconst buildPolygon = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"polygon\"\n  },\n  build(shape, points) {\n    for (let i = 0; i < shape.points.length; i++) {\n      points[i] = shape.points[i];\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n  }\n};\n\nexport { buildPolygon };\n//# sourceMappingURL=buildPolygon.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildRectangle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"rectangle\"\n  },\n  build(shape, points) {\n    const rectData = shape;\n    const x = rectData.x;\n    const y = rectData.y;\n    const width = rectData.width;\n    const height = rectData.height;\n    if (!(width >= 0 && height >= 0)) {\n      return points;\n    }\n    points[0] = x;\n    points[1] = y;\n    points[2] = x + width;\n    points[3] = y;\n    points[4] = x + width;\n    points[5] = y + height;\n    points[6] = x;\n    points[7] = y + height;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[6];\n    vertices[verticesOffset + count + 1] = points[7];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    count += verticesStride;\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 3;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildRectangle };\n//# sourceMappingURL=buildRectangle.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst buildTriangle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"triangle\"\n  },\n  build(shape, points) {\n    points[0] = shape.x;\n    points[1] = shape.y;\n    points[2] = shape.x2;\n    points[3] = shape.y2;\n    points[4] = shape.x3;\n    points[5] = shape.y3;\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    let count = 0;\n    verticesOffset *= verticesStride;\n    vertices[verticesOffset + count] = points[0];\n    vertices[verticesOffset + count + 1] = points[1];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[2];\n    vertices[verticesOffset + count + 1] = points[3];\n    count += verticesStride;\n    vertices[verticesOffset + count] = points[4];\n    vertices[verticesOffset + count + 1] = points[5];\n    const verticesIndex = verticesOffset / verticesStride;\n    indices[indicesOffset++] = verticesIndex;\n    indices[indicesOffset++] = verticesIndex + 1;\n    indices[indicesOffset++] = verticesIndex + 2;\n  }\n};\n\nexport { buildTriangle };\n//# sourceMappingURL=buildTriangle.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { buildUvs, buildSimpleUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { BigPool } from '../../../../utils/pool/PoolGroup.mjs';\nimport { BatchableGraphics } from '../BatchableGraphics.mjs';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle.mjs';\nimport { buildLine } from '../buildCommands/buildLine.mjs';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine.mjs';\nimport { buildPolygon } from '../buildCommands/buildPolygon.mjs';\nimport { buildRectangle } from '../buildCommands/buildRectangle.mjs';\nimport { buildTriangle } from '../buildCommands/buildTriangle.mjs';\nimport { triangulateWithHoles } from './triangulateWithHoles.mjs';\n\n\"use strict\";\nconst shapeBuilders = {};\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\nconst tempRect = new Rectangle();\nfunction buildContextBatches(context, gpuContext) {\n  const { geometryData, batches } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === \"texture\") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n      const isStroke = instruction.action === \"stroke\";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = shapeBuilders.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(\n    textureUvs.x0,\n    textureUvs.y0,\n    textureUvs.x1,\n    textureUvs.y1,\n    textureUvs.x3,\n    textureUvs.y3,\n    textureUvs.x2,\n    textureUvs.y2\n  );\n  const graphicsBatch = BigPool.get(BatchableGraphics);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.attributeOffset = vertOffset;\n  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.baseColor = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const { vertices, uvs, indices } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) => {\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = shapeBuilders[shape.type];\n    let topology = \"triangle-list\";\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach((holePoints) => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      if (!lineStyle.pixelLine) {\n        buildLine(points, lineStyle, false, close, vertices, indices);\n      } else {\n        buildPixelLine(points, close, vertices, indices);\n        topology = \"line-list\";\n      }\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture.WHITE) {\n      const textureMatrix = style.matrix;\n      if (textureMatrix) {\n        if (matrix) {\n          textureMatrix.append(matrix.clone().invert());\n        }\n        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n      }\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.baseColor = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    graphicsBatch.topology = topology;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape)\n    return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = shapeBuilders[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\n\nexport { buildContextBatches, shapeBuilders };\n//# sourceMappingURL=buildContextBatches.mjs.map\n","import { closePointEps } from '../const.mjs';\n\n\"use strict\";\nfunction buildPixelLine(points, closed, vertices, indices) {\n  const eps = closePointEps;\n  if (points.length === 0) {\n    return;\n  }\n  const fx = points[0];\n  const fy = points[1];\n  const lx = points[points.length - 2];\n  const ly = points[points.length - 1];\n  const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;\n  const verts = vertices;\n  const length = points.length / 2;\n  const indexStart = verts.length / 2;\n  for (let i = 0; i < length; i++) {\n    verts.push(points[i * 2]);\n    verts.push(points[i * 2 + 1]);\n  }\n  for (let i = 0; i < length - 1; i++) {\n    indices.push(indexStart + i, indexStart + i + 1);\n  }\n  if (closePath) {\n    indices.push(indexStart + length - 1, indexStart);\n  }\n}\n\nexport { buildPixelLine };\n//# sourceMappingURL=buildPixelLine.mjs.map\n","\"use strict\";\nfunction getOrientationOfPoints(points) {\n  const m = points.length;\n  if (m < 6) {\n    return 1;\n  }\n  let area = 0;\n  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    const x2 = points[i];\n    const y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  if (area < 0) {\n    return -1;\n  }\n  return 1;\n}\n\nexport { getOrientationOfPoints };\n//# sourceMappingURL=getOrientationOfPoints.mjs.map\n","\"use strict\";\nfunction buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {\n  let index = 0;\n  verticesOffset *= verticesStride;\n  uvsOffset *= uvsStride;\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  while (index < size) {\n    const x = vertices[verticesOffset];\n    const y = vertices[verticesOffset + 1];\n    uvs[uvsOffset] = a * x + c * y + tx;\n    uvs[uvsOffset + 1] = b * x + d * y + ty;\n    uvsOffset += uvsStride;\n    verticesOffset += verticesStride;\n    index++;\n  }\n}\nfunction buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {\n  let index = 0;\n  uvsOffset *= uvsStride;\n  while (index < size) {\n    uvs[uvsOffset] = 0;\n    uvs[uvsOffset + 1] = 0;\n    uvsOffset += uvsStride;\n    index++;\n  }\n}\n\nexport { buildSimpleUvs, buildUvs };\n//# sourceMappingURL=buildUvs.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher.mjs';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { buildContextBatches } from './utils/buildContextBatches.mjs';\n\n\"use strict\";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.batcher = new DefaultBatcher();\n    this.instructions = new InstructionSet();\n  }\n  init() {\n    this.instructions.reset();\n  }\n  /**\n   * @deprecated since version 8.0.0\n   * Use `batcher.geometry` instead.\n   * @see {Batcher#geometry}\n   */\n  get geometry() {\n    deprecation(v8_3_4, \"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.\");\n    return this.batcher.geometry;\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor(renderer) {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);\n    renderer.renderableGC.addManagedHash(this, \"_gpuContextHash\");\n    renderer.renderableGC.addManagedHash(this, \"_graphicsDataContextHash\");\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === \"no-batch\") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === \"auto\") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _initContextRenderData(context) {\n    const graphicsData = BigPool.get(GraphicsContextRenderData);\n    const { batches, geometryData } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = graphicsData.batcher;\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = batcher.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    gpuContext.context = context;\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        BigPool.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach((batch) => {\n        BigPool.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const i in this._gpuContextHash) {\n      if (this._gpuContextHash[i]) {\n        this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n      }\n    }\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\n\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem };\n//# sourceMappingURL=GraphicsContextSystem.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst _FillGradient = class _FillGradient {\n  constructor(x0, y0, x1, y1) {\n    /** unique id for this fill gradient */\n    this.uid = uid(\"fillGradient\");\n    this.type = \"linear\";\n    this.gradientStops = [];\n    this._styleKey = null;\n    this.x0 = x0;\n    this.y0 = y0;\n    this.x1 = x1;\n    this.y1 = y1;\n  }\n  addColorStop(offset, color) {\n    this.gradientStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n    this._styleKey = null;\n    return this;\n  }\n  // TODO move to the system!\n  buildLinearGradient() {\n    if (this.texture)\n      return;\n    const defaultSize = _FillGradient.defaultTextureSize;\n    const { gradientStops } = this;\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = defaultSize;\n    canvas.height = defaultSize;\n    const ctx = canvas.getContext(\"2d\");\n    const gradient = ctx.createLinearGradient(0, 0, _FillGradient.defaultTextureSize, 1);\n    for (let i = 0; i < gradientStops.length; i++) {\n      const stop = gradientStops[i];\n      gradient.addColorStop(stop.offset, stop.color);\n    }\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, defaultSize, defaultSize);\n    this.texture = new Texture({\n      source: new ImageSource({\n        resource: canvas,\n        addressModeU: \"clamp-to-edge\",\n        addressModeV: \"repeat\"\n      })\n    });\n    const { x0, y0, x1, y1 } = this;\n    const m = new Matrix();\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n    m.translate(-x0, -y0);\n    m.scale(1 / defaultSize, 1 / defaultSize);\n    m.rotate(-angle);\n    m.scale(256 / dist, 1);\n    this.transform = m;\n    this._styleKey = null;\n  }\n  get styleKey() {\n    if (this._styleKey) {\n      return this._styleKey;\n    }\n    const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join(\"-\");\n    const texture = this.texture.uid;\n    const transform = this.transform.toArray().join(\"-\");\n    return `fill-gradient-${this.uid}-${stops}-${texture}-${transform}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;\n  }\n};\n_FillGradient.defaultTextureSize = 256;\nlet FillGradient = _FillGradient;\n\nexport { FillGradient };\n//# sourceMappingURL=FillGradient.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nconst repetitionMap = {\n  repeat: {\n    addressModeU: \"repeat\",\n    addressModeV: \"repeat\"\n  },\n  \"repeat-x\": {\n    addressModeU: \"repeat\",\n    addressModeV: \"clamp-to-edge\"\n  },\n  \"repeat-y\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"repeat\"\n  },\n  \"no-repeat\": {\n    addressModeU: \"clamp-to-edge\",\n    addressModeV: \"clamp-to-edge\"\n  }\n};\nclass FillPattern {\n  constructor(texture, repetition) {\n    /** unique id for this fill pattern */\n    this.uid = uid(\"fillPattern\");\n    this.transform = new Matrix();\n    this._styleKey = null;\n    this.texture = texture;\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    if (repetition) {\n      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;\n      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;\n    }\n  }\n  setTransform(transform) {\n    const texture = this.texture;\n    this.transform.copyFrom(transform);\n    this.transform.invert();\n    this.transform.scale(\n      1 / texture.frame.width,\n      1 / texture.frame.height\n    );\n    this._styleKey = null;\n  }\n  get styleKey() {\n    if (this._styleKey)\n      return this._styleKey;\n    this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join(\"-\")}`;\n    return this._styleKey;\n  }\n}\n\nexport { FillPattern };\n//# sourceMappingURL=FillPattern.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { FillGradient } from '../fill/FillGradient.mjs';\nimport { FillPattern } from '../fill/FillPattern.mjs';\n\n\"use strict\";\nfunction isColorLike(value) {\n  return Color.isColorLike(value);\n}\nfunction isFillPattern(value) {\n  return value instanceof FillPattern;\n}\nfunction isFillGradient(value) {\n  return value instanceof FillGradient;\n}\nfunction handleColorLike(fill, value, defaultStyle) {\n  const temp = Color.shared.setValue(value ?? 0);\n  fill.color = temp.toNumber();\n  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n  fill.texture = Texture.WHITE;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillPattern(fill, value, defaultStyle) {\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillGradient(fill, value, defaultStyle) {\n  value.buildLinearGradient();\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return { ...defaultStyle, ...fill };\n}\nfunction handleFillObject(value, defaultStyle) {\n  const style = { ...defaultStyle, ...value };\n  if (style.texture) {\n    if (style.texture !== Texture.WHITE) {\n      const m = style.matrix?.clone().invert() || new Matrix();\n      m.translate(style.texture.frame.x, style.texture.frame.y);\n      m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === \"clamp-to-edge\") {\n      sourceStyle.addressMode = \"repeat\";\n      sourceStyle.update();\n    }\n  }\n  const color = Color.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\nfunction toFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  const fill = {};\n  const objectStyle = value;\n  if (isColorLike(value)) {\n    return handleColorLike(fill, value, defaultStyle);\n  } else if (isFillPattern(value)) {\n    return handleFillPattern(fill, value, defaultStyle);\n  } else if (isFillGradient(value)) {\n    return handleFillGradient(fill, value, defaultStyle);\n  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {\n    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {\n    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n  }\n  return handleFillObject(objectStyle, defaultStyle);\n}\nfunction toStrokeStyle(value, defaultStyle) {\n  const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;\n  const fill = toFillStyle(value, rest);\n  if (!fill) {\n    return null;\n  }\n  return {\n    width,\n    alignment,\n    miterLimit,\n    cap,\n    join,\n    pixelLine,\n    ...fill\n  };\n}\n\nexport { toFillStyle, toStrokeStyle };\n//# sourceMappingURL=convertFillInputToFillStyle.mjs.map\n","import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds.mjs';\nimport { deprecation } from '../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../view/ViewContainer.mjs';\n\n\"use strict\";\nclass Sprite extends ViewContainer {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = Texture.EMPTY) {\n    if (options instanceof Texture) {\n      options = { texture: options };\n    }\n    const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n    super({\n      label: \"Sprite\",\n      ...rest\n    });\n    this.renderPipeId = \"sprite\";\n    this.batched = true;\n    this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor) {\n      this.anchor = anchor;\n    } else if (texture.defaultAnchor) {\n      this.anchor = texture.defaultAnchor;\n    }\n    this.texture = texture;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * Helper function that creates a new sprite based on the source you provide.\n   * The source can be - frame id, image, video, canvas element, video element, texture\n   * @param source - Source to create texture from\n   * @param [skipCache] - Whether to skip the cache or not\n   * @returns The newly created sprite\n   */\n  static from(source, skipCache = false) {\n    if (source instanceof Texture) {\n      return new Sprite(source);\n    }\n    return new Sprite(Texture.from(source, skipCache));\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value)\n      return;\n    if (currentTexture && currentTexture.dynamic)\n      currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic)\n      value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    if (this._width) {\n      this._setWidth(this._width, this._texture.orig.width);\n    }\n    if (this._height) {\n      this._setHeight(this._height, this._texture.orig.height);\n    }\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * The bounds of the sprite, taking the texture's trim into account.\n   * @type {rendering.Bounds}\n   */\n  get visualBounds() {\n    updateQuadBounds(this._visualBounds, this._anchor, this._texture, 0);\n    return this._visualBounds;\n  }\n  /**\n   * @deprecated\n   */\n  get sourceBounds() {\n    deprecation(\"8.6.1\", \"Sprite.sourceBounds is deprecated, use visualBounds instead.\");\n    return this.visualBounds;\n  }\n  /** @private */\n  updateBounds() {\n    const anchor = this._anchor;\n    const texture = this._texture;\n    const bounds = this._bounds;\n    const { width, height } = texture.orig;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n    this._visualBounds = null;\n    this._bounds = null;\n    this._anchor = null;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Sprite } from 'pixi.js';\n   *\n   * const sprite = new Sprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this._texture.orig.width;\n  }\n  set width(value) {\n    this._setWidth(value, this._texture.orig.width);\n    this._width = value;\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this._texture.orig.height;\n  }\n  set height(value) {\n    this._setHeight(value, this._texture.orig.height);\n    this._height = value;\n  }\n  /**\n   * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Sprite.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n    out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Sprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this._texture.orig.width);\n    height !== void 0 && this._setHeight(height, this._texture.orig.height);\n  }\n}\n\nexport { Sprite };\n//# sourceMappingURL=Sprite.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nclass AbstractBitmapFont extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    /** The map of characters by character code. */\n    this.chars = /* @__PURE__ */ Object.create(null);\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    this.lineHeight = 0;\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    this.fontFamily = \"\";\n    /** The metrics of the font face. */\n    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    this.baseLineOffset = 0;\n    /** The range and type of the distance field for this font. */\n    this.distanceField = { type: \"none\", range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    this.pages = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    this.applyFillAsTint = true;\n    /** The size of the font face in pixels. */\n    this.baseMeasurementFontSize = 100;\n    this.baseRenderedFontSize = 100;\n  }\n  /**\n   * The name of the font face.\n   * @deprecated since 8.0.0 Use `fontFamily` instead.\n   */\n  get font() {\n    deprecation(v8_0_0, \"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.\");\n    return this.fontFamily;\n  }\n  /**\n   * The map of base page textures (i.e., sheets of glyphs).\n   * @deprecated since 8.0.0 Use `pages` instead.\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  /**\n   * The size of the font face in pixels.\n   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n   */\n  get size() {\n    deprecation(v8_0_0, \"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.\");\n    return this.fontMetrics.fontSize;\n  }\n  /**\n   * The kind of distance field for this font or \"none\".\n   * @deprecated since 8.0.0 Use `distanceField.type` instead.\n   */\n  get distanceFieldRange() {\n    deprecation(v8_0_0, \"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.\");\n    return this.distanceField.range;\n  }\n  /**\n   * The range of the distance field in pixels.\n   * @deprecated since 8.0.0 Use `distanceField.range` instead.\n   */\n  get distanceFieldType() {\n    deprecation(v8_0_0, \"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.\");\n    return this.distanceField.type;\n  }\n  destroy(destroyTextures = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    for (const i in this.chars) {\n      this.chars[i].texture?.destroy();\n    }\n    this.chars = null;\n    if (destroyTextures) {\n      this.pages.forEach((page) => page.texture.destroy(true));\n      this.pages = null;\n    }\n  }\n}\n\nexport { AbstractBitmapFont };\n//# sourceMappingURL=AbstractBitmapFont.mjs.map\n","\"use strict\";\nfunction resolveCharacters(chars) {\n  if (chars === \"\") {\n    return [];\n  }\n  if (typeof chars === \"string\") {\n    chars = [chars];\n  }\n  const result = [];\n  for (let i = 0, j = chars.length; i < j; i++) {\n    const item = chars[i];\n    if (Array.isArray(item)) {\n      if (item.length !== 2) {\n        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n      }\n      if (item[0].length === 0 || item[1].length === 0) {\n        throw new Error(\"[BitmapFont]: Invalid character delimiter.\");\n      }\n      const startCode = item[0].charCodeAt(0);\n      const endCode = item[1].charCodeAt(0);\n      if (endCode < startCode) {\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      }\n      for (let i2 = startCode, j2 = endCode; i2 <= j2; i2++) {\n        result.push(String.fromCharCode(i2));\n      }\n    } else {\n      result.push(...Array.from(item));\n    }\n  }\n  if (result.length === 0) {\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  }\n  return result;\n}\n\nexport { resolveCharacters };\n//# sourceMappingURL=resolveCharacters.mjs.map\n","import { Color } from '../../color/Color.mjs';\nimport { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle.mjs';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\n\"use strict\";\nconst _DynamicBitmapFont = class _DynamicBitmapFont extends AbstractBitmapFont {\n  /**\n   * @param options - The options for the dynamic bitmap font.\n   */\n  constructor(options) {\n    super();\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    this.resolution = 1;\n    /** The pages of the font. */\n    this.pages = [];\n    this._padding = 0;\n    this._measureCache = /* @__PURE__ */ Object.create(null);\n    this._currentChars = [];\n    this._currentX = 0;\n    this._currentY = 0;\n    this._currentPageIndex = -1;\n    this._skipKerning = false;\n    const dynamicOptions = { ..._DynamicBitmapFont.defaultOptions, ...options };\n    this._textureSize = dynamicOptions.textureSize;\n    this._mipmap = dynamicOptions.mipmap;\n    const style = dynamicOptions.style.clone();\n    if (dynamicOptions.overrideFill) {\n      style._fill.color = 16777215;\n      style._fill.alpha = 1;\n      style._fill.texture = Texture.WHITE;\n      style._fill.fill = null;\n    }\n    this.applyFillAsTint = dynamicOptions.overrideFill;\n    const requestedFontSize = style.fontSize;\n    style.fontSize = this.baseMeasurementFontSize;\n    const font = fontStringFromTextStyle(style);\n    if (dynamicOptions.overrideSize) {\n      if (style._stroke) {\n        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n      }\n    } else {\n      style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n    }\n    this._style = style;\n    this._skipKerning = dynamicOptions.skipKerning ?? false;\n    this.resolution = dynamicOptions.resolution ?? 1;\n    this._padding = dynamicOptions.padding ?? 4;\n    this.fontMetrics = CanvasTextMetrics.measureFont(font);\n    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n  }\n  ensureCharacters(chars) {\n    const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);\n    if (!charList.length)\n      return;\n    this._currentChars = [...this._currentChars, ...charList];\n    let pageData;\n    if (this._currentPageIndex === -1) {\n      pageData = this._nextPage();\n    } else {\n      pageData = this.pages[this._currentPageIndex];\n    }\n    let { canvas, context } = pageData.canvasAndContext;\n    let textureSource = pageData.texture.source;\n    const style = this._style;\n    let currentX = this._currentX;\n    let currentY = this._currentY;\n    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n    const padding = this._padding * fontScale;\n    let maxCharHeight = 0;\n    let skipTexture = false;\n    const maxTextureWidth = canvas.width / this.resolution;\n    const maxTextureHeight = canvas.height / this.resolution;\n    for (let i = 0; i < charList.length; i++) {\n      const char = charList[i];\n      const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n      metrics.lineHeight = metrics.height;\n      const width = metrics.width * fontScale;\n      const textureGlyphWidth = Math.ceil((style.fontStyle === \"italic\" ? 2 : 1) * width);\n      const height = metrics.height * fontScale;\n      const paddedWidth = textureGlyphWidth + padding * 2;\n      const paddedHeight = height + padding * 2;\n      skipTexture = false;\n      if (char !== \"\\n\" && char !== \"\\r\" && char !== \"\t\" && char !== \" \") {\n        skipTexture = true;\n        maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));\n      }\n      if (currentX + paddedWidth > maxTextureWidth) {\n        currentY += maxCharHeight;\n        maxCharHeight = paddedHeight;\n        currentX = 0;\n        if (currentY + maxCharHeight > maxTextureHeight) {\n          textureSource.update();\n          const pageData2 = this._nextPage();\n          canvas = pageData2.canvasAndContext.canvas;\n          context = pageData2.canvasAndContext.context;\n          textureSource = pageData2.texture.source;\n          currentY = 0;\n        }\n      }\n      const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);\n      this.chars[char] = {\n        id: char.codePointAt(0),\n        xOffset: -this._padding,\n        yOffset: -this._padding,\n        xAdvance,\n        kerning: {}\n      };\n      if (skipTexture) {\n        this._drawGlyph(\n          context,\n          metrics,\n          currentX + padding,\n          currentY + padding,\n          fontScale,\n          style\n        );\n        const px = textureSource.width * fontScale;\n        const py = textureSource.height * fontScale;\n        const frame = new Rectangle(\n          currentX / px * textureSource.width,\n          currentY / py * textureSource.height,\n          paddedWidth / px * textureSource.width,\n          paddedHeight / py * textureSource.height\n        );\n        this.chars[char].texture = new Texture({\n          source: textureSource,\n          frame\n        });\n        currentX += Math.ceil(paddedWidth);\n      }\n    }\n    textureSource.update();\n    this._currentX = currentX;\n    this._currentY = currentY;\n    this._skipKerning && this._applyKerning(charList, context);\n  }\n  /**\n   * @deprecated since 8.0.0\n   * The map of base page textures (i.e., sheets of glyphs).\n   */\n  get pageTextures() {\n    deprecation(v8_0_0, \"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.\");\n    return this.pages;\n  }\n  _applyKerning(newChars, context) {\n    const measureCache = this._measureCache;\n    for (let i = 0; i < newChars.length; i++) {\n      const first = newChars[i];\n      for (let j = 0; j < this._currentChars.length; j++) {\n        const second = this._currentChars[j];\n        let c1 = measureCache[first];\n        if (!c1)\n          c1 = measureCache[first] = context.measureText(first).width;\n        let c2 = measureCache[second];\n        if (!c2)\n          c2 = measureCache[second] = context.measureText(second).width;\n        let total = context.measureText(first + second).width;\n        let amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[first].kerning[second] = amount;\n        }\n        total = context.measureText(first + second).width;\n        amount = total - (c1 + c2);\n        if (amount) {\n          this.chars[second].kerning[first] = amount;\n        }\n      }\n    }\n  }\n  _nextPage() {\n    this._currentPageIndex++;\n    const textureResolution = this.resolution;\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n      this._textureSize,\n      this._textureSize,\n      textureResolution\n    );\n    this._setupContext(canvasAndContext.context, this._style, textureResolution);\n    const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n    const texture = new Texture({\n      source: new ImageSource({\n        resource: canvasAndContext.canvas,\n        resolution,\n        alphaMode: \"premultiply-alpha-on-upload\",\n        autoGenerateMipmaps: this._mipmap\n      })\n    });\n    const pageData = {\n      canvasAndContext,\n      texture\n    };\n    this.pages[this._currentPageIndex] = pageData;\n    return pageData;\n  }\n  // canvas style!\n  _setupContext(context, style, resolution) {\n    style.fontSize = this.baseRenderedFontSize;\n    context.scale(resolution, resolution);\n    context.font = fontStringFromTextStyle(style);\n    style.fontSize = this.baseMeasurementFontSize;\n    context.textBaseline = style.textBaseline;\n    const stroke = style._stroke;\n    const strokeThickness = stroke?.width ?? 0;\n    if (stroke) {\n      context.lineWidth = strokeThickness;\n      context.lineJoin = stroke.join;\n      context.miterLimit = stroke.miterLimit;\n      context.strokeStyle = getCanvasFillStyle(stroke, context);\n    }\n    if (style._fill) {\n      context.fillStyle = getCanvasFillStyle(style._fill, context);\n    }\n    if (style.dropShadow) {\n      const shadowOptions = style.dropShadow;\n      const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n      const dropShadowBlur = shadowOptions.blur * resolution;\n      const dropShadowDistance = shadowOptions.distance * resolution;\n      context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n      context.shadowBlur = dropShadowBlur;\n      context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n      context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n    } else {\n      context.shadowColor = \"black\";\n      context.shadowBlur = 0;\n      context.shadowOffsetX = 0;\n      context.shadowOffsetY = 0;\n    }\n  }\n  _drawGlyph(context, metrics, x, y, fontScale, style) {\n    const char = metrics.text;\n    const fontProperties = metrics.fontProperties;\n    const stroke = style._stroke;\n    const strokeThickness = (stroke?.width ?? 0) * fontScale;\n    const tx = x + strokeThickness / 2;\n    const ty = y - strokeThickness / 2;\n    const descent = fontProperties.descent * fontScale;\n    const lineHeight = metrics.lineHeight * fontScale;\n    if (style.stroke && strokeThickness) {\n      context.strokeText(char, tx, ty + lineHeight - descent);\n    }\n    if (style._fill) {\n      context.fillText(char, tx, ty + lineHeight - descent);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { canvasAndContext, texture } = this.pages[i];\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n};\n_DynamicBitmapFont.defaultOptions = {\n  textureSize: 512,\n  style: new TextStyle(),\n  mipmap: true\n};\nlet DynamicBitmapFont = _DynamicBitmapFont;\n\nexport { DynamicBitmapFont };\n//# sourceMappingURL=DynamicBitmapFont.mjs.map\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { TextStyle } from '../text/TextStyle.mjs';\nimport { DynamicBitmapFont } from './DynamicBitmapFont.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\nimport { resolveCharacters } from './utils/resolveCharacters.mjs';\n\n\"use strict\";\nlet fontCount = 0;\nclass BitmapFontManagerClass {\n  constructor() {\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    this.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    this.NUMERIC = [[\"0\", \"9\"]];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    this.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"];\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    this.ASCII = [[\" \", \"~\"]];\n    /** Default options for installing a new BitmapFont. */\n    this.defaultOptions = {\n      chars: this.ALPHANUMERIC,\n      resolution: 1,\n      padding: 4,\n      skipKerning: false\n    };\n  }\n  /**\n   * Get a font for the specified text and style.\n   * @param text - The text to get the font for\n   * @param style - The style to use\n   */\n  getFont(text, style) {\n    let fontFamilyKey = `${style.fontFamily}-bitmap`;\n    let overrideFill = true;\n    if (style._fill.fill && !style._stroke) {\n      fontFamilyKey += style._fill.fill.styleKey;\n      overrideFill = false;\n    } else if (style._stroke || style.dropShadow) {\n      let key = style.styleKey;\n      key = key.substring(0, key.lastIndexOf(\"-\"));\n      fontFamilyKey = `${key}-bitmap`;\n      overrideFill = false;\n    }\n    if (!Cache.has(fontFamilyKey)) {\n      const fnt = new DynamicBitmapFont({\n        style,\n        overrideFill,\n        overrideSize: true,\n        ...this.defaultOptions\n      });\n      fontCount++;\n      if (fontCount > 50) {\n        warn(\"BitmapText\", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n      }\n      fnt.once(\"destroy\", () => {\n        fontCount--;\n        Cache.remove(fontFamilyKey);\n      });\n      Cache.set(\n        fontFamilyKey,\n        fnt\n      );\n    }\n    const dynamicFont = Cache.get(fontFamilyKey);\n    dynamicFont.ensureCharacters?.(text);\n    return dynamicFont;\n  }\n  /**\n   * Get the layout of a text for the specified style.\n   * @param text - The text to get the layout for\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */\n  getLayout(text, style, trimEnd = true) {\n    const bitmapFont = this.getFont(text, style);\n    return getBitmapTextLayout([...text], style, bitmapFont, trimEnd);\n  }\n  /**\n   * Measure the text using the specified style.\n   * @param text - The text to measure\n   * @param style - The style to use\n   * @param trimEnd - Whether to ignore whitespaces at the end of each line\n   */\n  measureText(text, style, trimEnd = true) {\n    return this.getLayout(text, style, trimEnd);\n  }\n  // eslint-disable-next-line max-len\n  install(...args) {\n    let options = args[0];\n    if (typeof options === \"string\") {\n      options = {\n        name: options,\n        style: args[1],\n        chars: args[2]?.chars,\n        resolution: args[2]?.resolution,\n        padding: args[2]?.padding,\n        skipKerning: args[2]?.skipKerning\n      };\n      deprecation(v8_0_0, \"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})\");\n    }\n    const name = options?.name;\n    if (!name) {\n      throw new Error(\"[BitmapFontManager] Property `name` is required.\");\n    }\n    options = { ...this.defaultOptions, ...options };\n    const textStyle = options.style;\n    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n    const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;\n    const font = new DynamicBitmapFont({\n      style,\n      overrideFill,\n      skipKerning: options.skipKerning,\n      padding: options.padding,\n      resolution: options.resolution,\n      overrideSize: false\n    });\n    const flatChars = resolveCharacters(options.chars);\n    font.ensureCharacters(flatChars.join(\"\"));\n    Cache.set(`${name}-bitmap`, font);\n    font.once(\"destroy\", () => Cache.remove(`${name}-bitmap`));\n    return font;\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  uninstall(name) {\n    const cacheKey = `${name}-bitmap`;\n    const font = Cache.get(cacheKey);\n    if (font) {\n      font.destroy();\n    }\n  }\n}\nconst BitmapFontManager = new BitmapFontManagerClass();\n\nexport { BitmapFontManager };\n//# sourceMappingURL=BitmapFontManager.mjs.map\n","\"use strict\";\nfunction getBitmapTextLayout(chars, style, font, trimEnd) {\n  const layoutData = {\n    width: 0,\n    height: 0,\n    offsetY: 0,\n    scale: style.fontSize / font.baseMeasurementFontSize,\n    lines: [{\n      width: 0,\n      charPositions: [],\n      spaceWidth: 0,\n      spacesIndex: [],\n      chars: []\n    }]\n  };\n  layoutData.offsetY = font.baseLineOffset;\n  let currentLine = layoutData.lines[0];\n  let previousChar = null;\n  let firstWord = true;\n  const currentWord = {\n    spaceWord: false,\n    width: 0,\n    start: 0,\n    index: 0,\n    // use index to not modify the array as we use it a lot!\n    positions: [],\n    chars: []\n  };\n  const nextWord = (word) => {\n    const start = currentLine.width;\n    for (let j = 0; j < currentWord.index; j++) {\n      const position = word.positions[j];\n      currentLine.chars.push(word.chars[j]);\n      currentLine.charPositions.push(position + start);\n    }\n    currentLine.width += word.width;\n    firstWord = false;\n    currentWord.width = 0;\n    currentWord.index = 0;\n    currentWord.chars.length = 0;\n  };\n  const nextLine = () => {\n    let index = currentLine.chars.length - 1;\n    if (trimEnd) {\n      let lastChar = currentLine.chars[index];\n      while (lastChar === \" \") {\n        currentLine.width -= font.chars[lastChar].xAdvance;\n        lastChar = currentLine.chars[--index];\n      }\n    }\n    layoutData.width = Math.max(layoutData.width, currentLine.width);\n    currentLine = {\n      width: 0,\n      charPositions: [],\n      chars: [],\n      spaceWidth: 0,\n      spacesIndex: []\n    };\n    firstWord = true;\n    layoutData.lines.push(currentLine);\n    layoutData.height += font.lineHeight;\n  };\n  const scale = font.baseMeasurementFontSize / style.fontSize;\n  const adjustedLetterSpacing = style.letterSpacing * scale;\n  const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n  for (let i = 0; i < chars.length + 1; i++) {\n    let char;\n    const isEnd = i === chars.length;\n    if (!isEnd) {\n      char = chars[i];\n    }\n    const charData = font.chars[char] || font.chars[\" \"];\n    const isSpace = /(?:\\s)/.test(char);\n    const isWordBreak = isSpace || char === \"\\r\" || char === \"\\n\" || isEnd;\n    if (isWordBreak) {\n      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;\n      if (addWordToNextLine) {\n        nextLine();\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      } else {\n        currentWord.start = currentLine.width;\n        nextWord(currentWord);\n        if (!isEnd) {\n          currentLine.charPositions.push(0);\n        }\n      }\n      if (char === \"\\r\" || char === \"\\n\") {\n        if (currentLine.width !== 0) {\n          nextLine();\n        }\n      } else if (!isEnd) {\n        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n        currentLine.width += spaceWidth;\n        currentLine.spaceWidth = spaceWidth;\n        currentLine.spacesIndex.push(currentLine.charPositions.length);\n        currentLine.chars.push(char);\n      }\n    } else {\n      const kerning = charData.kerning[previousChar] || 0;\n      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n      currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n      currentWord.chars.push(char);\n      currentWord.width += nextCharWidth;\n    }\n    previousChar = char;\n  }\n  nextLine();\n  if (style.align === \"center\") {\n    alignCenter(layoutData);\n  } else if (style.align === \"right\") {\n    alignRight(layoutData);\n  } else if (style.align === \"justify\") {\n    alignJustify(layoutData);\n  }\n  return layoutData;\n}\nfunction alignCenter(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width / 2 - line.width / 2;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignRight(measurementData) {\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    const offset = measurementData.width - line.width;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      line.charPositions[j] += offset;\n    }\n  }\n}\nfunction alignJustify(measurementData) {\n  const width = measurementData.width;\n  for (let i = 0; i < measurementData.lines.length; i++) {\n    const line = measurementData.lines[i];\n    let indy = 0;\n    let spaceIndex = line.spacesIndex[indy++];\n    let offset = 0;\n    const totalSpaces = line.spacesIndex.length;\n    const newSpaceWidth = (width - line.width) / totalSpaces;\n    const spaceWidth = newSpaceWidth;\n    for (let j = 0; j < line.charPositions.length; j++) {\n      if (j === spaceIndex) {\n        spaceIndex = line.spacesIndex[indy++];\n        offset += spaceWidth;\n      }\n      line.charPositions[j] += offset;\n    }\n  }\n}\n\nexport { getBitmapTextLayout };\n//# sourceMappingURL=getBitmapTextLayout.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Color } from '../../color/Color.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient.mjs';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern.mjs';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext.mjs';\nimport { toFillStyle, toStrokeStyle } from '../graphics/shared/utils/convertFillInputToFillStyle.mjs';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey.mjs';\n\n\"use strict\";\nconst _TextStyle = class _TextStyle extends EventEmitter {\n  constructor(style = {}) {\n    super();\n    convertV7Tov8Style(style);\n    const fullStyle = { ..._TextStyle.defaultTextStyle, ...style };\n    for (const key in fullStyle) {\n      const thisKey = key;\n      this[thisKey] = fullStyle[key];\n    }\n    this.update();\n  }\n  /**\n   * Alignment for multiline text, does not affect single line text.\n   * @member {'left'|'center'|'right'|'justify'}\n   */\n  get align() {\n    return this._align;\n  }\n  set align(value) {\n    this._align = value;\n    this.update();\n  }\n  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n  get breakWords() {\n    return this._breakWords;\n  }\n  set breakWords(value) {\n    this._breakWords = value;\n    this.update();\n  }\n  /** Set a drop shadow for the text. */\n  get dropShadow() {\n    return this._dropShadow;\n  }\n  set dropShadow(value) {\n    if (value !== null && typeof value === \"object\") {\n      this._dropShadow = this._createProxy({ ..._TextStyle.defaultDropShadow, ...value });\n    } else {\n      this._dropShadow = value ? this._createProxy({ ..._TextStyle.defaultDropShadow }) : null;\n    }\n    this.update();\n  }\n  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n  get fontFamily() {\n    return this._fontFamily;\n  }\n  set fontFamily(value) {\n    this._fontFamily = value;\n    this.update();\n  }\n  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n  get fontSize() {\n    return this._fontSize;\n  }\n  set fontSize(value) {\n    if (typeof value === \"string\") {\n      this._fontSize = parseInt(value, 10);\n    } else {\n      this._fontSize = value;\n    }\n    this.update();\n  }\n  /**\n   * The font style.\n   * @member {'normal'|'italic'|'oblique'}\n   */\n  get fontStyle() {\n    return this._fontStyle;\n  }\n  set fontStyle(value) {\n    this._fontStyle = value.toLowerCase();\n    this.update();\n  }\n  /**\n   * The font variant.\n   * @member {'normal'|'small-caps'}\n   */\n  get fontVariant() {\n    return this._fontVariant;\n  }\n  set fontVariant(value) {\n    this._fontVariant = value;\n    this.update();\n  }\n  /**\n   * The font weight.\n   * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  get fontWeight() {\n    return this._fontWeight;\n  }\n  set fontWeight(value) {\n    this._fontWeight = value;\n    this.update();\n  }\n  /** The space between lines. */\n  get leading() {\n    return this._leading;\n  }\n  set leading(value) {\n    this._leading = value;\n    this.update();\n  }\n  /** The amount of spacing between letters, default is 0. */\n  get letterSpacing() {\n    return this._letterSpacing;\n  }\n  set letterSpacing(value) {\n    this._letterSpacing = value;\n    this.update();\n  }\n  /** The line height, a number that represents the vertical space that a letter uses. */\n  get lineHeight() {\n    return this._lineHeight;\n  }\n  set lineHeight(value) {\n    this._lineHeight = value;\n    this.update();\n  }\n  /**\n   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n   * by adding padding to all sides of the text.\n   */\n  get padding() {\n    return this._padding;\n  }\n  set padding(value) {\n    this._padding = value;\n    this.update();\n  }\n  /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n  get trim() {\n    return this._trim;\n  }\n  set trim(value) {\n    this._trim = value;\n    this.update();\n  }\n  /**\n   * The baseline of the text that is rendered.\n   * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  get textBaseline() {\n    return this._textBaseline;\n  }\n  set textBaseline(value) {\n    this._textBaseline = value;\n    this.update();\n  }\n  /**\n   * How newlines and spaces should be handled.\n   * Default is 'pre' (preserve, preserve).\n   *\n   *  value       | New lines     |   Spaces\n   *  ---         | ---           |   ---\n   * 'normal'     | Collapse      |   Collapse\n   * 'pre'        | Preserve      |   Preserve\n   * 'pre-line'   | Preserve      |   Collapse\n   * @member {'normal'|'pre'|'pre-line'}\n   */\n  get whiteSpace() {\n    return this._whiteSpace;\n  }\n  set whiteSpace(value) {\n    this._whiteSpace = value;\n    this.update();\n  }\n  /** Indicates if word wrap should be used. */\n  get wordWrap() {\n    return this._wordWrap;\n  }\n  set wordWrap(value) {\n    this._wordWrap = value;\n    this.update();\n  }\n  /** The width at which text will wrap, it needs wordWrap to be set to true. */\n  get wordWrapWidth() {\n    return this._wordWrapWidth;\n  }\n  set wordWrapWidth(value) {\n    this._wordWrapWidth = value;\n    this.update();\n  }\n  /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */\n  get fill() {\n    return this._originalFill;\n  }\n  set fill(value) {\n    if (value === this._originalFill)\n      return;\n    this._originalFill = value;\n    if (this._isFillStyle(value)) {\n      this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () => {\n        this._fill = toFillStyle(\n          { ...this._originalFill },\n          GraphicsContext.defaultFillStyle\n        );\n      });\n    }\n    this._fill = toFillStyle(\n      value === 0 ? \"black\" : value,\n      GraphicsContext.defaultFillStyle\n    );\n    this.update();\n  }\n  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n  get stroke() {\n    return this._originalStroke;\n  }\n  set stroke(value) {\n    if (value === this._originalStroke)\n      return;\n    this._originalStroke = value;\n    if (this._isFillStyle(value)) {\n      this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () => {\n        this._stroke = toStrokeStyle(\n          { ...this._originalStroke },\n          GraphicsContext.defaultStrokeStyle\n        );\n      });\n    }\n    this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    this.update();\n  }\n  _generateKey() {\n    this._styleKey = generateTextStyleKey(this);\n    return this._styleKey;\n  }\n  update() {\n    this._styleKey = null;\n    this.emit(\"update\", this);\n  }\n  /** Resets all properties to the default values */\n  reset() {\n    const defaultStyle = _TextStyle.defaultTextStyle;\n    for (const key in defaultStyle) {\n      this[key] = defaultStyle[key];\n    }\n  }\n  get styleKey() {\n    return this._styleKey || this._generateKey();\n  }\n  /**\n   * Creates a new TextStyle object with the same values as this one.\n   * @returns New cloned TextStyle object\n   */\n  clone() {\n    return new _TextStyle({\n      align: this.align,\n      breakWords: this.breakWords,\n      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n      fill: this._fill,\n      fontFamily: this.fontFamily,\n      fontSize: this.fontSize,\n      fontStyle: this.fontStyle,\n      fontVariant: this.fontVariant,\n      fontWeight: this.fontWeight,\n      leading: this.leading,\n      letterSpacing: this.letterSpacing,\n      lineHeight: this.lineHeight,\n      padding: this.padding,\n      stroke: this._stroke,\n      textBaseline: this.textBaseline,\n      whiteSpace: this.whiteSpace,\n      wordWrap: this.wordWrap,\n      wordWrapWidth: this.wordWrapWidth\n    });\n  }\n  /**\n   * Destroys this text style.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n   */\n  destroy(options = false) {\n    this.removeAllListeners();\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      if (this._fill?.texture) {\n        this._fill.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalFill?.texture) {\n        this._originalFill.texture.destroy(destroyTextureSource);\n      }\n      if (this._stroke?.texture) {\n        this._stroke.texture.destroy(destroyTextureSource);\n      }\n      if (this._originalStroke?.texture) {\n        this._originalStroke.texture.destroy(destroyTextureSource);\n      }\n    }\n    this._fill = null;\n    this._stroke = null;\n    this.dropShadow = null;\n    this._originalStroke = null;\n    this._originalFill = null;\n  }\n  _createProxy(value, cb) {\n    return new Proxy(value, {\n      set: (target, property, newValue) => {\n        target[property] = newValue;\n        cb?.(property, newValue);\n        this.update();\n        return true;\n      }\n    });\n  }\n  _isFillStyle(value) {\n    return (value ?? null) !== null && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);\n  }\n};\n/** The default drop shadow settings */\n_TextStyle.defaultDropShadow = {\n  /** Set alpha for the drop shadow */\n  alpha: 1,\n  /** Set a angle of the drop shadow */\n  angle: Math.PI / 6,\n  /** Set a shadow blur radius */\n  blur: 0,\n  /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n  color: \"black\",\n  /** Set a distance of the drop shadow */\n  distance: 5\n};\n/** The default text style settings */\n_TextStyle.defaultTextStyle = {\n  /**\n   * See {@link TextStyle.align}\n   * @type {'left'|'center'|'right'|'justify'}\n   */\n  align: \"left\",\n  /** See {@link TextStyle.breakWords} */\n  breakWords: false,\n  /** See {@link TextStyle.dropShadow} */\n  dropShadow: null,\n  /**\n   * See {@link TextStyle.fill}\n   * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n   */\n  fill: \"black\",\n  /**\n   * See {@link TextStyle.fontFamily}\n   * @type {string|string[]}\n   */\n  fontFamily: \"Arial\",\n  /**\n   * See {@link TextStyle.fontSize}\n   * @type {number|string}\n   */\n  fontSize: 26,\n  /**\n   * See {@link TextStyle.fontStyle}\n   * @type {'normal'|'italic'|'oblique'}\n   */\n  fontStyle: \"normal\",\n  /**\n   * See {@link TextStyle.fontVariant}\n   * @type {'normal'|'small-caps'}\n   */\n  fontVariant: \"normal\",\n  /**\n   * See {@link TextStyle.fontWeight}\n   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n   */\n  fontWeight: \"normal\",\n  /** See {@link TextStyle.leading} */\n  leading: 0,\n  /** See {@link TextStyle.letterSpacing} */\n  letterSpacing: 0,\n  /** See {@link TextStyle.lineHeight} */\n  lineHeight: 0,\n  /** See {@link TextStyle.padding} */\n  padding: 0,\n  /**\n   * See {@link TextStyle.stroke}\n   * @type {string|number}\n   */\n  stroke: null,\n  /**\n   * See {@link TextStyle.textBaseline}\n   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n   */\n  textBaseline: \"alphabetic\",\n  /** See {@link TextStyle.trim} */\n  trim: false,\n  /**\n   * See {@link TextStyle.whiteSpace}\n   * @type {'normal'|'pre'|'pre-line'}\n   */\n  whiteSpace: \"pre\",\n  /** See {@link TextStyle.wordWrap} */\n  wordWrap: false,\n  /** See {@link TextStyle.wordWrapWidth} */\n  wordWrapWidth: 100\n};\nlet TextStyle = _TextStyle;\nfunction convertV7Tov8Style(style) {\n  const oldStyle = style;\n  if (typeof oldStyle.dropShadow === \"boolean\" && oldStyle.dropShadow) {\n    const defaults = TextStyle.defaultDropShadow;\n    style.dropShadow = {\n      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n      angle: oldStyle.dropShadowAngle ?? defaults.angle,\n      blur: oldStyle.dropShadowBlur ?? defaults.blur,\n      color: oldStyle.dropShadowColor ?? defaults.color,\n      distance: oldStyle.dropShadowDistance ?? defaults.distance\n    };\n  }\n  if (oldStyle.strokeThickness !== void 0) {\n    deprecation(v8_0_0, \"strokeThickness is now a part of stroke\");\n    const color = oldStyle.stroke;\n    let obj = {};\n    if (Color.isColorLike(color)) {\n      obj.color = color;\n    } else if (color instanceof FillGradient || color instanceof FillPattern) {\n      obj.fill = color;\n    } else if (Object.hasOwnProperty.call(color, \"color\") || Object.hasOwnProperty.call(color, \"fill\")) {\n      obj = color;\n    } else {\n      throw new Error(\"Invalid stroke value.\");\n    }\n    style.stroke = {\n      ...obj,\n      width: oldStyle.strokeThickness\n    };\n  }\n  if (Array.isArray(oldStyle.fillGradientStops)) {\n    deprecation(v8_0_0, \"gradient fill is now a fill pattern: `new FillGradient(...)`\");\n    let fontSize;\n    if (style.fontSize == null) {\n      style.fontSize = TextStyle.defaultTextStyle.fontSize;\n    } else if (typeof style.fontSize === \"string\") {\n      fontSize = parseInt(style.fontSize, 10);\n    } else {\n      fontSize = style.fontSize;\n    }\n    const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);\n    const fills = oldStyle.fillGradientStops.map((color) => Color.shared.setValue(color).toNumber());\n    fills.forEach((number, index) => {\n      const ratio = index / (fills.length - 1);\n      gradientFill.addColorStop(ratio, number);\n    });\n    style.fill = {\n      fill: gradientFill\n    };\n  }\n}\n\nexport { TextStyle };\n//# sourceMappingURL=TextStyle.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle.mjs';\n\n\"use strict\";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = fontStringFromTextStyle(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    const metrics = context.measureText(text);\n    let metricWidth = metrics.width;\n    const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n    const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n    let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n    if (metricWidth > 0) {\n      if (useExperimentalLetterSpacing) {\n        metricWidth -= letterSpacing;\n        boundsWidth -= letterSpacing;\n      } else {\n        const val = (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n        metricWidth += val;\n        boundsWidth += val;\n      }\n    }\n    return Math.max(metricWidth, boundsWidth);\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== \"\") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convenience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== \"number\") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext(\"2d\", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = DOMAdapter.get().createCanvas();\n      } catch (_cx) {\n        canvas = DOMAdapter.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\nexport { CanvasTextMetrics };\n//# sourceMappingURL=CanvasTextMetrics.mjs.map\n","\"use strict\";\nconst genericFontFamilies = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n];\nfunction fontStringFromTextStyle(style) {\n  const fontSizeString = typeof style.fontSize === \"number\" ? `${style.fontSize}px` : style.fontSize;\n  let fontFamilies = style.fontFamily;\n  if (!Array.isArray(style.fontFamily)) {\n    fontFamilies = style.fontFamily.split(\",\");\n  }\n  for (let i = fontFamilies.length - 1; i >= 0; i--) {\n    let fontFamily = fontFamilies[i].trim();\n    if (!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {\n      fontFamily = `\"${fontFamily}\"`;\n    }\n    fontFamilies[i] = fontFamily;\n  }\n  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(\",\")}`;\n}\n\nexport { fontStringFromTextStyle };\n//# sourceMappingURL=fontStringFromTextStyle.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient.mjs';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern.mjs';\n\n\"use strict\";\nfunction getCanvasFillStyle(fillStyle, context) {\n  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {\n    return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n  } else if (!fillStyle.fill) {\n    const pattern = context.createPattern(fillStyle.texture.source.resource, \"repeat\");\n    const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n    tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillPattern) {\n    const fillPattern = fillStyle.fill;\n    const pattern = context.createPattern(fillPattern.texture.source.resource, \"repeat\");\n    const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n    tempMatrix.scale(\n      fillPattern.texture.frame.width,\n      fillPattern.texture.frame.height\n    );\n    pattern.setTransform(tempMatrix);\n    return pattern;\n  } else if (fillStyle.fill instanceof FillGradient) {\n    const fillGradient = fillStyle.fill;\n    if (fillGradient.type === \"linear\") {\n      const gradient = context.createLinearGradient(\n        fillGradient.x0,\n        fillGradient.y0,\n        fillGradient.x1,\n        fillGradient.y1\n      );\n      fillGradient.gradientStops.forEach((stop) => {\n        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n      });\n      return gradient;\n    }\n  }\n  warn(\"FillStyle not recognised\", fillStyle);\n  return \"red\";\n}\n\nexport { getCanvasFillStyle };\n//# sourceMappingURL=getCanvasFillStyle.mjs.map\n","import { Color } from '../../../color/Color.mjs';\n\n\"use strict\";\nconst valuesToIterateForKeys = [\n  \"align\",\n  \"breakWords\",\n  \"cssOverrides\",\n  \"fontVariant\",\n  \"fontWeight\",\n  \"leading\",\n  \"letterSpacing\",\n  \"lineHeight\",\n  \"padding\",\n  \"textBaseline\",\n  \"trim\",\n  \"whiteSpace\",\n  \"wordWrap\",\n  \"wordWrapWidth\",\n  \"fontFamily\",\n  \"fontStyle\",\n  \"fontSize\"\n];\nfunction generateTextStyleKey(style) {\n  const key = [];\n  let index = 0;\n  for (let i = 0; i < valuesToIterateForKeys.length; i++) {\n    const prop = `_${valuesToIterateForKeys[i]}`;\n    key[index++] = style[prop];\n  }\n  index = addFillStyleKey(style._fill, key, index);\n  index = addStokeStyleKey(style._stroke, key, index);\n  index = addDropShadowKey(style.dropShadow, key, index);\n  return key.join(\"-\");\n}\nfunction addFillStyleKey(fillStyle, key, index) {\n  if (!fillStyle)\n    return index;\n  key[index++] = fillStyle.color;\n  key[index++] = fillStyle.alpha;\n  key[index++] = fillStyle.fill?.styleKey;\n  return index;\n}\nfunction addStokeStyleKey(strokeStyle, key, index) {\n  if (!strokeStyle)\n    return index;\n  index = addFillStyleKey(strokeStyle, key, index);\n  key[index++] = strokeStyle.width;\n  key[index++] = strokeStyle.alignment;\n  key[index++] = strokeStyle.cap;\n  key[index++] = strokeStyle.join;\n  key[index++] = strokeStyle.miterLimit;\n  return index;\n}\nfunction addDropShadowKey(dropShadow, key, index) {\n  if (!dropShadow)\n    return index;\n  key[index++] = dropShadow.alpha;\n  key[index++] = dropShadow.angle;\n  key[index++] = dropShadow.blur;\n  key[index++] = dropShadow.distance;\n  key[index++] = Color.shared.setValue(dropShadow.color).toNumber();\n  return index;\n}\n\nexport { generateTextStyleKey };\n//# sourceMappingURL=generateTextStyleKey.mjs.map\n","import { Bounds } from '../container/bounds/Bounds.mjs';\nimport { Container } from '../container/Container.mjs';\n\n\"use strict\";\nclass ViewContainer extends Container {\n  constructor() {\n    super(...arguments);\n    /** @private */\n    this.canBundle = true;\n    /** @private */\n    this.allowChildren = false;\n    /** @private */\n    this._roundPixels = 0;\n    /** @private */\n    this._lastUsed = 0;\n    /** @private */\n    this._lastInstructionTick = -1;\n    this._bounds = new Bounds(0, 1, 0, 0);\n    this._boundsDirty = true;\n  }\n  /**\n   * The local bounds of the view.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this.updateBounds();\n    this._boundsDirty = false;\n    return this._bounds;\n  }\n  /**\n   * Whether or not to round the x/y position of the sprite.\n   * @type {boolean}\n   */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const bounds = this.bounds;\n    const { x, y } = point;\n    return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;\n  }\n  /** @private */\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    this._boundsDirty = true;\n    if (this.didViewUpdate)\n      return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  destroy(options) {\n    super.destroy(options);\n    this._bounds = null;\n  }\n}\n\nexport { ViewContainer };\n//# sourceMappingURL=ViewContainer.mjs.map\n","import { Rectangle } from '../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\n\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\nexport { Spritesheet };\n//# sourceMappingURL=Spritesheet.mjs.map\n","import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser.mjs';\nimport { Resolver } from '../assets/resolver/Resolver.mjs';\nimport { copySearchParams } from '../assets/utils/copySearchParams.mjs';\nimport { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { path } from '../utils/path.mjs';\nimport { Spritesheet } from './Spritesheet.mjs';\n\n\"use strict\";\nconst validImages = [\n  \"jpg\",\n  \"png\",\n  \"jpeg\",\n  \"avif\",\n  \"webp\",\n  \"basis\",\n  \"etc2\",\n  \"bc7\",\n  \"bc6h\",\n  \"bc5\",\n  \"bc4\",\n  \"bc3\",\n  \"bc2\",\n  \"bc1\",\n  \"eac\",\n  \"astc\"\n];\nfunction getCacheableAssets(keys, asset, ignoreMultiPack) {\n  const out = {};\n  keys.forEach((key) => {\n    out[key] = asset;\n  });\n  Object.keys(asset.textures).forEach((key) => {\n    out[key] = asset.textures[key];\n  });\n  if (!ignoreMultiPack) {\n    const basePath = path.dirname(keys[0]);\n    asset.linkedSheets.forEach((item, i) => {\n      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n      Object.assign(out, out2);\n    });\n  }\n  return out;\n}\nconst spritesheetAsset = {\n  extension: ExtensionType.Asset,\n  /** Handle the caching of the related Spritesheet Textures */\n  cache: {\n    test: (asset) => asset instanceof Spritesheet,\n    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)\n  },\n  /** Resolve the resolution of the asset. */\n  resolver: {\n    extension: {\n      type: ExtensionType.ResolveParser,\n      name: \"resolveSpritesheet\"\n    },\n    test: (value) => {\n      const tempURL = value.split(\"?\")[0];\n      const split = tempURL.split(\".\");\n      const extension = split.pop();\n      const format = split.pop();\n      return extension === \"json\" && validImages.includes(format);\n    },\n    parse: (value) => {\n      const split = value.split(\".\");\n      return {\n        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n        format: split[split.length - 2],\n        src: value\n      };\n    }\n  },\n  /**\n   * Loader plugin that parses sprite sheets!\n   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n   * If it is, we load the spritesheets image and parse the data into Spritesheet\n   * All textures in the sprite sheet are then added to the cache\n   */\n  loader: {\n    name: \"spritesheetLoader\",\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal,\n      name: \"spritesheetLoader\"\n    },\n    async testParse(asset, options) {\n      return path.extname(options.src).toLowerCase() === \".json\" && !!asset.frames;\n    },\n    async parse(asset, options, loader) {\n      const {\n        texture: imageTexture,\n        // if user need to use preloaded texture\n        imageFilename\n        // if user need to use custom filename (not from jsonFile.meta.image)\n      } = options?.data ?? {};\n      let basePath = path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n        basePath += \"/\";\n      }\n      let texture;\n      if (imageTexture instanceof Texture) {\n        texture = imageTexture;\n      } else {\n        const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n        const assets = await loader.load([imagePath]);\n        texture = assets[imagePath];\n      }\n      const spritesheet = new Spritesheet(\n        texture.source,\n        asset\n      );\n      await spritesheet.parse();\n      const multiPacks = asset?.meta?.related_multi_packs;\n      if (Array.isArray(multiPacks)) {\n        const promises = [];\n        for (const item of multiPacks) {\n          if (typeof item !== \"string\") {\n            continue;\n          }\n          let itemUrl = basePath + item;\n          if (options.data?.ignoreMultiPack) {\n            continue;\n          }\n          itemUrl = copySearchParams(itemUrl, options.src);\n          promises.push(loader.load({\n            src: itemUrl,\n            data: {\n              ignoreMultiPack: true\n            }\n          }));\n        }\n        const res = await Promise.all(promises);\n        spritesheet.linkedSheets = res;\n        res.forEach((item) => {\n          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));\n        });\n      }\n      return spritesheet;\n    },\n    async unload(spritesheet, _resolvedAsset, loader) {\n      await loader.unload(spritesheet.textureSource._sourceOrigin);\n      spritesheet.destroy(false);\n    }\n  }\n};\n\nexport { spritesheetAsset };\n//# sourceMappingURL=spritesheetAsset.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { spritesheetAsset } from './spritesheetAsset.mjs';\n\n\"use strict\";\nextensions.add(spritesheetAsset);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nclass TickerListener {\n  /**\n   * Constructor\n   * @private\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param priority - The priority for emitting\n   * @param once - If the handler should fire once\n   */\n  constructor(fn, context = null, priority = 0, once = false) {\n    /** The next item in chain. */\n    this.next = null;\n    /** The previous item in chain. */\n    this.previous = null;\n    /** `true` if this listener has been destroyed already. */\n    this._destroyed = false;\n    this._fn = fn;\n    this._context = context;\n    this.priority = priority;\n    this._once = once;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @returns `true` if the listener match the arguments\n   */\n  match(fn, context = null) {\n    return this._fn === fn && this._context === context;\n  }\n  /**\n   * Emit by calling the current function.\n   * @param ticker - The ticker emitting.\n   * @returns Next ticker\n   */\n  emit(ticker) {\n    if (this._fn) {\n      if (this._context) {\n        this._fn.call(this._context, ticker);\n      } else {\n        this._fn(ticker);\n      }\n    }\n    const redirect = this.next;\n    if (this._once) {\n      this.destroy(true);\n    }\n    if (this._destroyed) {\n      this.next = null;\n    }\n    return redirect;\n  }\n  /**\n   * Connect to the list.\n   * @param previous - Input node, previous listener\n   */\n  connect(previous) {\n    this.previous = previous;\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n    this.next = previous.next;\n    previous.next = this;\n  }\n  /**\n   * Destroy and don't use after this.\n   * @param hard - `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @returns The listener to redirect while emitting or removing.\n   */\n  destroy(hard = false) {\n    this._destroyed = true;\n    this._fn = null;\n    this._context = null;\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n    if (this.next) {\n      this.next.previous = this.previous;\n    }\n    const redirect = this.next;\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  }\n}\n\nexport { TickerListener };\n//# sourceMappingURL=TickerListener.mjs.map\n","import { UPDATE_PRIORITY } from './const.mjs';\nimport { TickerListener } from './TickerListener.mjs';\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\nexport { Ticker };\n//# sourceMappingURL=Ticker.mjs.map\n","\"use strict\";\nvar UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"INTERACTION\"] = 50] = \"INTERACTION\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"HIGH\"] = 25] = \"HIGH\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"NORMAL\"] = 0] = \"NORMAL\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"LOW\"] = -25] = \"LOW\";\n  UPDATE_PRIORITY2[UPDATE_PRIORITY2[\"UTILITY\"] = -50] = \"UTILITY\";\n  return UPDATE_PRIORITY2;\n})(UPDATE_PRIORITY || {});\n\nexport { UPDATE_PRIORITY };\n//# sourceMappingURL=const.mjs.map\n","\"use strict\";\nlet promise;\nasync function detectVideoAlphaMode() {\n  promise ?? (promise = (async () => {\n    const canvas = document.createElement(\"canvas\");\n    const gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const video = await new Promise((resolve) => {\n      const video2 = document.createElement(\"video\");\n      video2.onloadeddata = () => resolve(video2);\n      video2.onerror = () => resolve(null);\n      video2.autoplay = false;\n      video2.crossOrigin = \"anonymous\";\n      video2.preload = \"auto\";\n      video2.src = \"data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=\";\n      video2.load();\n    });\n    if (!video) {\n      return \"premultiply-alpha-on-upload\";\n    }\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const framebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.framebufferTexture2D(\n      gl.FRAMEBUFFER,\n      gl.COLOR_ATTACHMENT0,\n      gl.TEXTURE_2D,\n      texture,\n      0\n    );\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    gl.deleteFramebuffer(framebuffer);\n    gl.deleteTexture(texture);\n    gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    return pixel[0] <= pixel[3] ? \"premultiplied-alpha\" : \"premultiply-alpha-on-upload\";\n  })());\n  return promise;\n}\n\nexport { detectVideoAlphaMode };\n//# sourceMappingURL=detectVideoAlphaMode.mjs.map\n","\"use strict\";\nlet unsafeEval;\nfunction unsafeEvalSupported() {\n  if (typeof unsafeEval === \"boolean\") {\n    return unsafeEval;\n  }\n  try {\n    const func = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    unsafeEval = func({ a: \"b\" }, \"a\", \"b\") === true;\n  } catch (_e) {\n    unsafeEval = false;\n  }\n  return unsafeEval;\n}\n\nexport { unsafeEvalSupported };\n//# sourceMappingURL=unsafeEvalSupported.mjs.map\n","export { default as EventEmitter } from 'eventemitter3';\n\n\"use strict\";\nconst DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\nconst VERSION = \"8.6.4\";\n\nexport { DATA_URI, VERSION };\n//# sourceMappingURL=const.mjs.map\n","\"use strict\";\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === \"number\") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(`${type} isn't a valid view type`);\n    }\n  }\n}\n\nexport { ViewableBuffer };\n//# sourceMappingURL=ViewableBuffer.mjs.map\n","\"use strict\";\nfunction removeItems(arr, startIdx, removeCount) {\n  const length = arr.length;\n  let i;\n  if (startIdx >= length || removeCount === 0) {\n    return;\n  }\n  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;\n  const len = length - removeCount;\n  for (i = startIdx; i < len; ++i) {\n    arr[i] = arr[i + removeCount];\n  }\n  arr.length = len;\n}\n\nexport { removeItems };\n//# sourceMappingURL=removeItems.mjs.map\n","\"use strict\";\nconst uidCache = {\n  default: -1\n};\nfunction uid(name = \"default\") {\n  if (uidCache[name] === void 0) {\n    uidCache[name] = -1;\n  }\n  return ++uidCache[name];\n}\nfunction resetUids() {\n  for (const key in uidCache) {\n    delete uidCache[key];\n  }\n}\n\nexport { resetUids, uid };\n//# sourceMappingURL=uid.mjs.map\n","\"use strict\";\nfunction updateQuadBounds(bounds, anchor, texture, padding) {\n  const { width, height } = texture.orig;\n  const trim = texture.trim;\n  if (trim) {\n    const sourceWidth = trim.width;\n    const sourceHeight = trim.height;\n    bounds.minX = trim.x - anchor._x * width - padding;\n    bounds.maxX = bounds.minX + sourceWidth;\n    bounds.minY = trim.y - anchor._y * height - padding;\n    bounds.maxY = bounds.minY + sourceHeight;\n  } else {\n    bounds.minX = -anchor._x * width - padding;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height - padding;\n    bounds.maxY = bounds.minY + height;\n  }\n  return;\n}\n\nexport { updateQuadBounds };\n//# sourceMappingURL=updateQuadBounds.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { VERSION } from '../const.mjs';\n\n\"use strict\";\nclass ApplicationInitHook {\n  static init() {\n    globalThis.__PIXI_APP_INIT__?.(this, VERSION);\n  }\n  static destroy() {\n  }\n}\n/** @ignore */\nApplicationInitHook.extension = ExtensionType.Application;\nclass RendererInitHook {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  init() {\n    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nRendererInitHook.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"initHook\",\n  priority: -10\n};\n\nexport { ApplicationInitHook, RendererInitHook };\n//# sourceMappingURL=globalHooks.mjs.map\n","\"use strict\";\nconst warnings = {};\nconst v8_0_0 = \"8.0.0\";\nconst v8_3_4 = \"8.3.4\";\nfunction deprecation(version, message, ignoreDepth = 3) {\n  if (warnings[message]) {\n    return;\n  }\n  let stack = new Error().stack;\n  if (typeof stack === \"undefined\") {\n    console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n  } else {\n    stack = stack.split(\"\\n\").splice(ignoreDepth).join(\"\\n\");\n    if (console.groupCollapsed) {\n      console.groupCollapsed(\n        \"%cPixiJS Deprecation Warning: %c%s\",\n        \"color:#614108;background:#fffbe6\",\n        \"font-weight:normal;color:#614108;background:#fffbe6\",\n        `${message}\nDeprecated since v${version}`\n      );\n      console.warn(stack);\n      console.groupEnd();\n    } else {\n      console.warn(\"PixiJS Deprecation Warning: \", `${message}\nDeprecated since v${version}`);\n      console.warn(stack);\n    }\n  }\n  warnings[message] = true;\n}\n\nexport { deprecation, v8_0_0, v8_3_4 };\n//# sourceMappingURL=deprecation.mjs.map\n","\"use strict\";\nlet warnCount = 0;\nconst maxWarnings = 500;\nfunction warn(...args) {\n  if (warnCount === maxWarnings)\n    return;\n  warnCount++;\n  if (warnCount === maxWarnings) {\n    console.warn(\"PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.\");\n  } else {\n    console.warn(\"PixiJS Warning: \", ...args);\n  }\n}\n\nexport { warn };\n//# sourceMappingURL=warn.mjs.map\n","import { DOMAdapter } from '../environment/adapter.mjs';\n\n\"use strict\";\nfunction assertPath(path2) {\n  if (typeof path2 !== \"string\") {\n    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);\n  }\n}\nfunction removeUrlParams(url) {\n  const re = url.split(\"?\")[0];\n  return re.split(\"#\")[0];\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), \"g\"), replace);\n}\nfunction normalizeStringPosix(path2, allowAboveRoot) {\n  let res = \"\";\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = -1;\n  for (let i = 0; i <= path2.length; ++i) {\n    if (i < path2.length) {\n      code = path2.charCodeAt(i);\n    } else if (code === 47) {\n      break;\n    } else {\n      code = 47;\n    }\n    if (code === 47) {\n      if (lastSlash === i - 1 || dots === 1) {\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\");\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = \"\";\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\");\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\";\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += \"/..\";\n          } else {\n            res = \"..\";\n          }\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `/${path2.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path2.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nconst path = {\n  /**\n   * Converts a path to posix format.\n   * @param path - The path to convert to posix\n   */\n  toPosix(path2) {\n    return replaceAll(path2, \"\\\\\", \"/\");\n  },\n  /**\n   * Checks if the path is a URL e.g. http://, https://\n   * @param path - The path to check\n   */\n  isUrl(path2) {\n    return /^https?:/.test(this.toPosix(path2));\n  },\n  /**\n   * Checks if the path is a data URL\n   * @param path - The path to check\n   */\n  isDataUrl(path2) {\n    return /^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i.test(path2);\n  },\n  /**\n   * Checks if the path is a blob URL\n   * @param path - The path to check\n   */\n  isBlobUrl(path2) {\n    return path2.startsWith(\"blob:\");\n  },\n  /**\n   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n   * This will return true for windows file paths\n   * @param path - The path to check\n   */\n  hasProtocol(path2) {\n    return /^[^/:]+:/.test(this.toPosix(path2));\n  },\n  /**\n   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n   * @param path - The path to get the protocol from\n   */\n  getProtocol(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    const matchFile = /^file:\\/\\/\\//.exec(path2);\n    if (matchFile) {\n      return matchFile[0];\n    }\n    const matchProtocol = /^[^/:]+:\\/{0,2}/.exec(path2);\n    if (matchProtocol) {\n      return matchProtocol[0];\n    }\n    return \"\";\n  },\n  /**\n   * Converts URL to an absolute path.\n   * When loading from a Web Worker, we must use absolute paths.\n   * If the URL is already absolute we return it as is\n   * If it's not, we convert it\n   * @param url - The URL to test\n   * @param customBaseUrl - The base URL to use\n   * @param customRootUrl - The root URL to use\n   */\n  toAbsolute(url, customBaseUrl, customRootUrl) {\n    assertPath(url);\n    if (this.isDataUrl(url) || this.isBlobUrl(url))\n      return url;\n    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n    url = this.toPosix(url);\n    if (url.startsWith(\"/\")) {\n      return path.join(rootUrl, url.slice(1));\n    }\n    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n    return absolutePath;\n  },\n  /**\n   * Normalizes the given path, resolving '..' and '.' segments\n   * @param path - The path to normalize\n   */\n  normalize(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    if (this.isDataUrl(path2) || this.isBlobUrl(path2))\n      return path2;\n    path2 = this.toPosix(path2);\n    let protocol = \"\";\n    const isAbsolute = path2.startsWith(\"/\");\n    if (this.hasProtocol(path2)) {\n      protocol = this.rootname(path2);\n      path2 = path2.slice(protocol.length);\n    }\n    const trailingSeparator = path2.endsWith(\"/\");\n    path2 = normalizeStringPosix(path2, false);\n    if (path2.length > 0 && trailingSeparator)\n      path2 += \"/\";\n    if (isAbsolute)\n      return `/${path2}`;\n    return protocol + path2;\n  },\n  /**\n   * Determines if path is an absolute path.\n   * Absolute paths can be urls, data urls, or paths on disk\n   * @param path - The path to test\n   */\n  isAbsolute(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    if (this.hasProtocol(path2))\n      return true;\n    return path2.startsWith(\"/\");\n  },\n  /**\n   * Joins all given path segments together using the platform-specific separator as a delimiter,\n   * then normalizes the resulting path\n   * @param segments - The segments of the path to join\n   */\n  join(...segments) {\n    if (segments.length === 0) {\n      return \".\";\n    }\n    let joined;\n    for (let i = 0; i < segments.length; ++i) {\n      const arg = segments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === void 0)\n          joined = arg;\n        else {\n          const prevArg = segments[i - 1] ?? \"\";\n          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {\n            joined += `/../${arg}`;\n          } else {\n            joined += `/${arg}`;\n          }\n        }\n      }\n    }\n    if (joined === void 0) {\n      return \".\";\n    }\n    return this.normalize(joined);\n  },\n  /**\n   * Returns the directory name of a path\n   * @param path - The path to parse\n   */\n  dirname(path2) {\n    assertPath(path2);\n    if (path2.length === 0)\n      return \".\";\n    path2 = this.toPosix(path2);\n    let code = path2.charCodeAt(0);\n    const hasRoot = code === 47;\n    let end = -1;\n    let matchedSlash = true;\n    const proto = this.getProtocol(path2);\n    const origpath = path2;\n    path2 = path2.slice(proto.length);\n    for (let i = path2.length - 1; i >= 1; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1)\n      return hasRoot ? \"/\" : this.isUrl(origpath) ? proto + path2 : proto;\n    if (hasRoot && end === 1)\n      return \"//\";\n    return proto + path2.slice(0, end);\n  },\n  /**\n   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n   * @param path - The path to parse\n   */\n  rootname(path2) {\n    assertPath(path2);\n    path2 = this.toPosix(path2);\n    let root = \"\";\n    if (path2.startsWith(\"/\"))\n      root = \"/\";\n    else {\n      root = this.getProtocol(path2);\n    }\n    if (this.isUrl(path2)) {\n      const index = path2.indexOf(\"/\", root.length);\n      if (index !== -1) {\n        root = path2.slice(0, index);\n      } else\n        root = path2;\n      if (!root.endsWith(\"/\"))\n        root += \"/\";\n    }\n    return root;\n  },\n  /**\n   * Returns the last portion of a path\n   * @param path - The path to test\n   * @param ext - Optional extension to remove\n   */\n  basename(path2, ext) {\n    assertPath(path2);\n    if (ext)\n      assertPath(ext);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {\n      if (ext.length === path2.length && ext === path2)\n        return \"\";\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path2.length - 1; i >= 0; --i) {\n        const code = path2.charCodeAt(i);\n        if (code === 47) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path2.length;\n      return path2.slice(start, end);\n    }\n    for (i = path2.length - 1; i >= 0; --i) {\n      if (path2.charCodeAt(i) === 47) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1)\n      return \"\";\n    return path2.slice(start, end);\n  },\n  /**\n   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n   * the first character of the basename of path, an empty string is returned.\n   * @param path - The path to parse\n   */\n  extname(path2) {\n    assertPath(path2);\n    path2 = removeUrlParams(this.toPosix(path2));\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path2.length - 1; i >= 0; --i) {\n      const code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return \"\";\n    }\n    return path2.slice(startDot, end);\n  },\n  /**\n   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n   * @param path - The path to parse\n   */\n  parse(path2) {\n    assertPath(path2);\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" };\n    if (path2.length === 0)\n      return ret;\n    path2 = removeUrlParams(this.toPosix(path2));\n    let code = path2.charCodeAt(0);\n    const isAbsolute = this.isAbsolute(path2);\n    let start;\n    const protocol = \"\";\n    ret.root = this.rootname(path2);\n    if (isAbsolute || this.hasProtocol(path2)) {\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path2.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      code = path2.charCodeAt(i);\n      if (code === 47) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path2.slice(1, end);\n        else\n          ret.base = ret.name = path2.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path2.slice(1, startDot);\n        ret.base = path2.slice(1, end);\n      } else {\n        ret.name = path2.slice(startPart, startDot);\n        ret.base = path2.slice(startPart, end);\n      }\n      ret.ext = path2.slice(startDot, end);\n    }\n    ret.dir = this.dirname(path2);\n    if (protocol)\n      ret.dir = protocol + ret.dir;\n    return ret;\n  },\n  sep: \"/\",\n  delimiter: \":\",\n  joinExtensions: [\".html\"]\n};\n\nexport { path };\n//# sourceMappingURL=path.mjs.map\n","\"use strict\";\nclass Pool {\n  /**\n   * Constructs a new Pool.\n   * @param ClassType - The constructor of the items in the pool.\n   * @param {number} [initialSize] - The initial size of the pool.\n   */\n  constructor(ClassType, initialSize) {\n    this._pool = [];\n    this._count = 0;\n    this._index = 0;\n    this._classType = ClassType;\n    if (initialSize) {\n      this.prepopulate(initialSize);\n    }\n  }\n  /**\n   * Prepopulates the pool with a given number of items.\n   * @param total - The number of items to add to the pool.\n   */\n  prepopulate(total) {\n    for (let i = 0; i < total; i++) {\n      this._pool[this._index++] = new this._classType();\n    }\n    this._count += total;\n  }\n  /**\n   * Gets an item from the pool. Calls the item's `init` method if it exists.\n   * If there are no items left in the pool, a new one will be created.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(data) {\n    let item;\n    if (this._index > 0) {\n      item = this._pool[--this._index];\n    } else {\n      item = new this._classType();\n    }\n    item.init?.(data);\n    return item;\n  }\n  /**\n   * Returns an item to the pool. Calls the item's `reset` method if it exists.\n   * @param {T} item - The item to return to the pool.\n   */\n  return(item) {\n    item.reset?.();\n    this._pool[this._index++] = item;\n  }\n  /**\n   * Gets the number of items in the pool.\n   * @readonly\n   * @member {number}\n   */\n  get totalSize() {\n    return this._count;\n  }\n  /**\n   * Gets the number of items in the pool that are free to use without needing to create more.\n   * @readonly\n   * @member {number}\n   */\n  get totalFree() {\n    return this._index;\n  }\n  /**\n   * Gets the number of items in the pool that are currently in use.\n   * @readonly\n   * @member {number}\n   */\n  get totalUsed() {\n    return this._count - this._index;\n  }\n  /** clears the pool - mainly used for debugging! */\n  clear() {\n    this._pool.length = 0;\n    this._index = 0;\n  }\n}\n\nexport { Pool };\n//# sourceMappingURL=Pool.mjs.map\n","import { Pool } from './Pool.mjs';\n\n\"use strict\";\nclass PoolGroupClass {\n  constructor() {\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    this._poolsByClass = /* @__PURE__ */ new Map();\n  }\n  /**\n   * Prepopulates a specific pool with a given number of items.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {number} total - The number of items to add to the pool.\n   */\n  prepopulate(Class, total) {\n    const classPool = this.getPool(Class);\n    classPool.prepopulate(total);\n  }\n  /**\n   * Gets an item from a specific pool.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n   * @param {unknown} [data] - Optional data to pass to the item's constructor.\n   * @returns {T} The item from the pool.\n   */\n  get(Class, data) {\n    const pool = this.getPool(Class);\n    return pool.get(data);\n  }\n  /**\n   * Returns an item to its respective pool.\n   * @param {PoolItem} item - The item to return to the pool.\n   */\n  return(item) {\n    const pool = this.getPool(item.constructor);\n    pool.return(item);\n  }\n  /**\n   * Gets a specific pool based on the class type.\n   * @template T The type of items in the pool. Must extend PoolItem.\n   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n   * @returns {Pool<T>} The pool of the given class type.\n   */\n  getPool(ClassType) {\n    if (!this._poolsByClass.has(ClassType)) {\n      this._poolsByClass.set(ClassType, new Pool(ClassType));\n    }\n    return this._poolsByClass.get(ClassType);\n  }\n  /** gets the usage stats of each pool in the system */\n  stats() {\n    const stats = {};\n    this._poolsByClass.forEach((pool) => {\n      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;\n      stats[name] = {\n        free: pool.totalFree,\n        used: pool.totalUsed,\n        size: pool.totalSize\n      };\n    });\n    return stats;\n  }\n}\nconst BigPool = new PoolGroupClass();\n\nexport { BigPool, PoolGroupClass };\n//# sourceMappingURL=PoolGroup.mjs.map\n","import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + __webpack_require__.h() + \".js\";\n};","__webpack_require__.h = () => (\"1f329ca3da31e13efb96\")","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t792: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunklower_case_dashed_name_of_project\"] = self[\"webpackChunklower_case_dashed_name_of_project\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// Adapted from https://pixijs.com/8.x/tutorials/spine-boy-adventure#6\nconst keyMap = {\n    Space: 'space',\n    KeyW: 'up',\n    ArrowUp: 'up',\n    KeyA: 'left',\n    ArrowLeft: 'left',\n    KeyS: 'down',\n    ArrowDown: 'down',\n    KeyD: 'right',\n    ArrowRight: 'right',\n    KeyN: 'next'\n};\nexport class Controller {\n    constructor(dblTapDelayMs) {\n        if (!dblTapDelayMs)\n            this.delay = 300;\n        this.keys = {\n            space: { pressed: false, doubleTap: false, timestamp: 0 },\n            up: { pressed: false, doubleTap: false, timestamp: 0 },\n            down: { pressed: false, doubleTap: false, timestamp: 0 },\n            left: { pressed: false, doubleTap: false, timestamp: 0 },\n            right: { pressed: false, doubleTap: false, timestamp: 0 },\n            next: { pressed: false, doubleTap: false, timestamp: 0 },\n        };\n        this.keyUpCallbacks = [];\n        this.keyDownCallbacks = [];\n        window.addEventListener('keydown', (ev) => this.keydownHandler(ev));\n        window.addEventListener('keyup', (ev) => this.keyupHandler(ev));\n    }\n    attachKeyUpCallback(fn) {\n        this.keyUpCallbacks.push(fn);\n    }\n    attachKeyDownCallback(fn) {\n        this.keyDownCallbacks.push(fn);\n    }\n    keydownHandler(ev) {\n        const key = keyMap[ev.code];\n        if (!key)\n            return;\n        const now = Date.now();\n        this.keys[key].doubleTap = this.keys[key].doubleTap || now - this.keys[key].timestamp < this.delay;\n        this.keys[key].pressed = true;\n        this.keyDownCallbacks.forEach(fn => fn(key, this.keys[key]));\n    }\n    keyupHandler(ev) {\n        const key = keyMap[ev.code];\n        if (!key)\n            return;\n        const now = Date.now();\n        this.keys[key].pressed = false;\n        if (this.keys[key].doubleTap)\n            this.keys[key].doubleTap = false;\n        else\n            this.keys[key].timestamp = now;\n        this.keyUpCallbacks.forEach(fn => fn(key, this.keys[key]));\n    }\n}\nexport const controller = new Controller(100);\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst browserExt = {\n  extension: {\n    type: ExtensionType.Environment,\n    name: \"browser\",\n    priority: -1\n  },\n  test: () => true,\n  load: async () => {\n    await import('./browserAll.mjs');\n  }\n};\n\nexport { browserExt };\n//# sourceMappingURL=browserExt.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nconst webworkerExt = {\n  extension: {\n    type: ExtensionType.Environment,\n    name: \"webworker\",\n    priority: 0\n  },\n  test: () => typeof self !== \"undefined\" && self.WorkerGlobalScope !== void 0,\n  load: async () => {\n    await import('./webworkerAll.mjs');\n  }\n};\n\nexport { webworkerExt };\n//# sourceMappingURL=webworkerExt.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer.mjs';\n\n\"use strict\";\nlet _isWebGLSupported;\nfunction isWebGLSupported(failIfMajorPerformanceCaveat) {\n  if (_isWebGLSupported !== void 0)\n    return _isWebGLSupported;\n  _isWebGLSupported = (() => {\n    const contextOptions = {\n      stencil: true,\n      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n    };\n    try {\n      if (!DOMAdapter.get().getWebGLRenderingContext()) {\n        return false;\n      }\n      const canvas = DOMAdapter.get().createCanvas();\n      let gl = canvas.getContext(\"webgl\", contextOptions);\n      const success = !!gl?.getContextAttributes()?.stencil;\n      if (gl) {\n        const loseContext = gl.getExtension(\"WEBGL_lose_context\");\n        if (loseContext) {\n          loseContext.loseContext();\n        }\n      }\n      gl = null;\n      return success;\n    } catch (_e) {\n      return false;\n    }\n  })();\n  return _isWebGLSupported;\n}\n\nexport { isWebGLSupported };\n//# sourceMappingURL=isWebGLSupported.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nlet _isWebGPUSupported;\nasync function isWebGPUSupported(options = {}) {\n  if (_isWebGPUSupported !== void 0)\n    return _isWebGPUSupported;\n  _isWebGPUSupported = await (async () => {\n    const gpu = DOMAdapter.get().getNavigator().gpu;\n    if (!gpu) {\n      return false;\n    }\n    try {\n      const adapter = await gpu.requestAdapter(options);\n      await adapter.requestDevice();\n      return true;\n    } catch (_e) {\n      return false;\n    }\n  })();\n  return _isWebGPUSupported;\n}\n\nexport { isWebGPUSupported };\n//# sourceMappingURL=isWebGPUSupported.mjs.map\n","import { isWebGLSupported } from '../../utils/browser/isWebGLSupported.mjs';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported.mjs';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer.mjs';\n\n\"use strict\";\nconst renderPriority = [\"webgl\", \"webgpu\", \"canvas\"];\nasync function autoDetectRenderer(options) {\n  let preferredOrder = [];\n  if (options.preference) {\n    preferredOrder.push(options.preference);\n    renderPriority.forEach((item) => {\n      if (item !== options.preference) {\n        preferredOrder.push(item);\n      }\n    });\n  } else {\n    preferredOrder = renderPriority.slice();\n  }\n  let RendererClass;\n  let finalOptions = {};\n  for (let i = 0; i < preferredOrder.length; i++) {\n    const rendererType = preferredOrder[i];\n    if (rendererType === \"webgpu\" && await isWebGPUSupported()) {\n      const { WebGPURenderer } = await import('./gpu/WebGPURenderer.mjs');\n      RendererClass = WebGPURenderer;\n      finalOptions = { ...options, ...options.webgpu };\n      break;\n    } else if (rendererType === \"webgl\" && isWebGLSupported(\n      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n    )) {\n      const { WebGLRenderer } = await import('./gl/WebGLRenderer.mjs');\n      RendererClass = WebGLRenderer;\n      finalOptions = { ...options, ...options.webgl };\n      break;\n    } else if (rendererType === \"canvas\") {\n      finalOptions = { ...options };\n      throw new Error(\"CanvasRenderer is not yet implemented\");\n    }\n  }\n  delete finalOptions.webgpu;\n  delete finalOptions.webgl;\n  if (!RendererClass) {\n    throw new Error(\"No available renderer for the current environment\");\n  }\n  const renderer = new RendererClass();\n  await renderer.init(finalOptions);\n  return renderer;\n}\n\nexport { autoDetectRenderer };\n//# sourceMappingURL=autoDetectRenderer.mjs.map\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer.mjs';\nimport { Container } from '../scene/container/Container.mjs';\nimport { ApplicationInitHook } from '../utils/global/globalHooks.mjs';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _Application = class _Application {\n  /** @ignore */\n  constructor(...args) {\n    /** The root display container that's rendered. */\n    this.stage = new Container();\n    if (args[0] !== void 0) {\n      deprecation(v8_0_0, \"Application constructor options are deprecated, please use Application.init() instead.\");\n    }\n  }\n  /**\n   * @param options - The optional application and renderer parameters.\n   */\n  async init(options) {\n    options = { ...options };\n    this.renderer = await autoDetectRenderer(options);\n    _Application._plugins.forEach((plugin) => {\n      plugin.init.call(this, options);\n    });\n  }\n  /** Render the current stage. */\n  render() {\n    this.renderer.render({ container: this.stage });\n  }\n  /**\n   * Reference to the renderer's canvas element.\n   * @readonly\n   * @member {HTMLCanvasElement}\n   */\n  get canvas() {\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer's canvas element.\n   * @member {HTMLCanvasElement}\n   * @deprecated since 8.0.0\n   */\n  get view() {\n    deprecation(v8_0_0, \"Application.view is deprecated, please use Application.canvas instead.\");\n    return this.renderer.canvas;\n  }\n  /**\n   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n   * @readonly\n   */\n  get screen() {\n    return this.renderer.screen;\n  }\n  /**\n   * Destroys the application and all of its resources.\n   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n   * @param {object|boolean} [options=false] - The options for destroying the stage.\n   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n   * called as well. `options` will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n   * If options.children is set to true,\n   * it should destroy the texture of the child sprite.\n   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n   *  If options.children is set to true,\n   * it should destroy the texture source of the child sprite.\n   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n   * If options.children is set to true,\n   * it should destroy the context of the child graphics.\n   */\n  destroy(rendererDestroyOptions = false, options = false) {\n    const plugins = _Application._plugins.slice(0);\n    plugins.reverse();\n    plugins.forEach((plugin) => {\n      plugin.destroy.call(this);\n    });\n    this.stage.destroy(options);\n    this.stage = null;\n    this.renderer.destroy(rendererDestroyOptions);\n    this.renderer = null;\n  }\n};\n/**\n * Collection of installed plugins.\n * @alias _plugins\n */\n_Application._plugins = [];\nlet Application = _Application;\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ApplicationInitHook);\n\nexport { Application };\n//# sourceMappingURL=Application.mjs.map\n","import { Rectangle } from '../../maths/shapes/Rectangle.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { AbstractBitmapFont } from './AbstractBitmapFont.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\n\n\"use strict\";\nclass BitmapFont extends AbstractBitmapFont {\n  constructor(options, url) {\n    super();\n    const { textures, data } = options;\n    Object.keys(data.pages).forEach((key) => {\n      const pageData = data.pages[parseInt(key, 10)];\n      const texture = textures[pageData.id];\n      this.pages.push({ texture });\n    });\n    Object.keys(data.chars).forEach((key) => {\n      const charData = data.chars[key];\n      const {\n        frame: textureFrame,\n        source: textureSource\n      } = textures[charData.page];\n      const frameReal = new Rectangle(\n        charData.x + textureFrame.x,\n        charData.y + textureFrame.y,\n        charData.width,\n        charData.height\n      );\n      const texture = new Texture({\n        source: textureSource,\n        frame: frameReal\n      });\n      this.chars[key] = {\n        id: key.codePointAt(0),\n        xOffset: charData.xOffset,\n        yOffset: charData.yOffset,\n        xAdvance: charData.xAdvance,\n        kerning: charData.kerning ?? {},\n        texture\n      };\n    });\n    this.baseRenderedFontSize = data.fontSize;\n    this.baseMeasurementFontSize = data.fontSize;\n    this.fontMetrics = {\n      ascent: 0,\n      descent: 0,\n      fontSize: data.fontSize\n    };\n    this.baseLineOffset = data.baseLineOffset;\n    this.lineHeight = data.lineHeight;\n    this.fontFamily = data.fontFamily;\n    this.distanceField = data.distanceField ?? {\n      type: \"none\",\n      range: 0\n    };\n    this.url = url;\n  }\n  /** Destroys the BitmapFont object. */\n  destroy() {\n    super.destroy();\n    for (let i = 0; i < this.pages.length; i++) {\n      const { texture } = this.pages[i];\n      texture.destroy(true);\n    }\n    this.pages = null;\n  }\n  /**\n   * Generates a bitmap-font for the given style and character set\n   * @param options - Setup options for font generation.\n   * @returns Font generated by style options.\n   * @example\n   * import { BitmapFont, BitmapText } from 'pixi.js';\n   *\n   * BitmapFont.install('TitleFont', {\n   *     fontFamily: 'Arial',\n   *     fontSize: 12,\n   *     strokeThickness: 2,\n   *     fill: 'purple',\n   * });\n   *\n   * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n   */\n  static install(options) {\n    BitmapFontManager.install(options);\n  }\n  /**\n   * Uninstalls a bitmap font from the cache.\n   * @param {string} name - The name of the bitmap font to uninstall.\n   */\n  static uninstall(name) {\n    BitmapFontManager.uninstall(name);\n  }\n}\n\nexport { BitmapFont };\n//# sourceMappingURL=BitmapFont.mjs.map\n","\"use strict\";\nconst bitmapFontTextParser = {\n  test(data) {\n    return typeof data === \"string\" && data.startsWith(\"info face=\");\n  },\n  parse(txt) {\n    const items = txt.match(/^[a-z]+\\s+.+$/gm);\n    const rawData = {\n      info: [],\n      common: [],\n      page: [],\n      char: [],\n      chars: [],\n      kerning: [],\n      kernings: [],\n      distanceField: []\n    };\n    for (const i in items) {\n      const name = items[i].match(/^[a-z]+/gm)[0];\n      const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n      const itemData = {};\n      for (const i2 in attributeList) {\n        const split = attributeList[i2].split(\"=\");\n        const key = split[0];\n        const strValue = split[1].replace(/\"/gm, \"\");\n        const floatValue = parseFloat(strValue);\n        const value = isNaN(floatValue) ? strValue : floatValue;\n        itemData[key] = value;\n      }\n      rawData[name].push(itemData);\n    }\n    const font = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const [info] = rawData.info;\n    const [common] = rawData.common;\n    const [distanceField] = rawData.distanceField ?? [];\n    if (distanceField) {\n      font.distanceField = {\n        range: parseInt(distanceField.distanceRange, 10),\n        type: distanceField.fieldType\n      };\n    }\n    font.fontSize = parseInt(info.size, 10);\n    font.fontFamily = info.face;\n    font.lineHeight = parseInt(common.lineHeight, 10);\n    const page = rawData.page;\n    for (let i = 0; i < page.length; i++) {\n      font.pages.push({\n        id: parseInt(page[i].id, 10) || 0,\n        file: page[i].file\n      });\n    }\n    const map = {};\n    font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n    const char = rawData.char;\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.id, 10);\n      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n      if (letter === \"space\")\n        letter = \" \";\n      map[id] = letter;\n      font.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.page, 10) || 0,\n        x: parseInt(charNode.x, 10),\n        y: parseInt(charNode.y, 10),\n        width: parseInt(charNode.width, 10),\n        height: parseInt(charNode.height, 10),\n        xOffset: parseInt(charNode.xoffset, 10),\n        yOffset: parseInt(charNode.yoffset, 10),\n        xAdvance: parseInt(charNode.xadvance, 10),\n        kerning: {}\n      };\n    }\n    const kerning = rawData.kerning || [];\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].first, 10);\n      const second = parseInt(kerning[i].second, 10);\n      const amount = parseInt(kerning[i].amount, 10);\n      font.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return font;\n  }\n};\n\nexport { bitmapFontTextParser };\n//# sourceMappingURL=bitmapFontTextParser.mjs.map\n","\"use strict\";\nconst bitmapFontXMLParser = {\n  test(data) {\n    const xml = data;\n    return typeof xml !== \"string\" && \"getElementsByTagName\" in xml && xml.getElementsByTagName(\"page\").length && xml.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n  },\n  parse(xml) {\n    const data = {\n      chars: {},\n      pages: [],\n      lineHeight: 0,\n      fontSize: 0,\n      fontFamily: \"\",\n      distanceField: null,\n      baseLineOffset: 0\n    };\n    const info = xml.getElementsByTagName(\"info\")[0];\n    const common = xml.getElementsByTagName(\"common\")[0];\n    const distanceField = xml.getElementsByTagName(\"distanceField\")[0];\n    if (distanceField) {\n      data.distanceField = {\n        type: distanceField.getAttribute(\"fieldType\"),\n        range: parseInt(distanceField.getAttribute(\"distanceRange\"), 10)\n      };\n    }\n    const page = xml.getElementsByTagName(\"page\");\n    const char = xml.getElementsByTagName(\"char\");\n    const kerning = xml.getElementsByTagName(\"kerning\");\n    data.fontSize = parseInt(info.getAttribute(\"size\"), 10);\n    data.fontFamily = info.getAttribute(\"face\");\n    data.lineHeight = parseInt(common.getAttribute(\"lineHeight\"), 10);\n    for (let i = 0; i < page.length; i++) {\n      data.pages.push({\n        id: parseInt(page[i].getAttribute(\"id\"), 10) || 0,\n        file: page[i].getAttribute(\"file\")\n      });\n    }\n    const map = {};\n    data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute(\"base\"), 10);\n    for (let i = 0; i < char.length; i++) {\n      const charNode = char[i];\n      const id = parseInt(charNode.getAttribute(\"id\"), 10);\n      let letter = charNode.getAttribute(\"letter\") ?? charNode.getAttribute(\"char\") ?? String.fromCharCode(id);\n      if (letter === \"space\")\n        letter = \" \";\n      map[id] = letter;\n      data.chars[letter] = {\n        id,\n        // texture deets..\n        page: parseInt(charNode.getAttribute(\"page\"), 10) || 0,\n        x: parseInt(charNode.getAttribute(\"x\"), 10),\n        y: parseInt(charNode.getAttribute(\"y\"), 10),\n        width: parseInt(charNode.getAttribute(\"width\"), 10),\n        height: parseInt(charNode.getAttribute(\"height\"), 10),\n        // render deets..\n        xOffset: parseInt(charNode.getAttribute(\"xoffset\"), 10),\n        yOffset: parseInt(charNode.getAttribute(\"yoffset\"), 10),\n        // + baseLineOffset,\n        xAdvance: parseInt(charNode.getAttribute(\"xadvance\"), 10),\n        kerning: {}\n      };\n    }\n    for (let i = 0; i < kerning.length; i++) {\n      const first = parseInt(kerning[i].getAttribute(\"first\"), 10);\n      const second = parseInt(kerning[i].getAttribute(\"second\"), 10);\n      const amount = parseInt(kerning[i].getAttribute(\"amount\"), 10);\n      data.chars[map[second]].kerning[map[first]] = amount;\n    }\n    return data;\n  }\n};\n\nexport { bitmapFontXMLParser };\n//# sourceMappingURL=bitmapFontXMLParser.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser.mjs';\n\n\"use strict\";\nconst bitmapFontXMLStringParser = {\n  test(data) {\n    if (typeof data === \"string\" && data.includes(\"<font>\")) {\n      return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n    }\n    return false;\n  },\n  parse(data) {\n    return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n  }\n};\n\nexport { bitmapFontXMLStringParser };\n//# sourceMappingURL=bitmapFontXMLStringParser.mjs.map\n","import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser.mjs';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams.mjs';\nimport { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { path } from '../../../utils/path.mjs';\nimport { BitmapFont } from '../BitmapFont.mjs';\nimport { bitmapFontTextParser } from './bitmapFontTextParser.mjs';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser.mjs';\n\n\"use strict\";\nconst validExtensions = [\".xml\", \".fnt\"];\nconst bitmapFontCachePlugin = {\n  extension: {\n    type: ExtensionType.CacheParser,\n    name: \"cacheBitmapFont\"\n  },\n  test: (asset) => asset instanceof BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach((key) => {\n      out[key] = asset;\n      out[`${key}-bitmap`] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Normal\n  },\n  name: \"loadBitmapFont\",\n  test(url) {\n    return validExtensions.includes(path.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);\n    const { src } = data;\n    const { pages } = bitmapFontData;\n    const textureUrls = [];\n    const textureOptions = bitmapFontData.distanceField ? {\n      scaleMode: \"linear\",\n      alphaMode: \"premultiply-alpha-on-upload\",\n      autoGenerateMipmaps: false,\n      resolution: 1\n    } : {};\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path.join(path.dirname(src), pageFile);\n      imagePath = copySearchParams(imagePath, src);\n      textureUrls.push({\n        src: imagePath,\n        data: textureOptions\n      });\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map((url) => loadedTextures[url.src]);\n    const bitmapFont = new BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await DOMAdapter.get().fetch(url);\n    return await response.text();\n  },\n  async unload(bitmapFont, _resolvedAsset, loader) {\n    await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n    bitmapFont.destroy();\n  }\n};\n\nexport { bitmapFontCachePlugin, loadBitmapFont };\n//# sourceMappingURL=loadBitmapFont.mjs.map\n","\"use strict\";\nclass BackgroundLoader {\n  /**\n   * @param loader\n   * @param verbose - should the loader log to the console\n   */\n  constructor(loader, verbose = false) {\n    this._loader = loader;\n    this._assetList = [];\n    this._isLoading = false;\n    this._maxConcurrent = 1;\n    this.verbose = verbose;\n  }\n  /**\n   * Adds an array of assets to load.\n   * @param assetUrls - assets to load\n   */\n  add(assetUrls) {\n    assetUrls.forEach((a) => {\n      this._assetList.push(a);\n    });\n    if (this.verbose) {\n      console.log(\"[BackgroundLoader] assets: \", this._assetList);\n    }\n    if (this._isActive && !this._isLoading) {\n      void this._next();\n    }\n  }\n  /**\n   * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n   *\n   * The max assets it will try to load at one time will be 4.\n   */\n  async _next() {\n    if (this._assetList.length && this._isActive) {\n      this._isLoading = true;\n      const toLoad = [];\n      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n      for (let i = 0; i < toLoadAmount; i++) {\n        toLoad.push(this._assetList.pop());\n      }\n      await this._loader.load(toLoad);\n      this._isLoading = false;\n      void this._next();\n    }\n  }\n  /**\n   * Activate/Deactivate the loading. If set to true then it will immediately continue to load the next asset.\n   * @returns whether the class is active\n   */\n  get active() {\n    return this._isActive;\n  }\n  set active(value) {\n    if (this._isActive === value)\n      return;\n    this._isActive = value;\n    if (value && !this._isLoading) {\n      void this._next();\n    }\n  }\n}\n\nexport { BackgroundLoader };\n//# sourceMappingURL=BackgroundLoader.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\n\n\"use strict\";\nconst cacheTextureArray = {\n  extension: {\n    type: ExtensionType.CacheParser,\n    name: \"cacheTextureArray\"\n  },\n  test: (asset) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n  getCacheableAssets: (keys, asset) => {\n    const out = {};\n    keys.forEach((key) => {\n      asset.forEach((item, i) => {\n        out[key + (i === 0 ? \"\" : i + 1)] = item;\n      });\n    });\n    return out;\n  }\n};\n\nexport { cacheTextureArray };\n//# sourceMappingURL=cacheTextureArray.mjs.map\n","\"use strict\";\nasync function testImageFormat(imageData) {\n  if (\"Image\" in globalThis) {\n    return new Promise((resolve) => {\n      const image = new Image();\n      image.onload = () => {\n        resolve(true);\n      };\n      image.onerror = () => {\n        resolve(false);\n      };\n      image.src = imageData;\n    });\n  }\n  if (\"createImageBitmap\" in globalThis && \"fetch\" in globalThis) {\n    try {\n      const blob = await (await fetch(imageData)).blob();\n      await createImageBitmap(blob);\n    } catch (_e) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport { testImageFormat };\n//# sourceMappingURL=testImageFormat.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testImageFormat } from '../utils/testImageFormat.mjs';\n\n\"use strict\";\nconst detectAvif = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 1\n  },\n  test: async () => testImageFormat(\n    // eslint-disable-next-line max-len\n    \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=\"\n  ),\n  add: async (formats) => [...formats, \"avif\"],\n  remove: async (formats) => formats.filter((f) => f !== \"avif\")\n};\n\nexport { detectAvif };\n//# sourceMappingURL=detectAvif.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst imageFormats = [\"png\", \"jpg\", \"jpeg\"];\nconst detectDefaults = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: -1\n  },\n  test: () => Promise.resolve(true),\n  add: async (formats) => [...formats, ...imageFormats],\n  remove: async (formats) => formats.filter((f) => !imageFormats.includes(f))\n};\n\nexport { detectDefaults };\n//# sourceMappingURL=detectDefaults.mjs.map\n","\"use strict\";\nconst inWorker = \"WorkerGlobalScope\" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;\nfunction testVideoFormat(mimeType) {\n  if (inWorker) {\n    return false;\n  }\n  const video = document.createElement(\"video\");\n  return video.canPlayType(mimeType) !== \"\";\n}\n\nexport { testVideoFormat };\n//# sourceMappingURL=testVideoFormat.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testVideoFormat } from '../utils/testVideoFormat.mjs';\n\n\"use strict\";\nconst detectMp4 = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat(\"video/mp4\"),\n  add: async (formats) => [...formats, \"mp4\", \"m4v\"],\n  remove: async (formats) => formats.filter((f) => f !== \"mp4\" && f !== \"m4v\")\n};\n\nexport { detectMp4 };\n//# sourceMappingURL=detectMp4.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testVideoFormat } from '../utils/testVideoFormat.mjs';\n\n\"use strict\";\nconst detectOgv = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat(\"video/ogg\"),\n  add: async (formats) => [...formats, \"ogv\"],\n  remove: async (formats) => formats.filter((f) => f !== \"ogv\")\n};\n\nexport { detectOgv };\n//# sourceMappingURL=detectOgv.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testVideoFormat } from '../utils/testVideoFormat.mjs';\n\n\"use strict\";\nconst detectWebm = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testVideoFormat(\"video/webm\"),\n  add: async (formats) => [...formats, \"webm\"],\n  remove: async (formats) => formats.filter((f) => f !== \"webm\")\n};\n\nexport { detectWebm };\n//# sourceMappingURL=detectWebm.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { testImageFormat } from '../utils/testImageFormat.mjs';\n\n\"use strict\";\nconst detectWebp = {\n  extension: {\n    type: ExtensionType.DetectionParser,\n    priority: 0\n  },\n  test: async () => testImageFormat(\n    \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=\"\n  ),\n  add: async (formats) => [...formats, \"webp\"],\n  remove: async (formats) => formats.filter((f) => f !== \"webp\")\n};\n\nexport { detectWebp };\n//# sourceMappingURL=detectWebp.mjs.map\n","import { warn } from '../../utils/logging/warn.mjs';\nimport { path } from '../../utils/path.mjs';\nimport { convertToList } from '../utils/convertToList.mjs';\nimport { isSingleItem } from '../utils/isSingleItem.mjs';\n\n\"use strict\";\nclass Loader {\n  constructor() {\n    this._parsers = [];\n    this._parsersValidated = false;\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    this.parsers = new Proxy(this._parsers, {\n      set: (target, key, value) => {\n        this._parsersValidated = false;\n        target[key] = value;\n        return true;\n      }\n    });\n    /** Cache loading promises that ae currently active */\n    this.promiseCache = {};\n  }\n  /** function used for testing */\n  reset() {\n    this._parsersValidated = false;\n    this.promiseCache = {};\n  }\n  /**\n   * Used internally to generate a promise for the asset to be loaded.\n   * @param url - The URL to be loaded\n   * @param data - any custom additional information relevant to the asset being loaded\n   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n   */\n  _getLoadPromiseAndParser(url, data) {\n    const result = {\n      promise: null,\n      parser: null\n    };\n    result.promise = (async () => {\n      let asset = null;\n      let parser = null;\n      if (data.loadParser) {\n        parser = this._parserHash[data.loadParser];\n        if (!parser) {\n          warn(`[Assets] specified load parser \"${data.loadParser}\" not found while loading ${url}`);\n        }\n      }\n      if (!parser) {\n        for (let i = 0; i < this.parsers.length; i++) {\n          const parserX = this.parsers[i];\n          if (parserX.load && parserX.test?.(url, data, this)) {\n            parser = parserX;\n            break;\n          }\n        }\n        if (!parser) {\n          warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n          return null;\n        }\n      }\n      asset = await parser.load(url, data, this);\n      result.parser = parser;\n      for (let i = 0; i < this.parsers.length; i++) {\n        const parser2 = this.parsers[i];\n        if (parser2.parse) {\n          if (parser2.parse && await parser2.testParse?.(asset, data, this)) {\n            asset = await parser2.parse(asset, data, this) || asset;\n            result.parser = parser2;\n          }\n        }\n      }\n      return asset;\n    })();\n    return result;\n  }\n  async load(assetsToLoadIn, onProgress) {\n    if (!this._parsersValidated) {\n      this._validateParsers();\n    }\n    let count = 0;\n    const assets = {};\n    const singleAsset = isSingleItem(assetsToLoadIn);\n    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({\n      alias: [item],\n      src: item,\n      data: {}\n    }));\n    const total = assetsToLoad.length;\n    const promises = assetsToLoad.map(async (asset) => {\n      const url = path.toAbsolute(asset.src);\n      if (!assets[asset.src]) {\n        try {\n          if (!this.promiseCache[url]) {\n            this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n          }\n          assets[asset.src] = await this.promiseCache[url].promise;\n          if (onProgress)\n            onProgress(++count / total);\n        } catch (e) {\n          delete this.promiseCache[url];\n          delete assets[asset.src];\n          throw new Error(`[Loader.load] Failed to load ${url}.\n${e}`);\n        }\n      }\n    });\n    await Promise.all(promises);\n    return singleAsset ? assets[assetsToLoad[0].src] : assets;\n  }\n  /**\n   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n   * The parser that created the asset, will be the one that unloads it.\n   * @example\n   * // Single asset:\n   * const asset = await Loader.load('cool.png');\n   *\n   * await Loader.unload('cool.png');\n   *\n   * console.log(asset.destroyed); // true\n   * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n   */\n  async unload(assetsToUnloadIn) {\n    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({\n      alias: [item],\n      src: item\n    }));\n    const promises = assetsToUnload.map(async (asset) => {\n      const url = path.toAbsolute(asset.src);\n      const loadPromise = this.promiseCache[url];\n      if (loadPromise) {\n        const loadedAsset = await loadPromise.promise;\n        delete this.promiseCache[url];\n        await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n      }\n    });\n    await Promise.all(promises);\n  }\n  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n  _validateParsers() {\n    this._parsersValidated = true;\n    this._parserHash = this._parsers.filter((parser) => parser.name).reduce((hash, parser) => {\n      if (!parser.name) {\n        warn(`[Assets] loadParser should have a name`);\n      } else if (hash[parser.name]) {\n        warn(`[Assets] loadParser name conflict \"${parser.name}\"`);\n      }\n      return { ...hash, [parser.name]: parser };\n    }, {});\n  }\n}\n\nexport { Loader };\n//# sourceMappingURL=Loader.mjs.map\n","\"use strict\";\nfunction checkDataUrl(url, mimes) {\n  if (Array.isArray(mimes)) {\n    for (const mime of mimes) {\n      if (url.startsWith(`data:${mime}`))\n        return true;\n    }\n    return false;\n  }\n  return url.startsWith(`data:${mimes}`);\n}\n\nexport { checkDataUrl };\n//# sourceMappingURL=checkDataUrl.mjs.map\n","import { path } from '../../utils/path.mjs';\n\n\"use strict\";\nfunction checkExtension(url, extension) {\n  const tempURL = url.split(\"?\")[0];\n  const ext = path.extname(tempURL).toLowerCase();\n  if (Array.isArray(extension)) {\n    return extension.includes(ext);\n  }\n  return ext === extension;\n}\n\nexport { checkExtension };\n//# sourceMappingURL=checkExtension.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { checkDataUrl } from '../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from './LoaderParser.mjs';\n\n\"use strict\";\nconst validJSONExtension = \".json\";\nconst validJSONMIME = \"application/json\";\nconst loadJson = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: \"loadJson\",\n  test(url) {\n    return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n  },\n  async load(url) {\n    const response = await DOMAdapter.get().fetch(url);\n    const json = await response.json();\n    return json;\n  }\n};\n\nexport { loadJson };\n//# sourceMappingURL=loadJson.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { checkDataUrl } from '../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from './LoaderParser.mjs';\n\n\"use strict\";\nconst validTXTExtension = \".txt\";\nconst validTXTMIME = \"text/plain\";\nconst loadTxt = {\n  name: \"loadTxt\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low,\n    name: \"loadTxt\"\n  },\n  test(url) {\n    return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n  },\n  async load(url) {\n    const response = await DOMAdapter.get().fetch(url);\n    const txt = await response.text();\n    return txt;\n  }\n};\n\nexport { loadTxt };\n//# sourceMappingURL=loadTxt.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\nimport { path } from '../../../utils/path.mjs';\nimport { Cache } from '../../cache/Cache.mjs';\nimport { checkDataUrl } from '../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from './LoaderParser.mjs';\n\n\"use strict\";\nconst validWeights = [\n  \"normal\",\n  \"bold\",\n  \"100\",\n  \"200\",\n  \"300\",\n  \"400\",\n  \"500\",\n  \"600\",\n  \"700\",\n  \"800\",\n  \"900\"\n];\nconst validFontExtensions = [\".ttf\", \".otf\", \".woff\", \".woff2\"];\nconst validFontMIMEs = [\n  \"font/ttf\",\n  \"font/otf\",\n  \"font/woff\",\n  \"font/woff2\"\n];\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\nfunction getFontFamilyName(url) {\n  const ext = path.extname(url);\n  const name = path.basename(url, ext);\n  const nameWithSpaces = name.replace(/(-|_)/g, \" \");\n  const nameTokens = nameWithSpaces.toLowerCase().split(\" \").map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n  let valid = nameTokens.length > 0;\n  for (const token of nameTokens) {\n    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {\n      valid = false;\n      break;\n    }\n  }\n  let fontFamilyName = nameTokens.join(\" \");\n  if (!valid) {\n    fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, \"\\\\$&\")}\"`;\n  }\n  return fontFamilyName;\n}\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\nfunction encodeURIWhenNeeded(uri) {\n  if (validURICharactersRegex.test(uri)) {\n    return uri;\n  }\n  return encodeURI(uri);\n}\nconst loadWebFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low\n  },\n  name: \"loadWebFont\",\n  test(url) {\n    return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n  },\n  async load(url, options) {\n    const fonts = DOMAdapter.get().getFontFaceSet();\n    if (fonts) {\n      const fontFaces = [];\n      const name = options.data?.family ?? getFontFamilyName(url);\n      const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? [\"normal\"];\n      const data = options.data ?? {};\n      for (let i = 0; i < weights.length; i++) {\n        const weight = weights[i];\n        const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n          ...data,\n          weight\n        });\n        await font.load();\n        fonts.add(font);\n        fontFaces.push(font);\n      }\n      Cache.set(`${name}-and-url`, {\n        url,\n        fontFaces\n      });\n      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n    }\n    warn(\"[loadWebFont] FontFace API is not supported. Skipping loading font\");\n    return null;\n  },\n  unload(font) {\n    (Array.isArray(font) ? font : [font]).forEach((t) => {\n      Cache.remove(t.family);\n      DOMAdapter.get().getFontFaceSet().delete(t);\n    });\n  }\n};\n\nexport { getFontFamilyName, loadWebFont };\n//# sourceMappingURL=loadWebFont.mjs.map\n","import { Resolver } from '../../assets/resolver/Resolver.mjs';\n\n\"use strict\";\nfunction getResolutionOfUrl(url, defaultValue = 1) {\n  const resolution = Resolver.RETINA_PREFIX?.exec(url);\n  if (resolution) {\n    return parseFloat(resolution[1]);\n  }\n  return defaultValue;\n}\n\nexport { getResolutionOfUrl };\n//# sourceMappingURL=getResolutionOfUrl.mjs.map\n","import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\nimport { Cache } from '../../../../cache/Cache.mjs';\n\n\"use strict\";\nfunction createTexture(source, loader, url) {\n  source.label = url;\n  source._sourceOrigin = url;\n  const texture = new Texture({\n    source,\n    label: url\n  });\n  const unload = () => {\n    delete loader.promiseCache[url];\n    if (Cache.has(url)) {\n      Cache.remove(url);\n    }\n  };\n  texture.source.once(\"destroy\", () => {\n    if (loader.promiseCache[url]) {\n      warn(\"[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.\");\n      unload();\n    }\n  });\n  texture.once(\"destroy\", () => {\n    if (!source.destroyed) {\n      warn(\"[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.\");\n      unload();\n    }\n  });\n  return texture;\n}\n\nexport { createTexture };\n//# sourceMappingURL=createTexture.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validSVGExtension = \".svg\";\nconst validSVGMIME = \"image/svg+xml\";\nconst loadSvg = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Low,\n    name: \"loadSVG\"\n  },\n  name: \"loadSVG\",\n  config: {\n    crossOrigin: \"anonymous\",\n    parseAsGraphicsContext: false\n  },\n  test(url) {\n    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n  },\n  async load(url, asset, loader) {\n    if (asset.data.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext) {\n      return loadAsGraphics(url);\n    }\n    return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n  },\n  unload(asset) {\n    asset.destroy(true);\n  }\n};\nasync function loadAsTexture(url, asset, loader, crossOrigin) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const blobUrl = URL.createObjectURL(blob);\n  const image = new Image();\n  image.src = blobUrl;\n  image.crossOrigin = crossOrigin;\n  await image.decode();\n  URL.revokeObjectURL(blobUrl);\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n  const width = asset.data?.width ?? image.width;\n  const height = asset.data?.height ?? image.height;\n  canvas.width = width * resolution;\n  canvas.height = height * resolution;\n  context.drawImage(image, 0, 0, width * resolution, height * resolution);\n  const { parseAsGraphicsContext: _p, ...rest } = asset.data;\n  const base = new ImageSource({\n    resource: canvas,\n    alphaMode: \"premultiply-alpha-on-upload\",\n    resolution,\n    ...rest\n  });\n  return createTexture(base, loader, url);\n}\nasync function loadAsGraphics(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const svgSource = await response.text();\n  const context = new GraphicsContext();\n  context.svg(svgSource);\n  return context;\n}\n\nexport { loadSvg };\n//# sourceMappingURL=loadSVG.mjs.map\n","const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    const WHITE_PNG = \\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\\\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \\\"function\\\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (_e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=checkImageBitmap.worker.mjs.map\n","const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    async function loadImageBitmap(url, alphaMode) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      return alphaMode === \\\"premultiplied-alpha\\\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \\\"none\\\" }) : createImageBitmap(imageBlob);\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=loadImageBitmap.worker.mjs.map\n","import WorkerInstance from '../../../_virtual/checkImageBitmap.worker.mjs';\nimport WorkerInstance$1 from '../../../_virtual/loadImageBitmap.worker.mjs';\n\n\"use strict\";\nlet UUID = 0;\nlet MAX_WORKERS;\nclass WorkerManagerClass {\n  constructor() {\n    this._initialized = false;\n    this._createdWorkers = 0;\n    this._workerPool = [];\n    this._queue = [];\n    this._resolveHash = {};\n  }\n  isImageBitmapSupported() {\n    if (this._isImageBitmapSupported !== void 0)\n      return this._isImageBitmapSupported;\n    this._isImageBitmapSupported = new Promise((resolve) => {\n      const { worker } = new WorkerInstance();\n      worker.addEventListener(\"message\", (event) => {\n        worker.terminate();\n        WorkerInstance.revokeObjectURL();\n        resolve(event.data);\n      });\n    });\n    return this._isImageBitmapSupported;\n  }\n  loadImageBitmap(src, asset) {\n    return this._run(\"loadImageBitmap\", [src, asset?.data?.alphaMode]);\n  }\n  async _initWorkers() {\n    if (this._initialized)\n      return;\n    this._initialized = true;\n  }\n  _getWorker() {\n    if (MAX_WORKERS === void 0) {\n      MAX_WORKERS = navigator.hardwareConcurrency || 4;\n    }\n    let worker = this._workerPool.pop();\n    if (!worker && this._createdWorkers < MAX_WORKERS) {\n      this._createdWorkers++;\n      worker = new WorkerInstance$1().worker;\n      worker.addEventListener(\"message\", (event) => {\n        this._complete(event.data);\n        this._returnWorker(event.target);\n        this._next();\n      });\n    }\n    return worker;\n  }\n  _returnWorker(worker) {\n    this._workerPool.push(worker);\n  }\n  _complete(data) {\n    if (data.error !== void 0) {\n      this._resolveHash[data.uuid].reject(data.error);\n    } else {\n      this._resolveHash[data.uuid].resolve(data.data);\n    }\n    this._resolveHash[data.uuid] = null;\n  }\n  async _run(id, args) {\n    await this._initWorkers();\n    const promise = new Promise((resolve, reject) => {\n      this._queue.push({ id, arguments: args, resolve, reject });\n    });\n    this._next();\n    return promise;\n  }\n  _next() {\n    if (!this._queue.length)\n      return;\n    const worker = this._getWorker();\n    if (!worker) {\n      return;\n    }\n    const toDo = this._queue.pop();\n    const id = toDo.id;\n    this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n    worker.postMessage({\n      data: toDo.arguments,\n      uuid: UUID++,\n      id\n    });\n  }\n}\nconst WorkerManager = new WorkerManagerClass();\n\nexport { WorkerManager };\n//# sourceMappingURL=WorkerManager.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { WorkerManager } from '../../workers/WorkerManager.mjs';\nimport { LoaderParserPriority } from '../LoaderParser.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validImageExtensions = [\".jpeg\", \".jpg\", \".png\", \".webp\", \".avif\"];\nconst validImageMIMEs = [\n  \"image/jpeg\",\n  \"image/png\",\n  \"image/webp\",\n  \"image/avif\"\n];\nasync function loadImageBitmap(url, asset) {\n  const response = await DOMAdapter.get().fetch(url);\n  if (!response.ok) {\n    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n  }\n  const imageBlob = await response.blob();\n  return asset?.data?.alphaMode === \"premultiplied-alpha\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \"none\" }) : createImageBitmap(imageBlob);\n}\nconst loadTextures = {\n  name: \"loadTextures\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.High,\n    name: \"loadTextures\"\n  },\n  config: {\n    preferWorkers: true,\n    preferCreateImageBitmap: true,\n    crossOrigin: \"anonymous\"\n  },\n  test(url) {\n    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n  },\n  async load(url, asset, loader) {\n    let src = null;\n    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {\n      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {\n        src = await WorkerManager.loadImageBitmap(url, asset);\n      } else {\n        src = await loadImageBitmap(url, asset);\n      }\n    } else {\n      src = await new Promise((resolve) => {\n        src = new Image();\n        src.crossOrigin = this.config.crossOrigin;\n        src.src = url;\n        if (src.complete) {\n          resolve(src);\n        } else {\n          src.onload = () => {\n            resolve(src);\n          };\n        }\n      });\n    }\n    const base = new ImageSource({\n      resource: src,\n      alphaMode: \"premultiply-alpha-on-upload\",\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      ...asset.data\n    });\n    return createTexture(base, loader, url);\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexport { loadImageBitmap, loadTextures };\n//# sourceMappingURL=loadTextures.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource.mjs';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode.mjs';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl.mjs';\nimport { checkDataUrl } from '../../../utils/checkDataUrl.mjs';\nimport { checkExtension } from '../../../utils/checkExtension.mjs';\nimport { createTexture } from './utils/createTexture.mjs';\n\n\"use strict\";\nconst validVideoExtensions = [\".mp4\", \".m4v\", \".webm\", \".ogg\", \".ogv\", \".h264\", \".avi\", \".mov\"];\nconst validVideoMIMEs = validVideoExtensions.map((ext) => `video/${ext.substring(1)}`);\nfunction crossOrigin(element, url, crossorigin) {\n  if (crossorigin === void 0 && !url.startsWith(\"data:\")) {\n    element.crossOrigin = determineCrossOrigin(url);\n  } else if (crossorigin !== false) {\n    element.crossOrigin = typeof crossorigin === \"string\" ? crossorigin : \"anonymous\";\n  }\n}\nfunction preloadVideo(element) {\n  return new Promise((resolve, reject) => {\n    element.addEventListener(\"canplaythrough\", loaded);\n    element.addEventListener(\"error\", error);\n    element.load();\n    function loaded() {\n      cleanup();\n      resolve();\n    }\n    function error(err) {\n      cleanup();\n      reject(err);\n    }\n    function cleanup() {\n      element.removeEventListener(\"canplaythrough\", loaded);\n      element.removeEventListener(\"error\", error);\n    }\n  });\n}\nfunction determineCrossOrigin(url, loc = globalThis.location) {\n  if (url.startsWith(\"data:\")) {\n    return \"\";\n  }\n  loc || (loc = globalThis.location);\n  const parsedUrl = new URL(url, document.baseURI);\n  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {\n    return \"anonymous\";\n  }\n  return \"\";\n}\nconst loadVideoTextures = {\n  name: \"loadVideo\",\n  extension: {\n    type: ExtensionType.LoadParser,\n    name: \"loadVideo\"\n  },\n  test(url) {\n    const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n    const isValidExtension = checkExtension(url, validVideoExtensions);\n    return isValidDataUrl || isValidExtension;\n  },\n  async load(url, asset, loader) {\n    const options = {\n      ...VideoSource.defaultOptions,\n      resolution: asset.data?.resolution || getResolutionOfUrl(url),\n      alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n      ...asset.data\n    };\n    const videoElement = document.createElement(\"video\");\n    const attributeMap = {\n      preload: options.autoLoad !== false ? \"auto\" : void 0,\n      \"webkit-playsinline\": options.playsinline !== false ? \"\" : void 0,\n      playsinline: options.playsinline !== false ? \"\" : void 0,\n      muted: options.muted === true ? \"\" : void 0,\n      loop: options.loop === true ? \"\" : void 0,\n      autoplay: options.autoPlay !== false ? \"\" : void 0\n    };\n    Object.keys(attributeMap).forEach((key) => {\n      const value = attributeMap[key];\n      if (value !== void 0)\n        videoElement.setAttribute(key, value);\n    });\n    if (options.muted === true) {\n      videoElement.muted = true;\n    }\n    crossOrigin(videoElement, url, options.crossorigin);\n    const sourceElement = document.createElement(\"source\");\n    let mime;\n    if (url.startsWith(\"data:\")) {\n      mime = url.slice(5, url.indexOf(\";\"));\n    } else if (!url.startsWith(\"blob:\")) {\n      const ext = url.split(\"?\")[0].slice(url.lastIndexOf(\".\") + 1).toLowerCase();\n      mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n    }\n    sourceElement.src = url;\n    if (mime) {\n      sourceElement.type = mime;\n    }\n    return new Promise((resolve) => {\n      const onCanPlay = async () => {\n        const base = new VideoSource({ ...options, resource: videoElement });\n        videoElement.removeEventListener(\"canplay\", onCanPlay);\n        if (asset.data.preload) {\n          await preloadVideo(videoElement);\n        }\n        resolve(createTexture(base, loader, url));\n      };\n      videoElement.addEventListener(\"canplay\", onCanPlay);\n      videoElement.appendChild(sourceElement);\n    });\n  },\n  unload(texture) {\n    texture.destroy(true);\n  }\n};\n\nexport { crossOrigin, determineCrossOrigin, loadVideoTextures, preloadVideo };\n//# sourceMappingURL=loadVideoTextures.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { loadTextures } from '../../loader/parsers/textures/loadTextures.mjs';\nimport { Resolver } from '../Resolver.mjs';\n\n\"use strict\";\nconst resolveTextureUrl = {\n  extension: {\n    type: ExtensionType.ResolveParser,\n    name: \"resolveTexture\"\n  },\n  test: loadTextures.test,\n  parse: (value) => ({\n    resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? \"1\"),\n    format: value.split(\".\").pop(),\n    src: value\n  })\n};\n\nexport { resolveTextureUrl };\n//# sourceMappingURL=resolveTextureUrl.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Resolver } from '../Resolver.mjs';\nimport { resolveTextureUrl } from './resolveTextureUrl.mjs';\n\n\"use strict\";\nconst resolveJsonUrl = {\n  extension: {\n    type: ExtensionType.ResolveParser,\n    priority: -2,\n    name: \"resolveJson\"\n  },\n  test: (value) => Resolver.RETINA_PREFIX.test(value) && value.endsWith(\".json\"),\n  parse: resolveTextureUrl.parse\n};\n\nexport { resolveJsonUrl };\n//# sourceMappingURL=resolveJsonUrl.mjs.map\n","import { extensions, ExtensionType } from '../extensions/Extensions.mjs';\nimport { loadBitmapFont, bitmapFontCachePlugin } from '../scene/text-bitmap/asset/loadBitmapFont.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\nimport { BackgroundLoader } from './BackgroundLoader.mjs';\nimport { Cache } from './cache/Cache.mjs';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray.mjs';\nimport { detectAvif } from './detections/parsers/detectAvif.mjs';\nimport { detectDefaults } from './detections/parsers/detectDefaults.mjs';\nimport { detectMp4 } from './detections/parsers/detectMp4.mjs';\nimport { detectOgv } from './detections/parsers/detectOgv.mjs';\nimport { detectWebm } from './detections/parsers/detectWebm.mjs';\nimport { detectWebp } from './detections/parsers/detectWebp.mjs';\nimport { Loader } from './loader/Loader.mjs';\nimport { loadJson } from './loader/parsers/loadJson.mjs';\nimport { loadTxt } from './loader/parsers/loadTxt.mjs';\nimport { loadWebFont } from './loader/parsers/loadWebFont.mjs';\nimport { loadSvg } from './loader/parsers/textures/loadSVG.mjs';\nimport { loadTextures } from './loader/parsers/textures/loadTextures.mjs';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures.mjs';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl.mjs';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl.mjs';\nimport { Resolver } from './resolver/Resolver.mjs';\nimport { convertToList } from './utils/convertToList.mjs';\nimport { isSingleItem } from './utils/isSingleItem.mjs';\n\n\"use strict\";\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver();\n    this.loader = new Loader();\n    this.cache = Cache;\n    this._backgroundLoader = new BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Assets manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      warn(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === \"string\") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === \"number\" ? [resolutionPref] : resolutionPref;\n    const formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  /**\n   * Allows you to specify how to resolve any assets load requests.\n   * There are a few ways to add things here as shown below:\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Simple\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n   * const bunny = await Assets.load('bunnyBooBoo');\n   *\n   * // Multiple keys:\n   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n   *\n   * const bunny = await Assets.load('burger');\n   * const bunny2 = await Assets.load('chicken');\n   *\n   * // passing options to to the object\n   * Assets.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny.{png,webp}',\n   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * // Multiple assets\n   *\n   * // The following all do the same thing:\n   *\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.{png,webp}'});\n   *\n   * Assets.add({\n   *     alias: 'bunnyBooBoo',\n   *     src: [\n   *         'bunny.png',\n   *         'bunny.webp',\n   *    ],\n   * });\n   *\n   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n   * @param assets - the unresolved assets to add to the resolver\n   */\n  add(assets) {\n    this.resolver.add(assets);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = isSingleItem(urls);\n    const urlArray = convertToList(urls).map((url) => {\n      if (typeof url !== \"string\") {\n        const aliases = this.resolver.getAlias(url);\n        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {\n          this.add(url);\n        }\n        return Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      if (!this.resolver.hasKey(url))\n        this.add({ alias: url, src: url });\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const assets = await Assets.loadBundle('animals');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle('load-screen');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle('game-screen');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === \"string\") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your initial load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.backgroundLoad('bunny.png');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === \"string\") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: 'load-screen',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle('load-screen');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === \"string\") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === \"string\") {\n      return Cache.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache.get(keys[i]);\n    }\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = [...new Set(Object.values(resolveResults))];\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach((resolveResult) => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      keys.forEach((key) => {\n        out[key] = asset;\n      });\n      Cache.set(keys, asset);\n    });\n    return out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n   *\n   * await Assets.unload('http://some.url.com/image.png')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload(['thumper', 'chicko']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = convertToList(urls).map((url) => typeof url !== \"string\" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle({\n   *     'thumper': 'http://some.url.com/thumper.png',\n   * })\n   *\n   * const assets = await Assets.loadBundle('thumper');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle('thumper');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    if (options.preferredFormats) {\n      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];\n    }\n    for (const detection of options.detections) {\n      if (options.skipDetections || await detection.test()) {\n        formats = await detection.add(formats);\n      } else if (!options.skipDetections) {\n        formats = await detection.remove(formats);\n      }\n    }\n    formats = formats.filter((format, index) => formats.indexOf(format) === index);\n    return formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      if (!parser.config)\n        return;\n      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nextensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n  cacheTextureArray,\n  detectDefaults,\n  detectAvif,\n  detectWebp,\n  detectMp4,\n  detectOgv,\n  detectWebm,\n  loadJson,\n  loadTxt,\n  loadWebFont,\n  loadSvg,\n  loadTextures,\n  loadVideoTextures,\n  loadBitmapFont,\n  bitmapFontCachePlugin,\n  resolveTextureUrl,\n  resolveJsonUrl\n);\nconst assetKeyMap = {\n  loader: ExtensionType.LoadParser,\n  resolver: ExtensionType.ResolveParser,\n  cache: ExtensionType.CacheParser,\n  detection: ExtensionType.DetectionParser\n};\nextensions.handle(ExtensionType.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => extensions.add(Object.assign(\n    ref[key],\n    // Allow the function to optionally define it's own\n    // ExtensionMetadata, the use cases here is priority for LoaderParsers\n    { extension: ref[key].extension ?? type }\n  )));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => extensions.remove(ref[key]));\n});\n\nexport { Assets, AssetsClass };\n//# sourceMappingURL=Assets.mjs.map\n","import { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { UPDATE_PRIORITY } from '../../ticker/const.mjs';\nimport { Ticker } from '../../ticker/Ticker.mjs';\nimport { Sprite } from '../sprite/Sprite.mjs';\n\n\"use strict\";\nclass AnimatedSprite extends Sprite {\n  /** @ignore */\n  constructor(...args) {\n    let options = args[0];\n    if (Array.isArray(args[0])) {\n      options = {\n        textures: args[0],\n        autoUpdate: args[1]\n      };\n    }\n    const { textures, autoUpdate, ...rest } = options;\n    const [firstFrame] = textures;\n    super({\n      ...rest,\n      texture: firstFrame instanceof Texture ? firstFrame : firstFrame.texture\n    });\n    this._textures = null;\n    this._durations = null;\n    this._autoUpdate = autoUpdate ?? true;\n    this._isConnectedToTicker = false;\n    this.animationSpeed = 1;\n    this.loop = true;\n    this.updateAnchor = false;\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n    this._currentTime = 0;\n    this._playing = false;\n    this._previousFrame = null;\n    this.textures = textures;\n  }\n  /** Stops the AnimatedSprite. */\n  stop() {\n    if (!this._playing) {\n      return;\n    }\n    this._playing = false;\n    if (this._autoUpdate && this._isConnectedToTicker) {\n      Ticker.shared.remove(this.update, this);\n      this._isConnectedToTicker = false;\n    }\n  }\n  /** Plays the AnimatedSprite. */\n  play() {\n    if (this._playing) {\n      return;\n    }\n    this._playing = true;\n    if (this._autoUpdate && !this._isConnectedToTicker) {\n      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n      this._isConnectedToTicker = true;\n    }\n  }\n  /**\n   * Stops the AnimatedSprite and goes to a specific frame.\n   * @param frameNumber - Frame index to stop at.\n   */\n  gotoAndStop(frameNumber) {\n    this.stop();\n    this.currentFrame = frameNumber;\n  }\n  /**\n   * Goes to a specific frame and begins playing the AnimatedSprite.\n   * @param frameNumber - Frame index to start at.\n   */\n  gotoAndPlay(frameNumber) {\n    this.currentFrame = frameNumber;\n    this.play();\n  }\n  /**\n   * Updates the object transform for rendering.\n   * @param ticker - the ticker to use to update the object.\n   */\n  update(ticker) {\n    if (!this._playing) {\n      return;\n    }\n    const deltaTime = ticker.deltaTime;\n    const elapsed = this.animationSpeed * deltaTime;\n    const previousFrame = this.currentFrame;\n    if (this._durations !== null) {\n      let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n      lag += elapsed / 60 * 1e3;\n      while (lag < 0) {\n        this._currentTime--;\n        lag += this._durations[this.currentFrame];\n      }\n      const sign = Math.sign(this.animationSpeed * deltaTime);\n      this._currentTime = Math.floor(this._currentTime);\n      while (lag >= this._durations[this.currentFrame]) {\n        lag -= this._durations[this.currentFrame] * sign;\n        this._currentTime += sign;\n      }\n      this._currentTime += lag / this._durations[this.currentFrame];\n    } else {\n      this._currentTime += elapsed;\n    }\n    if (this._currentTime < 0 && !this.loop) {\n      this.gotoAndStop(0);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (this._currentTime >= this._textures.length && !this.loop) {\n      this.gotoAndStop(this._textures.length - 1);\n      if (this.onComplete) {\n        this.onComplete();\n      }\n    } else if (previousFrame !== this.currentFrame) {\n      if (this.loop && this.onLoop) {\n        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n          this.onLoop();\n        }\n      }\n      this._updateTexture();\n    }\n  }\n  /** Updates the displayed texture to match the current frame index. */\n  _updateTexture() {\n    const currentFrame = this.currentFrame;\n    if (this._previousFrame === currentFrame) {\n      return;\n    }\n    this._previousFrame = currentFrame;\n    this.texture = this._textures[currentFrame];\n    if (this.updateAnchor) {\n      this.anchor.copyFrom(this.texture.defaultAnchor);\n    }\n    if (this.onFrameChange) {\n      this.onFrameChange(this.currentFrame);\n    }\n  }\n  /** Stops the AnimatedSprite and destroys it. */\n  destroy() {\n    this.stop();\n    super.destroy();\n    this.onComplete = null;\n    this.onFrameChange = null;\n    this.onLoop = null;\n  }\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of frame ids.\n   * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n   * @returns - The new animated sprite with the specified frames.\n   */\n  static fromFrames(frames) {\n    const textures = [];\n    for (let i = 0; i < frames.length; ++i) {\n      textures.push(Texture.from(frames[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  /**\n   * A short hand way of creating an AnimatedSprite from an array of image ids.\n   * @param images - The array of image urls the AnimatedSprite will use as its texture frames.\n   * @returns The new animate sprite with the specified images as frames.\n   */\n  static fromImages(images) {\n    const textures = [];\n    for (let i = 0; i < images.length; ++i) {\n      textures.push(Texture.from(images[i]));\n    }\n    return new AnimatedSprite(textures);\n  }\n  /**\n   * The total number of frames in the AnimatedSprite. This is the same as number of textures\n   * assigned to the AnimatedSprite.\n   * @readonly\n   * @default 0\n   */\n  get totalFrames() {\n    return this._textures.length;\n  }\n  /** The array of textures used for this AnimatedSprite. */\n  get textures() {\n    return this._textures;\n  }\n  set textures(value) {\n    if (value[0] instanceof Texture) {\n      this._textures = value;\n      this._durations = null;\n    } else {\n      this._textures = [];\n      this._durations = [];\n      for (let i = 0; i < value.length; i++) {\n        this._textures.push(value[i].texture);\n        this._durations.push(value[i].time);\n      }\n    }\n    this._previousFrame = null;\n    this.gotoAndStop(0);\n    this._updateTexture();\n  }\n  /** The AnimatedSprite's current frame index. */\n  get currentFrame() {\n    let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n    if (currentFrame < 0) {\n      currentFrame += this._textures.length;\n    }\n    return currentFrame;\n  }\n  set currentFrame(value) {\n    if (value < 0 || value > this.totalFrames - 1) {\n      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);\n    }\n    const previousFrame = this.currentFrame;\n    this._currentTime = value;\n    if (previousFrame !== this.currentFrame) {\n      this._updateTexture();\n    }\n  }\n  /**\n   * Indicates if the AnimatedSprite is currently playing.\n   * @readonly\n   */\n  get playing() {\n    return this._playing;\n  }\n  /** Whether to use Ticker.shared to auto update animation time. */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      if (!this._autoUpdate && this._isConnectedToTicker) {\n        Ticker.shared.remove(this.update, this);\n        this._isConnectedToTicker = false;\n      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n        Ticker.shared.add(this.update, this);\n        this._isConnectedToTicker = true;\n      }\n    }\n  }\n}\n\nexport { AnimatedSprite };\n//# sourceMappingURL=AnimatedSprite.mjs.map\n","import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../view/ViewContainer.mjs';\n\n\"use strict\";\nclass AbstractText extends ViewContainer {\n  constructor(options, styleClass) {\n    const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n    super({\n      ...rest\n    });\n    this.batched = true;\n    this._resolution = null;\n    this._autoResolution = true;\n    this._didTextUpdate = true;\n    this._styleClass = styleClass;\n    this.text = text ?? \"\";\n    this.style = style;\n    this.resolution = resolution ?? null;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint(\n      {\n        _onUpdate: () => {\n          this.onViewUpdate();\n        }\n      }\n    );\n    if (anchor)\n      this.anchor = anchor;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0)\n      this.width = width;\n    if (height !== void 0)\n      this.height = height;\n  }\n  /**\n   * The anchor sets the origin point of the text.\n   * The default is `(0,0)`, this means the text's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Text } from 'pixi.js';\n   *\n   * const text = new Text('hello world');\n   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** Set the copy for the text object. To split a line you can use '\\n'. */\n  set text(value) {\n    value = value.toString();\n    if (this._text === value)\n      return;\n    this._text = value;\n    this.onViewUpdate();\n  }\n  get text() {\n    return this._text;\n  }\n  /**\n   * The resolution / device pixel ratio of the canvas.\n   * @default 1\n   */\n  set resolution(value) {\n    this._autoResolution = value === null;\n    this._resolution = value;\n    this.onViewUpdate();\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  get style() {\n    return this._style;\n  }\n  /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n   * @type {\n   * text.TextStyle |\n   * Partial<text.TextStyle> |\n   * text.TextStyleOptions |\n   * text.HTMLTextStyle |\n   * Partial<text.HTMLTextStyle> |\n   * text.HTMLTextStyleOptions\n   * }\n   */\n  set style(style) {\n    style || (style = {});\n    this._style?.off(\"update\", this.onViewUpdate, this);\n    if (style instanceof this._styleClass) {\n      this._style = style;\n    } else {\n      this._style = new this._styleClass(style);\n    }\n    this._style.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this.bounds.width;\n  }\n  set width(value) {\n    this._setWidth(value, this.bounds.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this.bounds.height;\n  }\n  set height(value) {\n    this._setHeight(value, this.bounds.height);\n  }\n  /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Text.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this.bounds.width;\n    out.height = Math.abs(this.scale.y) * this.bounds.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this.bounds.width);\n    height !== void 0 && this._setHeight(height, this.bounds.height);\n  }\n  /**\n   * Checks if the text contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const width = this.bounds.width;\n    const height = this.bounds.height;\n    const x1 = -width * this.anchor.x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (point.y >= y1 && point.y <= y1 + height)\n        return true;\n    }\n    return false;\n  }\n  onViewUpdate() {\n    if (!this.didViewUpdate)\n      this._didTextUpdate = true;\n    super.onViewUpdate();\n  }\n  _getKey() {\n    return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n  }\n  /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n   * @param {boolean} [options.style=false] - Should it destroy the style of the text\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this.owner = null;\n    this._bounds = null;\n    this._anchor = null;\n    if (typeof options === \"boolean\" ? options : options?.style) {\n      this._style.destroy(options);\n    }\n    this._style = null;\n    this._text = null;\n  }\n}\nfunction ensureOptions(args, name) {\n  let options = args[0] ?? {};\n  if (typeof options === \"string\" || args[1]) {\n    deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n    options = {\n      text: options,\n      style: args[1]\n    };\n  }\n  return options;\n}\n\nexport { AbstractText, ensureOptions };\n//# sourceMappingURL=AbstractText.mjs.map\n","import { AbstractText, ensureOptions } from './AbstractText.mjs';\nimport { CanvasTextMetrics } from './canvas/CanvasTextMetrics.mjs';\nimport { TextStyle } from './TextStyle.mjs';\n\n\"use strict\";\nclass Text extends AbstractText {\n  constructor(...args) {\n    const options = ensureOptions(args, \"Text\");\n    super(options, TextStyle);\n    this.renderPipeId = \"text\";\n  }\n  /** @private */\n  updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const canvasMeasurement = CanvasTextMetrics.measureText(\n      this._text,\n      this._style\n    );\n    const { width, height } = canvasMeasurement;\n    bounds.minX = -anchor._x * width;\n    bounds.maxX = bounds.minX + width;\n    bounds.minY = -anchor._y * height;\n    bounds.maxY = bounds.minY + height;\n  }\n}\n\nexport { Text };\n//# sourceMappingURL=Text.mjs.map\n","import { browserExt } from './environment-browser/browserExt.mjs';\nimport { webworkerExt } from './environment-webworker/webworkerExt.mjs';\nimport { extensions } from './extensions/Extensions.mjs';\nexport { ExtensionType, normalizeExtensionPriority } from './extensions/Extensions.mjs';\nimport './rendering/init.mjs';\nimport './spritesheet/init.mjs';\nimport './accessibility/index.mjs';\nimport './advanced-blend-modes/index.mjs';\nimport './app/index.mjs';\nimport './assets/index.mjs';\nimport './color/index.mjs';\nimport './compressed-textures/index.mjs';\nimport './culling/index.mjs';\nimport './environment/index.mjs';\nimport './environment-browser/index.mjs';\nimport './environment-webworker/index.mjs';\nimport './events/index.mjs';\nimport './extensions/index.mjs';\nimport './filters/index.mjs';\nimport './maths/index.mjs';\nimport './prepare/index.mjs';\nimport './rendering/index.mjs';\nimport './scene/index.mjs';\nimport './spritesheet/index.mjs';\nimport './ticker/index.mjs';\nimport './utils/index.mjs';\nexport { AccessibilitySystem } from './accessibility/AccessibilitySystem.mjs';\nexport { accessibilityTarget } from './accessibility/accessibilityTarget.mjs';\nexport { ColorBlend } from './advanced-blend-modes/ColorBlend.mjs';\nexport { ColorBurnBlend } from './advanced-blend-modes/ColorBurnBlend.mjs';\nexport { ColorDodgeBlend } from './advanced-blend-modes/ColorDodgeBlend.mjs';\nexport { DarkenBlend } from './advanced-blend-modes/DarkenBlend.mjs';\nexport { DifferenceBlend } from './advanced-blend-modes/DifferenceBlend.mjs';\nexport { DivideBlend } from './advanced-blend-modes/DivideBlend.mjs';\nexport { ExclusionBlend } from './advanced-blend-modes/ExclusionBlend.mjs';\nexport { HardLightBlend } from './advanced-blend-modes/HardLightBlend.mjs';\nexport { HardMixBlend } from './advanced-blend-modes/HardMixBlend.mjs';\nexport { LightenBlend } from './advanced-blend-modes/LightenBlend.mjs';\nexport { LinearBurnBlend } from './advanced-blend-modes/LinearBurnBlend.mjs';\nexport { LinearDodgeBlend } from './advanced-blend-modes/LinearDodgeBlend.mjs';\nexport { LinearLightBlend } from './advanced-blend-modes/LinearLightBlend.mjs';\nexport { LuminosityBlend } from './advanced-blend-modes/LuminosityBlend.mjs';\nexport { NegationBlend } from './advanced-blend-modes/NegationBlend.mjs';\nexport { OverlayBlend } from './advanced-blend-modes/OverlayBlend.mjs';\nexport { PinLightBlend } from './advanced-blend-modes/PinLightBlend.mjs';\nexport { SaturationBlend } from './advanced-blend-modes/SaturationBlend.mjs';\nexport { SoftLightBlend } from './advanced-blend-modes/SoftLightBlend.mjs';\nexport { SubtractBlend } from './advanced-blend-modes/SubtractBlend.mjs';\nexport { VividLightBlend } from './advanced-blend-modes/VividLightBlend.mjs';\nexport { Application } from './app/Application.mjs';\nexport { ResizePlugin } from './app/ResizePlugin.mjs';\nexport { TickerPlugin } from './app/TickerPlugin.mjs';\nexport { Assets, AssetsClass } from './assets/Assets.mjs';\nexport { BackgroundLoader } from './assets/BackgroundLoader.mjs';\nexport { Cache } from './assets/cache/Cache.mjs';\nexport { cacheTextureArray } from './assets/cache/parsers/cacheTextureArray.mjs';\nexport { detectAvif } from './assets/detections/parsers/detectAvif.mjs';\nexport { detectDefaults } from './assets/detections/parsers/detectDefaults.mjs';\nexport { detectMp4 } from './assets/detections/parsers/detectMp4.mjs';\nexport { detectOgv } from './assets/detections/parsers/detectOgv.mjs';\nexport { detectWebm } from './assets/detections/parsers/detectWebm.mjs';\nexport { detectWebp } from './assets/detections/parsers/detectWebp.mjs';\nexport { testImageFormat } from './assets/detections/utils/testImageFormat.mjs';\nexport { testVideoFormat } from './assets/detections/utils/testVideoFormat.mjs';\nexport { Loader } from './assets/loader/Loader.mjs';\nexport { LoaderParserPriority } from './assets/loader/parsers/LoaderParser.mjs';\nexport { loadJson } from './assets/loader/parsers/loadJson.mjs';\nexport { loadTxt } from './assets/loader/parsers/loadTxt.mjs';\nexport { getFontFamilyName, loadWebFont } from './assets/loader/parsers/loadWebFont.mjs';\nexport { loadSvg } from './assets/loader/parsers/textures/loadSVG.mjs';\nexport { loadImageBitmap, loadTextures } from './assets/loader/parsers/textures/loadTextures.mjs';\nexport { crossOrigin, determineCrossOrigin, loadVideoTextures, preloadVideo } from './assets/loader/parsers/textures/loadVideoTextures.mjs';\nexport { createTexture } from './assets/loader/parsers/textures/utils/createTexture.mjs';\nexport { WorkerManager } from './assets/loader/workers/WorkerManager.mjs';\nexport { resolveJsonUrl } from './assets/resolver/parsers/resolveJsonUrl.mjs';\nexport { resolveTextureUrl } from './assets/resolver/parsers/resolveTextureUrl.mjs';\nexport { Resolver, getUrlExtension } from './assets/resolver/Resolver.mjs';\nexport { checkDataUrl } from './assets/utils/checkDataUrl.mjs';\nexport { checkExtension } from './assets/utils/checkExtension.mjs';\nexport { convertToList } from './assets/utils/convertToList.mjs';\nexport { copySearchParams } from './assets/utils/copySearchParams.mjs';\nexport { createStringVariations } from './assets/utils/createStringVariations.mjs';\nexport { isSingleItem } from './assets/utils/isSingleItem.mjs';\nexport { Color } from './color/Color.mjs';\nexport { detectBasis } from './compressed-textures/basis/detectBasis.mjs';\nexport { loadBasis } from './compressed-textures/basis/loadBasis.mjs';\nexport { createLevelBuffers } from './compressed-textures/basis/utils/createLevelBuffers.mjs';\nexport { gpuFormatToBasisTranscoderFormat } from './compressed-textures/basis/utils/gpuFormatToBasisTranscoderFormat.mjs';\nexport { basisTranscoderUrls, setBasisTranscoderPath } from './compressed-textures/basis/utils/setBasisTranscoderPath.mjs';\nexport { loadBasisOnWorker } from './compressed-textures/basis/worker/loadBasisOnWorker.mjs';\nexport { D3D10_RESOURCE_DIMENSION, D3DFMT, DDS, DXGI_FORMAT, DXGI_TO_TEXTURE_FORMAT, FOURCC_TO_TEXTURE_FORMAT, TEXTURE_FORMAT_BLOCK_SIZE } from './compressed-textures/dds/const.mjs';\nexport { loadDDS } from './compressed-textures/dds/loadDDS.mjs';\nexport { parseDDS } from './compressed-textures/dds/parseDDS.mjs';\nexport { loadKTX } from './compressed-textures/ktx/loadKTX.mjs';\nexport { parseKTX } from './compressed-textures/ktx/parseKTX.mjs';\nexport { GL_INTERNAL_FORMAT, KTX } from './compressed-textures/ktx2/const.mjs';\nexport { loadKTX2 } from './compressed-textures/ktx2/loadKTX2.mjs';\nexport { convertFormatIfRequired } from './compressed-textures/ktx2/utils/convertFormatIfRequired.mjs';\nexport { createLevelBuffersFromKTX } from './compressed-textures/ktx2/utils/createLevelBuffersFromKTX.mjs';\nexport { getTextureFormatFromKTXTexture } from './compressed-textures/ktx2/utils/getTextureFormatFromKTXTexture.mjs';\nexport { glFormatToGPUFormat } from './compressed-textures/ktx2/utils/glFormatToGPUFormat.mjs';\nexport { gpuFormatToKTXBasisTranscoderFormat } from './compressed-textures/ktx2/utils/gpuFormatToKTXBasisTranscoderFormat.mjs';\nexport { ktxTranscoderUrls, setKTXTranscoderPath } from './compressed-textures/ktx2/utils/setKTXTranscoderPath.mjs';\nexport { vkFormatToGPUFormat } from './compressed-textures/ktx2/utils/vkFormatToGPUFormat.mjs';\nexport { loadKTX2onWorker } from './compressed-textures/ktx2/worker/loadKTX2onWorker.mjs';\nexport { detectCompressed } from './compressed-textures/shared/detectCompressed.mjs';\nexport { resolveCompressedTextureUrl, validFormats } from './compressed-textures/shared/resolveCompressedTextureUrl.mjs';\nexport { Culler } from './culling/Culler.mjs';\nexport { CullerPlugin } from './culling/CullerPlugin.mjs';\nexport { cullingMixin } from './culling/cullingMixin.mjs';\nexport { DOMAdapter } from './environment/adapter.mjs';\nexport { autoDetectEnvironment, loadEnvironmentExtensions } from './environment/autoDetectEnvironment.mjs';\nexport { BrowserAdapter } from './environment-browser/BrowserAdapter.mjs';\nexport { WebWorkerAdapter } from './environment-webworker/WebWorkerAdapter.mjs';\nexport { EventBoundary } from './events/EventBoundary.mjs';\nexport { EventSystem } from './events/EventSystem.mjs';\nexport { EventsTicker } from './events/EventTicker.mjs';\nexport { FederatedEvent } from './events/FederatedEvent.mjs';\nexport { FederatedContainer } from './events/FederatedEventTarget.mjs';\nexport { FederatedMouseEvent } from './events/FederatedMouseEvent.mjs';\nexport { FederatedPointerEvent } from './events/FederatedPointerEvent.mjs';\nexport { FederatedWheelEvent } from './events/FederatedWheelEvent.mjs';\nexport { default as blendTemplateFrag } from './filters/blend-modes/blend-template.frag.mjs';\nexport { default as blendTemplateVert } from './filters/blend-modes/blend-template.vert.mjs';\nexport { default as blendTemplateWgsl } from './filters/blend-modes/blend-template.wgsl.mjs';\nexport { default as hslWgsl } from './filters/blend-modes/hsl.wgsl.mjs';\nexport { default as alphaFrag } from './filters/defaults/alpha/alpha.frag.mjs';\nexport { default as alphaWgsl } from './filters/defaults/alpha/alpha.wgsl.mjs';\nexport { default as blurTemplateWgsl } from './filters/defaults/blur/gpu/blur-template.wgsl.mjs';\nexport { default as colorMatrixFilterFrag } from './filters/defaults/color-matrix/colorMatrixFilter.frag.mjs';\nexport { default as colorMatrixFilterWgsl } from './filters/defaults/color-matrix/colorMatrixFilter.wgsl.mjs';\nexport { default as defaultFilterVert } from './filters/defaults/defaultFilter.vert.mjs';\nexport { default as displacementFrag } from './filters/defaults/displacement/displacement.frag.mjs';\nexport { default as displacementVert } from './filters/defaults/displacement/displacement.vert.mjs';\nexport { default as displacementWgsl } from './filters/defaults/displacement/displacement.wgsl.mjs';\nexport { default as noiseFrag } from './filters/defaults/noise/noise.frag.mjs';\nexport { default as noiseWgsl } from './filters/defaults/noise/noise.wgsl.mjs';\nexport { default as maskFrag } from './filters/mask/mask.frag.mjs';\nexport { default as maskVert } from './filters/mask/mask.vert.mjs';\nexport { default as maskWgsl } from './filters/mask/mask.wgsl.mjs';\nexport { BlendModeFilter } from './filters/blend-modes/BlendModeFilter.mjs';\nexport { hslgl } from './filters/blend-modes/hls/GLhls.mjs';\nexport { hslgpu } from './filters/blend-modes/hls/GPUhls.mjs';\nexport { AlphaFilter } from './filters/defaults/alpha/AlphaFilter.mjs';\nexport { BlurFilter } from './filters/defaults/blur/BlurFilter.mjs';\nexport { BlurFilterPass } from './filters/defaults/blur/BlurFilterPass.mjs';\nexport { GAUSSIAN_VALUES } from './filters/defaults/blur/const.mjs';\nexport { generateBlurFragSource } from './filters/defaults/blur/gl/generateBlurFragSource.mjs';\nexport { generateBlurGlProgram } from './filters/defaults/blur/gl/generateBlurGlProgram.mjs';\nexport { generateBlurVertSource } from './filters/defaults/blur/gl/generateBlurVertSource.mjs';\nexport { generateBlurProgram } from './filters/defaults/blur/gpu/generateBlurProgram.mjs';\nexport { ColorMatrixFilter } from './filters/defaults/color-matrix/ColorMatrixFilter.mjs';\nexport { DisplacementFilter } from './filters/defaults/displacement/DisplacementFilter.mjs';\nexport { NoiseFilter } from './filters/defaults/noise/NoiseFilter.mjs';\nexport { Filter } from './filters/Filter.mjs';\nexport { FilterEffect } from './filters/FilterEffect.mjs';\nexport { FilterPipe } from './filters/FilterPipe.mjs';\nexport { FilterSystem } from './filters/FilterSystem.mjs';\nexport { MaskFilter } from './filters/mask/MaskFilter.mjs';\nexport { groupD8 } from './maths/matrix/groupD8.mjs';\nexport { Matrix } from './maths/matrix/Matrix.mjs';\nexport { DEG_TO_RAD, PI_2, RAD_TO_DEG } from './maths/misc/const.mjs';\nexport { isPow2, log2, nextPow2 } from './maths/misc/pow2.mjs';\nexport { squaredDistanceToLineSegment } from './maths/misc/squaredDistanceToLineSegment.mjs';\nexport { ObservablePoint } from './maths/point/ObservablePoint.mjs';\nexport { Point } from './maths/point/Point.mjs';\nexport { pointInTriangle } from './maths/point/pointInTriangle.mjs';\nexport { Circle } from './maths/shapes/Circle.mjs';\nexport { Ellipse } from './maths/shapes/Ellipse.mjs';\nexport { Polygon } from './maths/shapes/Polygon.mjs';\nexport { Rectangle } from './maths/shapes/Rectangle.mjs';\nexport { RoundedRectangle } from './maths/shapes/RoundedRectangle.mjs';\nexport { Triangle } from './maths/shapes/Triangle.mjs';\nexport { PrepareBase } from './prepare/PrepareBase.mjs';\nexport { PrepareQueue } from './prepare/PrepareQueue.mjs';\nexport { PrepareSystem } from './prepare/PrepareSystem.mjs';\nexport { PrepareUpload } from './prepare/PrepareUpload.mjs';\nexport { GlBatchAdaptor } from './rendering/batcher/gl/GlBatchAdaptor.mjs';\nexport { checkMaxIfStatementsInShader } from './rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs';\nexport { getMaxTexturesPerBatch } from './rendering/batcher/gl/utils/maxRecommendedTextures.mjs';\nexport { generateGPULayout } from './rendering/batcher/gpu/generateGPULayout.mjs';\nexport { generateLayout } from './rendering/batcher/gpu/generateLayout.mjs';\nexport { getTextureBatchBindGroup } from './rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nexport { GpuBatchAdaptor } from './rendering/batcher/gpu/GpuBatchAdaptor.mjs';\nexport { Batch, Batcher } from './rendering/batcher/shared/Batcher.mjs';\nexport { BatcherPipe } from './rendering/batcher/shared/BatcherPipe.mjs';\nexport { BatchGeometry } from './rendering/batcher/shared/BatchGeometry.mjs';\nexport { BatchTextureArray } from './rendering/batcher/shared/BatchTextureArray.mjs';\nexport { DefaultBatcher } from './rendering/batcher/shared/DefaultBatcher.mjs';\nexport { DefaultShader } from './rendering/batcher/shared/DefaultShader.mjs';\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram } from './rendering/high-shader/compileHighShaderToProgram.mjs';\nexport { compileHighShader, compileHighShaderGl } from './rendering/high-shader/compiler/compileHighShader.mjs';\nexport { addBits } from './rendering/high-shader/compiler/utils/addBits.mjs';\nexport { compileHooks, findHooksRx } from './rendering/high-shader/compiler/utils/compileHooks.mjs';\nexport { compileInputs } from './rendering/high-shader/compiler/utils/compileInputs.mjs';\nexport { compileOutputs } from './rendering/high-shader/compiler/utils/compileOutputs.mjs';\nexport { formatShader } from './rendering/high-shader/compiler/utils/formatShader.mjs';\nexport { injectBits } from './rendering/high-shader/compiler/utils/injectBits.mjs';\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate } from './rendering/high-shader/defaultProgramTemplate.mjs';\nexport { colorBit, colorBitGl } from './rendering/high-shader/shader-bits/colorBit.mjs';\nexport { generateTextureBatchBit, generateTextureBatchBitGl } from './rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl } from './rendering/high-shader/shader-bits/globalUniformsBit.mjs';\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 } from './rendering/high-shader/shader-bits/localUniformBit.mjs';\nexport { roundPixelsBit, roundPixelsBitGl } from './rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nexport { textureBit, textureBitGl } from './rendering/high-shader/shader-bits/textureBit.mjs';\nexport { AlphaMask } from './rendering/mask/alpha/AlphaMask.mjs';\nexport { AlphaMaskPipe } from './rendering/mask/alpha/AlphaMaskPipe.mjs';\nexport { ColorMask } from './rendering/mask/color/ColorMask.mjs';\nexport { ColorMaskPipe } from './rendering/mask/color/ColorMaskPipe.mjs';\nexport { MaskEffectManager, MaskEffectManagerClass } from './rendering/mask/MaskEffectManager.mjs';\nexport { ScissorMask } from './rendering/mask/scissor/ScissorMask.mjs';\nexport { StencilMask } from './rendering/mask/stencil/StencilMask.mjs';\nexport { StencilMaskPipe } from './rendering/mask/stencil/StencilMaskPipe.mjs';\nexport { addMaskBounds } from './rendering/mask/utils/addMaskBounds.mjs';\nexport { addMaskLocalBounds, getMatrixRelativeToParent } from './rendering/mask/utils/addMaskLocalBounds.mjs';\nexport { autoDetectRenderer } from './rendering/renderers/autoDetectRenderer.mjs';\nexport { BUFFER_TYPE } from './rendering/renderers/gl/buffer/const.mjs';\nexport { GlBuffer } from './rendering/renderers/gl/buffer/GlBuffer.mjs';\nexport { GlBufferSystem } from './rendering/renderers/gl/buffer/GlBufferSystem.mjs';\nexport { CLEAR } from './rendering/renderers/gl/const.mjs';\nexport { GlContextSystem } from './rendering/renderers/gl/context/GlContextSystem.mjs';\nexport { GlGeometrySystem } from './rendering/renderers/gl/geometry/GlGeometrySystem.mjs';\nexport { getGlTypeFromFormat } from './rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs';\nexport { GlBackBufferSystem } from './rendering/renderers/gl/GlBackBufferSystem.mjs';\nexport { GlColorMaskSystem } from './rendering/renderers/gl/GlColorMaskSystem.mjs';\nexport { GlEncoderSystem } from './rendering/renderers/gl/GlEncoderSystem.mjs';\nexport { GlRenderTarget } from './rendering/renderers/gl/GlRenderTarget.mjs';\nexport { GlStencilSystem } from './rendering/renderers/gl/GlStencilSystem.mjs';\nexport { GlUboSystem } from './rendering/renderers/gl/GlUboSystem.mjs';\nexport { GlRenderTargetAdaptor } from './rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs';\nexport { GlRenderTargetSystem } from './rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs';\nexport { generateShaderSyncCode } from './rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs';\nexport { getBatchSamplersUniformGroup } from './rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nexport { GlProgram } from './rendering/renderers/gl/shader/GlProgram.mjs';\nexport { GlProgramData, IGLUniformData } from './rendering/renderers/gl/shader/GlProgramData.mjs';\nexport { GlShaderSystem } from './rendering/renderers/gl/shader/GlShaderSystem.mjs';\nexport { GlUniformGroupSystem } from './rendering/renderers/gl/shader/GlUniformGroupSystem.mjs';\nexport { migrateFragmentFromV7toV8 } from './rendering/renderers/gl/shader/migrateFragmentFromV7toV8.mjs';\nexport { compileShader } from './rendering/renderers/gl/shader/program/compileShader.mjs';\nexport { defaultValue } from './rendering/renderers/gl/shader/program/defaultValue.mjs';\nexport { ensureAttributes } from './rendering/renderers/gl/shader/program/ensureAttributes.mjs';\nexport { extractAttributesFromGlProgram } from './rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs';\nexport { generateProgram } from './rendering/renderers/gl/shader/program/generateProgram.mjs';\nexport { getMaxFragmentPrecision } from './rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs';\nexport { getTestContext } from './rendering/renderers/gl/shader/program/getTestContext.mjs';\nexport { getUboData } from './rendering/renderers/gl/shader/program/getUboData.mjs';\nexport { getUniformData } from './rendering/renderers/gl/shader/program/getUniformData.mjs';\nexport { logProgramError } from './rendering/renderers/gl/shader/program/logProgramError.mjs';\nexport { mapSize } from './rendering/renderers/gl/shader/program/mapSize.mjs';\nexport { mapGlToVertexFormat, mapType } from './rendering/renderers/gl/shader/program/mapType.mjs';\nexport { addProgramDefines } from './rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs';\nexport { ensurePrecision } from './rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs';\nexport { insertVersion } from './rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs';\nexport { setProgramName } from './rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs';\nexport { stripVersion } from './rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs';\nexport { WGSL_TO_STD40_SIZE, createUboElementsSTD40 } from './rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs';\nexport { createUboSyncFunctionSTD40 } from './rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs';\nexport { generateArraySyncSTD40 } from './rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs';\nexport { generateUniformsSync } from './rendering/renderers/gl/shader/utils/generateUniformsSync.mjs';\nexport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs';\nexport { GlStateSystem } from './rendering/renderers/gl/state/GlStateSystem.mjs';\nexport { mapWebGLBlendModesToPixi } from './rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs';\nexport { GL_FORMATS, GL_TARGETS, GL_TYPES, GL_WRAP_MODES } from './rendering/renderers/gl/texture/const.mjs';\nexport { GlTexture } from './rendering/renderers/gl/texture/GlTexture.mjs';\nexport { GlTextureSystem } from './rendering/renderers/gl/texture/GlTextureSystem.mjs';\nexport { glUploadBufferImageResource } from './rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs';\nexport { glUploadCompressedTextureResource } from './rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs';\nexport { glUploadImageResource } from './rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs';\nexport { glUploadVideoResource } from './rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs';\nexport { applyStyleParams } from './rendering/renderers/gl/texture/utils/applyStyleParams.mjs';\nexport { getSupportedGlCompressedTextureFormats } from './rendering/renderers/gl/texture/utils/getSupportedGlCompressedTextureFormats.mjs';\nexport { mapFormatToGlFormat } from './rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs';\nexport { mapFormatToGlInternalFormat } from './rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs';\nexport { mapFormatToGlType } from './rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs';\nexport { compareModeToGlCompare, mipmapScaleModeToGlFilter, scaleModeToGlFilter, wrapModeToGlAddress } from './rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs';\nexport { unpremultiplyAlpha } from './rendering/renderers/gl/texture/utils/unpremultiplyAlpha.mjs';\nexport { WebGLRenderer } from './rendering/renderers/gl/WebGLRenderer.mjs';\nexport { BindGroupSystem } from './rendering/renderers/gpu/BindGroupSystem.mjs';\nexport { GpuBufferSystem } from './rendering/renderers/gpu/buffer/GpuBufferSystem.mjs';\nexport { GpuReadBuffer } from './rendering/renderers/gpu/buffer/GpuReadBuffer.mjs';\nexport { UboBatch } from './rendering/renderers/gpu/buffer/UboBatch.mjs';\nexport { GpuColorMaskSystem } from './rendering/renderers/gpu/GpuColorMaskSystem.mjs';\nexport { GpuDeviceSystem } from './rendering/renderers/gpu/GpuDeviceSystem.mjs';\nexport { GpuEncoderSystem } from './rendering/renderers/gpu/GpuEncoderSystem.mjs';\nexport { GpuStencilSystem } from './rendering/renderers/gpu/GpuStencilSystem.mjs';\nexport { GpuUboSystem } from './rendering/renderers/gpu/GpuUboSystem.mjs';\nexport { GpuUniformBatchPipe } from './rendering/renderers/gpu/GpuUniformBatchPipe.mjs';\nexport { PipelineSystem } from './rendering/renderers/gpu/pipeline/PipelineSystem.mjs';\nexport { calculateProjection } from './rendering/renderers/gpu/renderTarget/calculateProjection.mjs';\nexport { GpuRenderTarget } from './rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs';\nexport { GpuRenderTargetAdaptor } from './rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs';\nexport { GpuRenderTargetSystem } from './rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs';\nexport { BindGroup } from './rendering/renderers/gpu/shader/BindGroup.mjs';\nexport { GpuProgram } from './rendering/renderers/gpu/shader/GpuProgram.mjs';\nexport { GpuShaderSystem } from './rendering/renderers/gpu/shader/GpuShaderSystem.mjs';\nexport { WGSL_ALIGN_SIZE_DATA, createUboElementsWGSL } from './rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs';\nexport { createUboSyncFunctionWGSL } from './rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs';\nexport { extractAttributesFromGpuProgram } from './rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs';\nexport { extractStructAndGroups } from './rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs';\nexport { generateArraySyncWGSL } from './rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs';\nexport { generateGpuLayoutGroups } from './rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs';\nexport { generateLayoutHash } from './rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs';\nexport { removeStructAndGroupDuplicates } from './rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs';\nexport { GpuBlendModesToPixi } from './rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs';\nexport { GpuStateSystem } from './rendering/renderers/gpu/state/GpuStateSystem.mjs';\nexport { GpuStencilModesToPixi } from './rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs';\nexport { GpuTextureSystem } from './rendering/renderers/gpu/texture/GpuTextureSystem.mjs';\nexport { gpuUploadBufferImageResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs';\nexport { blockDataMap, gpuUploadCompressedTextureResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs';\nexport { gpuUploadImageResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs';\nexport { gpuUploadVideoResource } from './rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs';\nexport { getSupportedGPUCompressedTextureFormats } from './rendering/renderers/gpu/texture/utils/getSupportedGPUCompressedTextureFormats.mjs';\nexport { GpuMipmapGenerator } from './rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs';\nexport { WebGPURenderer } from './rendering/renderers/gpu/WebGPURenderer.mjs';\nexport { BackgroundSystem } from './rendering/renderers/shared/background/BackgroundSystem.mjs';\nexport { BlendModePipe } from './rendering/renderers/shared/blendModes/BlendModePipe.mjs';\nexport { Buffer } from './rendering/renderers/shared/buffer/Buffer.mjs';\nexport { BufferResource } from './rendering/renderers/shared/buffer/BufferResource.mjs';\nexport { BufferUsage } from './rendering/renderers/shared/buffer/const.mjs';\nexport { fastCopy } from './rendering/renderers/shared/buffer/utils/fastCopy.mjs';\nexport { ExtractSystem } from './rendering/renderers/shared/extract/ExtractSystem.mjs';\nexport { GenerateTextureSystem } from './rendering/renderers/shared/extract/GenerateTextureSystem.mjs';\nexport { DRAW_MODES } from './rendering/renderers/shared/geometry/const.mjs';\nexport { Geometry } from './rendering/renderers/shared/geometry/Geometry.mjs';\nexport { buildSimpleUvs, buildUvs } from './rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nexport { ensureIsBuffer } from './rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs';\nexport { getAttributeInfoFromFormat } from './rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nexport { getGeometryBounds } from './rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs';\nexport { transformVertices } from './rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nexport { InstructionSet } from './rendering/renderers/shared/instructions/InstructionSet.mjs';\nexport { GlobalUniformSystem } from './rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs';\nexport { isRenderingToScreen } from './rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs';\nexport { RenderTarget } from './rendering/renderers/shared/renderTarget/RenderTarget.mjs';\nexport { RenderTargetSystem } from './rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs';\nexport { viewportFromFrame } from './rendering/renderers/shared/renderTarget/viewportFromFrame.mjs';\nexport { SchedulerSystem } from './rendering/renderers/shared/SchedulerSystem.mjs';\nexport { ShaderStage } from './rendering/renderers/shared/shader/const.mjs';\nexport { Shader } from './rendering/renderers/shared/shader/Shader.mjs';\nexport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES } from './rendering/renderers/shared/shader/types.mjs';\nexport { UboSystem } from './rendering/renderers/shared/shader/UboSystem.mjs';\nexport { UniformGroup } from './rendering/renderers/shared/shader/UniformGroup.mjs';\nexport { createUboSyncFunction } from './rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs';\nexport { getDefaultUniformValue } from './rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs';\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL } from './rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs';\nexport { uniformParsers } from './rendering/renderers/shared/shader/utils/uniformParsers.mjs';\nexport { HelloSystem } from './rendering/renderers/shared/startup/HelloSystem.mjs';\nexport { BLEND_TO_NPM, STENCIL_MODES } from './rendering/renderers/shared/state/const.mjs';\nexport { getAdjustedBlendModeBlend } from './rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nexport { State } from './rendering/renderers/shared/state/State.mjs';\nexport { AbstractRenderer } from './rendering/renderers/shared/system/AbstractRenderer.mjs';\nexport { SharedRenderPipes, SharedSystems } from './rendering/renderers/shared/system/SharedSystems.mjs';\nexport { SystemRunner } from './rendering/renderers/shared/system/SystemRunner.mjs';\nexport { CanvasPool, CanvasPoolClass } from './rendering/renderers/shared/texture/CanvasPool.mjs';\nexport { DEPRECATED_SCALE_MODES, DEPRECATED_WRAP_MODES, MSAA_QUALITY, SCALE_MODES, WRAP_MODES } from './rendering/renderers/shared/texture/const.mjs';\nexport { RenderableGCSystem } from './rendering/renderers/shared/texture/RenderableGCSystem.mjs';\nexport { RenderTexture } from './rendering/renderers/shared/texture/RenderTexture.mjs';\nexport { BufferImageSource } from './rendering/renderers/shared/texture/sources/BufferImageSource.mjs';\nexport { CanvasSource } from './rendering/renderers/shared/texture/sources/CanvasSource.mjs';\nexport { CompressedSource } from './rendering/renderers/shared/texture/sources/CompressedSource.mjs';\nexport { ImageSource } from './rendering/renderers/shared/texture/sources/ImageSource.mjs';\nexport { TextureSource } from './rendering/renderers/shared/texture/sources/TextureSource.mjs';\nexport { VideoSource } from './rendering/renderers/shared/texture/sources/VideoSource.mjs';\nexport { Texture } from './rendering/renderers/shared/texture/Texture.mjs';\nexport { TextureGCSystem } from './rendering/renderers/shared/texture/TextureGCSystem.mjs';\nexport { TextureMatrix } from './rendering/renderers/shared/texture/TextureMatrix.mjs';\nexport { TexturePool, TexturePoolClass } from './rendering/renderers/shared/texture/TexturePool.mjs';\nexport { TextureStyle } from './rendering/renderers/shared/texture/TextureStyle.mjs';\nexport { TextureUvs } from './rendering/renderers/shared/texture/TextureUvs.mjs';\nexport { generateUID } from './rendering/renderers/shared/texture/utils/generateUID.mjs';\nexport { getCanvasTexture, hasCachedCanvasTexture } from './rendering/renderers/shared/texture/utils/getCanvasTexture.mjs';\nexport { getSupportedCompressedTextureFormats } from './rendering/renderers/shared/texture/utils/getSupportedCompressedTextureFormats.mjs';\nexport { getSupportedTextureFormats, nonCompressedFormats } from './rendering/renderers/shared/texture/utils/getSupportedTextureFormats.mjs';\nexport { autoDetectSource, resourceToTexture, textureFrom } from './rendering/renderers/shared/texture/utils/textureFrom.mjs';\nexport { createIdFromString } from './rendering/renderers/shared/utils/createIdFromString.mjs';\nexport { parseFunctionBody } from './rendering/renderers/shared/utils/parseFunctionBody.mjs';\nexport { ViewSystem } from './rendering/renderers/shared/view/ViewSystem.mjs';\nexport { RendererType } from './rendering/renderers/types.mjs';\nexport { default as particlesFrag } from './scene/particle-container/shared/shader/particles.frag.mjs';\nexport { default as particlesVert } from './scene/particle-container/shared/shader/particles.vert.mjs';\nexport { default as particlesWgsl } from './scene/particle-container/shared/shader/particles.wgsl.mjs';\nexport { Bounds } from './scene/container/bounds/Bounds.mjs';\nexport { _getGlobalBoundsRecursive, getFastGlobalBounds } from './scene/container/bounds/getFastGlobalBounds.mjs';\nexport { _getGlobalBounds, getGlobalBounds, updateTransformBackwards } from './scene/container/bounds/getGlobalBounds.mjs';\nexport { getLocalBounds, getParent } from './scene/container/bounds/getLocalBounds.mjs';\nexport { getGlobalRenderableBounds } from './scene/container/bounds/getRenderableBounds.mjs';\nexport { boundsPool, matrixPool } from './scene/container/bounds/utils/matrixAndBoundsPool.mjs';\nexport { cacheAsTextureMixin } from './scene/container/container-mixins/cacheAsTextureMixin.mjs';\nexport { childrenHelperMixin } from './scene/container/container-mixins/childrenHelperMixin.mjs';\nexport { effectsMixin } from './scene/container/container-mixins/effectsMixin.mjs';\nexport { findMixin } from './scene/container/container-mixins/findMixin.mjs';\nexport { bgr2rgb, getGlobalMixin } from './scene/container/container-mixins/getGlobalMixin.mjs';\nexport { measureMixin } from './scene/container/container-mixins/measureMixin.mjs';\nexport { onRenderMixin } from './scene/container/container-mixins/onRenderMixin.mjs';\nexport { sortMixin } from './scene/container/container-mixins/sortMixin.mjs';\nexport { toLocalGlobalMixin } from './scene/container/container-mixins/toLocalGlobalMixin.mjs';\nexport { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_TRANSFORM, UPDATE_VISIBLE } from './scene/container/Container.mjs';\nexport { CustomRenderPipe } from './scene/container/CustomRenderPipe.mjs';\nexport { RenderContainer } from './scene/container/RenderContainer.mjs';\nexport { RenderGroup } from './scene/container/RenderGroup.mjs';\nexport { RenderGroupPipe } from './scene/container/RenderGroupPipe.mjs';\nexport { RenderGroupSystem } from './scene/container/RenderGroupSystem.mjs';\nexport { assignWithIgnore } from './scene/container/utils/assignWithIgnore.mjs';\nexport { buildInstructions, collectAllRenderables } from './scene/container/utils/buildInstructions.mjs';\nexport { checkChildrenDidChange } from './scene/container/utils/checkChildrenDidChange.mjs';\nexport { clearList } from './scene/container/utils/clearList.mjs';\nexport { definedProps } from './scene/container/utils/definedProps.mjs';\nexport { executeInstructions } from './scene/container/utils/executeInstructions.mjs';\nexport { mixHexColors } from './scene/container/utils/mixHexColors.mjs';\nexport { multiplyColors } from './scene/container/utils/multiplyColors.mjs';\nexport { multiplyHexColors } from './scene/container/utils/multiplyHexColors.mjs';\nexport { updateLocalTransform } from './scene/container/utils/updateLocalTransform.mjs';\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren } from './scene/container/utils/updateRenderGroupTransforms.mjs';\nexport { updateWorldTransform } from './scene/container/utils/updateWorldTransform.mjs';\nexport { validateRenderables } from './scene/container/utils/validateRenderables.mjs';\nexport { GlGraphicsAdaptor } from './scene/graphics/gl/GlGraphicsAdaptor.mjs';\nexport { color32BitToUniform, colorToUniform } from './scene/graphics/gpu/colorToUniform.mjs';\nexport { GpuGraphicsAdaptor } from './scene/graphics/gpu/GpuGraphicsAdaptor.mjs';\nexport { BatchableGraphics } from './scene/graphics/shared/BatchableGraphics.mjs';\nexport { buildAdaptiveBezier } from './scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs';\nexport { buildAdaptiveQuadratic } from './scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs';\nexport { buildArc } from './scene/graphics/shared/buildCommands/buildArc.mjs';\nexport { buildArcTo } from './scene/graphics/shared/buildCommands/buildArcTo.mjs';\nexport { buildArcToSvg } from './scene/graphics/shared/buildCommands/buildArcToSvg.mjs';\nexport { buildCircle, buildEllipse, buildRoundedRectangle } from './scene/graphics/shared/buildCommands/buildCircle.mjs';\nexport { buildLine } from './scene/graphics/shared/buildCommands/buildLine.mjs';\nexport { buildPixelLine } from './scene/graphics/shared/buildCommands/buildPixelLine.mjs';\nexport { buildPolygon } from './scene/graphics/shared/buildCommands/buildPolygon.mjs';\nexport { buildRectangle } from './scene/graphics/shared/buildCommands/buildRectangle.mjs';\nexport { buildTriangle } from './scene/graphics/shared/buildCommands/buildTriangle.mjs';\nexport { closePointEps, curveEps } from './scene/graphics/shared/const.mjs';\nexport { FillGradient } from './scene/graphics/shared/fill/FillGradient.mjs';\nexport { FillPattern } from './scene/graphics/shared/fill/FillPattern.mjs';\nexport { Graphics } from './scene/graphics/shared/Graphics.mjs';\nexport { GraphicsContext } from './scene/graphics/shared/GraphicsContext.mjs';\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem } from './scene/graphics/shared/GraphicsContextSystem.mjs';\nexport { GraphicsPipe } from './scene/graphics/shared/GraphicsPipe.mjs';\nexport { GraphicsPath } from './scene/graphics/shared/path/GraphicsPath.mjs';\nexport { roundedShapeArc, roundedShapeQuadraticCurve } from './scene/graphics/shared/path/roundShape.mjs';\nexport { ShapePath } from './scene/graphics/shared/path/ShapePath.mjs';\nexport { SVGParser } from './scene/graphics/shared/svg/SVGParser.mjs';\nexport { SVGToGraphicsPath } from './scene/graphics/shared/svg/SVGToGraphicsPath.mjs';\nexport { buildContextBatches, shapeBuilders } from './scene/graphics/shared/utils/buildContextBatches.mjs';\nexport { buildGeometryFromPath } from './scene/graphics/shared/utils/buildGeometryFromPath.mjs';\nexport { toFillStyle, toStrokeStyle } from './scene/graphics/shared/utils/convertFillInputToFillStyle.mjs';\nexport { getOrientationOfPoints } from './scene/graphics/shared/utils/getOrientationOfPoints.mjs';\nexport { triangulateWithHoles } from './scene/graphics/shared/utils/triangulateWithHoles.mjs';\nexport { PerspectiveMesh } from './scene/mesh-perspective/PerspectiveMesh.mjs';\nexport { PerspectivePlaneGeometry } from './scene/mesh-perspective/PerspectivePlaneGeometry.mjs';\nexport { applyProjectiveTransformationToPlane } from './scene/mesh-perspective/utils/applyProjectiveTransformationToPlane.mjs';\nexport { compute2DProjection } from './scene/mesh-perspective/utils/compute2DProjections.mjs';\nexport { MeshPlane } from './scene/mesh-plane/MeshPlane.mjs';\nexport { PlaneGeometry } from './scene/mesh-plane/PlaneGeometry.mjs';\nexport { MeshRope } from './scene/mesh-simple/MeshRope.mjs';\nexport { MeshSimple } from './scene/mesh-simple/MeshSimple.mjs';\nexport { RopeGeometry } from './scene/mesh-simple/RopeGeometry.mjs';\nexport { GlMeshAdaptor } from './scene/mesh/gl/GlMeshAdaptor.mjs';\nexport { GpuMeshAdapter } from './scene/mesh/gpu/GpuMeshAdapter.mjs';\nexport { BatchableMesh } from './scene/mesh/shared/BatchableMesh.mjs';\nexport { getTextureDefaultMatrix } from './scene/mesh/shared/getTextureDefaultMatrix.mjs';\nexport { Mesh } from './scene/mesh/shared/Mesh.mjs';\nexport { MeshGeometry } from './scene/mesh/shared/MeshGeometry.mjs';\nexport { MeshPipe } from './scene/mesh/shared/MeshPipe.mjs';\nexport { GlParticleContainerAdaptor } from './scene/particle-container/gl/GlParticleContainerAdaptor.mjs';\nexport { GpuParticleContainerAdaptor } from './scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs';\nexport { GlParticleContainerPipe } from './scene/particle-container/shared/GlParticleContainerPipe.mjs';\nexport { GpuParticleContainerPipe } from './scene/particle-container/shared/GpuParticleContainerPipe.mjs';\nexport { Particle } from './scene/particle-container/shared/Particle.mjs';\nexport { ParticleBuffer } from './scene/particle-container/shared/ParticleBuffer.mjs';\nexport { ParticleContainer } from './scene/particle-container/shared/ParticleContainer.mjs';\nexport { ParticleContainerPipe } from './scene/particle-container/shared/ParticleContainerPipe.mjs';\nexport { particleData } from './scene/particle-container/shared/particleData.mjs';\nexport { ParticleShader } from './scene/particle-container/shared/shader/ParticleShader.mjs';\nexport { createIndicesForQuads } from './scene/particle-container/shared/utils/createIndicesForQuads.mjs';\nexport { generateParticleUpdateFunction } from './scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs';\nexport { AnimatedSprite } from './scene/sprite-animated/AnimatedSprite.mjs';\nexport { NineSliceGeometry } from './scene/sprite-nine-slice/NineSliceGeometry.mjs';\nexport { NineSlicePlane, NineSliceSprite } from './scene/sprite-nine-slice/NineSliceSprite.mjs';\nexport { NineSliceSpritePipe } from './scene/sprite-nine-slice/NineSliceSpritePipe.mjs';\nexport { tilingBit, tilingBitGl } from './scene/sprite-tiling/shader/tilingBit.mjs';\nexport { TilingSpriteShader } from './scene/sprite-tiling/shader/TilingSpriteShader.mjs';\nexport { TilingSprite } from './scene/sprite-tiling/TilingSprite.mjs';\nexport { TilingSpritePipe } from './scene/sprite-tiling/TilingSpritePipe.mjs';\nexport { applyMatrix } from './scene/sprite-tiling/utils/applyMatrix.mjs';\nexport { QuadGeometry } from './scene/sprite-tiling/utils/QuadGeometry.mjs';\nexport { setPositions } from './scene/sprite-tiling/utils/setPositions.mjs';\nexport { setUvs } from './scene/sprite-tiling/utils/setUvs.mjs';\nexport { BatchableSprite } from './scene/sprite/BatchableSprite.mjs';\nexport { Sprite } from './scene/sprite/Sprite.mjs';\nexport { SpritePipe } from './scene/sprite/SpritePipe.mjs';\nexport { AbstractBitmapFont } from './scene/text-bitmap/AbstractBitmapFont.mjs';\nexport { bitmapFontTextParser } from './scene/text-bitmap/asset/bitmapFontTextParser.mjs';\nexport { bitmapFontXMLParser } from './scene/text-bitmap/asset/bitmapFontXMLParser.mjs';\nexport { bitmapFontXMLStringParser } from './scene/text-bitmap/asset/bitmapFontXMLStringParser.mjs';\nexport { bitmapFontCachePlugin, loadBitmapFont } from './scene/text-bitmap/asset/loadBitmapFont.mjs';\nexport { BitmapFont } from './scene/text-bitmap/BitmapFont.mjs';\nexport { BitmapFontManager } from './scene/text-bitmap/BitmapFontManager.mjs';\nexport { BitmapText } from './scene/text-bitmap/BitmapText.mjs';\nexport { BitmapTextPipe } from './scene/text-bitmap/BitmapTextPipe.mjs';\nexport { DynamicBitmapFont } from './scene/text-bitmap/DynamicBitmapFont.mjs';\nexport { getBitmapTextLayout } from './scene/text-bitmap/utils/getBitmapTextLayout.mjs';\nexport { resolveCharacters } from './scene/text-bitmap/utils/resolveCharacters.mjs';\nexport { HTMLText } from './scene/text-html/HTMLText.mjs';\nexport { HTMLTextPipe } from './scene/text-html/HTMLTextPipe.mjs';\nexport { HTMLTextRenderData, nssvg, nsxhtml } from './scene/text-html/HTMLTextRenderData.mjs';\nexport { HTMLTextStyle } from './scene/text-html/HTMLTextStyle.mjs';\nexport { HTMLTextSystem } from './scene/text-html/HTMLTextSystem.mjs';\nexport { extractFontFamilies } from './scene/text-html/utils/extractFontFamilies.mjs';\nexport { FontStylePromiseCache, getFontCss } from './scene/text-html/utils/getFontCss.mjs';\nexport { getSVGUrl } from './scene/text-html/utils/getSVGUrl.mjs';\nexport { getTemporaryCanvasFromImage } from './scene/text-html/utils/getTemporaryCanvasFromImage.mjs';\nexport { loadFontAsBase64 } from './scene/text-html/utils/loadFontAsBase64.mjs';\nexport { loadFontCSS } from './scene/text-html/utils/loadFontCSS.mjs';\nexport { loadSVGImage } from './scene/text-html/utils/loadSVGImage.mjs';\nexport { measureHtmlText } from './scene/text-html/utils/measureHtmlText.mjs';\nexport { textStyleToCSS } from './scene/text-html/utils/textStyleToCSS.mjs';\nexport { AbstractText, ensureOptions } from './scene/text/AbstractText.mjs';\nexport { CanvasTextMetrics } from './scene/text/canvas/CanvasTextMetrics.mjs';\nexport { CanvasTextPipe } from './scene/text/canvas/CanvasTextPipe.mjs';\nexport { CanvasTextSystem } from './scene/text/canvas/CanvasTextSystem.mjs';\nexport { fontStringFromTextStyle } from './scene/text/canvas/utils/fontStringFromTextStyle.mjs';\nexport { getCanvasFillStyle } from './scene/text/canvas/utils/getCanvasFillStyle.mjs';\nexport { SdfShader } from './scene/text/sdfShader/SdfShader.mjs';\nexport { localUniformMSDFBit, localUniformMSDFBitGl } from './scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs';\nexport { mSDFBit, mSDFBitGl } from './scene/text/sdfShader/shader-bits/mSDFBit.mjs';\nexport { Text } from './scene/text/Text.mjs';\nexport { TextStyle } from './scene/text/TextStyle.mjs';\nexport { ensureTextStyle } from './scene/text/utils/ensureTextStyle.mjs';\nexport { generateTextStyleKey } from './scene/text/utils/generateTextStyleKey.mjs';\nexport { getPo2TextureFromSource } from './scene/text/utils/getPo2TextureFromSource.mjs';\nexport { ViewContainer } from './scene/view/ViewContainer.mjs';\nexport { Spritesheet } from './spritesheet/Spritesheet.mjs';\nexport { spritesheetAsset } from './spritesheet/spritesheetAsset.mjs';\nexport { UPDATE_PRIORITY } from './ticker/const.mjs';\nexport { Ticker } from './ticker/Ticker.mjs';\nexport { TickerListener } from './ticker/TickerListener.mjs';\nexport { detectVideoAlphaMode } from './utils/browser/detectVideoAlphaMode.mjs';\nexport { isMobile } from './utils/browser/isMobile.mjs';\nexport { isSafari } from './utils/browser/isSafari.mjs';\nexport { isWebGLSupported } from './utils/browser/isWebGLSupported.mjs';\nexport { isWebGPUSupported } from './utils/browser/isWebGPUSupported.mjs';\nexport { unsafeEvalSupported } from './utils/browser/unsafeEvalSupported.mjs';\nexport { getCanvasBoundingBox } from './utils/canvas/getCanvasBoundingBox.mjs';\nexport { DATA_URI, VERSION } from './utils/const.mjs';\nexport { default as EventEmitter } from 'eventemitter3';\nexport { cleanArray, cleanHash } from './utils/data/clean.mjs';\nexport { removeItems } from './utils/data/removeItems.mjs';\nexport { resetUids, uid } from './utils/data/uid.mjs';\nexport { updateQuadBounds } from './utils/data/updateQuadBounds.mjs';\nexport { ViewableBuffer } from './utils/data/ViewableBuffer.mjs';\nexport { ApplicationInitHook, RendererInitHook } from './utils/global/globalHooks.mjs';\nexport { deprecation, v8_0_0, v8_3_4 } from './utils/logging/deprecation.mjs';\nexport { logDebugTexture } from './utils/logging/logDebugTexture.mjs';\nexport { logRenderGroupScene, logScene } from './utils/logging/logScene.mjs';\nexport { warn } from './utils/logging/warn.mjs';\nexport { NOOP } from './utils/misc/NOOP.mjs';\nexport { Transform } from './utils/misc/Transform.mjs';\nexport { getResolutionOfUrl } from './utils/network/getResolutionOfUrl.mjs';\nexport { path } from './utils/path.mjs';\nexport { Pool } from './utils/pool/Pool.mjs';\nexport { BigPool, PoolGroupClass } from './utils/pool/PoolGroup.mjs';\nexport { sayHello } from './utils/sayHello.mjs';\nexport { default as earcut } from 'earcut';\n\n\"use strict\";\nextensions.add(browserExt, webworkerExt);\n\nexport { browserExt, extensions, webworkerExt };\n//# sourceMappingURL=index.mjs.map\n","export default __webpack_public_path__ + \"8bf10a11f7a60e8647c27b9cd29ec80a.png\";","import CHARACTERS from './characters.png';\nimport TILES from './sheet.png';\nexport const atlasData = {\n    characters: {\n        meta: {\n            image: CHARACTERS,\n            scale: 1,\n            format: 'RGBA8888',\n            size: { w: 736, h: 128 },\n        },\n        frames: {\n            player_walk_0: {\n                frame: { x: 0, y: 32, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_walk_1: {\n                frame: { x: 32 * 1, y: 32, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_walk_2: {\n                frame: { x: 32 * 2, y: 32, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_walk_3: {\n                frame: { x: 32 * 3, y: 32, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_jump_0: {\n                frame: { x: 32 * 4, y: 32, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_jump_1: {\n                frame: { x: 32 * 5, y: 32, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_jump_2: {\n                frame: { x: 32 * 6, y: 32, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_slash_0: {\n                frame: { x: 32 * 4, y: 32 * 3, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_slash_1: {\n                frame: { x: 32 * 5, y: 32 * 3, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_slash_2: {\n                frame: { x: 32 * 6, y: 32 * 3, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_slash_3: {\n                frame: { x: 32 * 7, y: 32 * 3, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n            player_slash_4: {\n                frame: { x: 32 * 8, y: 32 * 3, h: 32, w: 32 },\n                sourceSize: { w: 32, h: 32 }\n            },\n        },\n        animations: {\n            playerWalk: ['player_walk_0', 'player_walk_1', 'player_walk_2', 'player_walk_3'],\n            playerJump: ['player_jump_0', 'player_jump_1', 'player_jump_2'],\n            playerSlash: ['player_slash_4', 'player_slash_0', 'player_slash_1', 'player_slash_2', 'player_slash_3', 'player_slash_4']\n        }\n    },\n    tiles: {\n        meta: {\n            image: TILES,\n            scale: 1,\n            format: 'RGBA8888',\n            size: { w: 272, h: 128 },\n        },\n        frames: {\n            blank: {\n                frame: { x: 0, y: 3 * 16, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            grass_top: {\n                frame: { x: 16 * 8, y: 0, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            solid: {\n                frame: { x: 16 * 11, y: 16, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            spike: {\n                frame: { x: 16 * 7, y: 16 * 7, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            fence_left: {\n                frame: { x: 16 * 14, y: 16 * 3, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            fence_mid: {\n                frame: { x: 16 * 15, y: 16 * 3, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            fence_right: {\n                frame: { x: 16 * 16, y: 16 * 3, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            flower1: {\n                frame: { x: 16 * 14, y: 16 * 6, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            flower2: {\n                frame: { x: 16 * 14, y: 16 * 5, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            exit: {\n                frame: { x: 16 * 14, y: 16, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            left_wall: {\n                frame: { x: 16 * 12, y: 16, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            top_wall: {\n                frame: { x: 16 * 11, y: 0, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            right_wall: {\n                frame: { x: 16 * 10, y: 16, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            rock: {\n                frame: { x: 16 * 16, y: 16 * 6, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n            blank_dot: {\n                frame: { x: 16 * 7, y: 16, h: 16, w: 16 },\n                sourceSize: { w: 16, h: 16 },\n                spriteSourceSize: { w: 6, h: 16, x: 0, y: 0 }\n            },\n        }\n    }\n};\n","export default __webpack_public_path__ + \"6a53af6f64fb4515abfec35ee0e16901.png\";","import { Graphics } from \"pixi.js\";\nexport class Rectangle extends Graphics {\n    constructor(x, y, w, h, c) {\n        super();\n        this.beginPath();\n        this.setStrokeStyle(c !== null && c !== void 0 ? c : \"#FF0000\");\n        this.rect(x, y, w, h);\n        this.stroke();\n        this.closePath();\n    }\n}\n","import { Container } from \"pixi.js\";\nimport { Rectangle } from \"@components/debug/Rectangle\";\nexport class CollisionBody {\n    constructor(engine, x, y, w, h, type, trigger) {\n        this.view = new Container();\n        this.view.x = x;\n        this.view.y = y;\n        this.type = type;\n        this.view.addChild(new Rectangle(0, 0, w, h, \"#00FF00\"));\n        this.trigger = trigger !== null && trigger !== void 0 ? trigger : false;\n        this.callbacks = [];\n        engine.colliders.push(this);\n    }\n    isColliding(other) {\n        if (this.maxX() <= other.minX() || this.minX() >= other.maxX() ||\n            this.maxY() <= other.minY() || this.minY() >= other.maxY())\n            return [];\n        const pcTopBottom = ((this.maxX() > other.maxX() ? other.maxX() : this.maxX()) - (this.minX() < other.minX() ? other.minX() : this.minX())) / (this.maxX() - this.minX());\n        const pcLeftRight = ((this.maxY() > other.maxY() ? other.maxY() : this.maxY()) - (this.minY() < other.minY() ? other.minY() : this.minY())) / (this.maxY() - this.minY());\n        const sides = [];\n        if (this.maxX() > other.minX() && this.minX() < other.minX())\n            sides.push(\"left\");\n        if (this.minX() < other.maxX() && this.maxX() > other.maxX())\n            sides.push(\"right\");\n        if (this.maxY() > other.minY() && this.minY() < other.minY() && pcTopBottom > 0.3)\n            sides.push(\"top\");\n        if (this.minY() < other.maxY() && this.maxY() > other.maxY() && pcTopBottom > 0.3)\n            sides.push(\"bottom\");\n        return sides;\n    }\n    minX() { return this.view.getBounds().minX; }\n    maxX() { return this.view.getBounds().maxX; }\n    minY() { return this.view.getBounds().minY; }\n    maxY() { return this.view.getBounds().maxY; }\n    collisionCallback(other, s) {\n        this.callbacks.forEach(fn => fn(other, s));\n    }\n    onCollision(fn) {\n        this.callbacks.push(fn);\n    }\n}\n","import { CollisionBody } from \"@components/physics/collisionbody\";\nimport { Container } from \"pixi.js\";\nexport class Platform {\n    constructor(engine, x, y, w, h) {\n        this.view = new Container();\n        this.view.position.set(x, y);\n        this.view.width = w;\n        this.view.height = h;\n        this.view.addChild(new CollisionBody(engine, 0, 0, w, h, 'platform').view);\n    }\n}\n","import { Container } from \"pixi.js\";\nexport class AnimationController {\n    constructor(animations) {\n        this.view = new Container();\n        this.animations = Object.assign({}, animations);\n    }\n    setAnimation(id) {\n        const next = this.animations[id];\n        if (next === this.selected)\n            return this;\n        if (this.selected) {\n            this.selected.gotoAndStop(0);\n            this.view.removeChild(this.selected);\n        }\n        this.selected = this.animations[id];\n        this.view.addChild(this.selected);\n        return this;\n    }\n    play() {\n        this.selected.play();\n        return this;\n    }\n    stop() {\n        this.selected.stop();\n        return this;\n    }\n    setFrame(frame) {\n        this.selected.gotoAndStop(frame);\n        return this;\n    }\n}\n","/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = '171';\n\nconst MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst CullFaceFrontBack = 3;\nconst BasicShadowMap = 0;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst ConstantColorFactor = 211;\nconst OneMinusConstantColorFactor = 212;\nconst ConstantAlphaFactor = 213;\nconst OneMinusConstantAlphaFactor = 214;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\nconst AgXToneMapping = 6;\nconst NeutralToneMapping = 7;\nconst AttachedBindMode = 'attached';\nconst DetachedBindMode = 'detached';\n\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipMapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst NearestMipMapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipMapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst LinearMipMapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedInt248Type = 1020;\nconst UnsignedInt5999Type = 35902;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBIntegerFormat = 1032;\nconst RGBAIntegerFormat = 1033;\n\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst RGB_BPTC_SIGNED_Format = 36494;\nconst RGB_BPTC_UNSIGNED_Format = 36495;\nconst RED_RGTC1_Format = 36283;\nconst SIGNED_RED_RGTC1_Format = 36284;\nconst RED_GREEN_RGTC2_Format = 36285;\nconst SIGNED_RED_GREEN_RGTC2_Format = 36286;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst RGBDepthPacking = 3202;\nconst RGDepthPacking = 3203;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\n\n// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\nconst NoColorSpace = '';\nconst SRGBColorSpace = 'srgb';\nconst LinearSRGBColorSpace = 'srgb-linear';\n\nconst LinearTransfer = 'linear';\nconst SRGBTransfer = 'srgb';\n\nconst ZeroStencilOp = 0;\nconst KeepStencilOp = 7680;\nconst ReplaceStencilOp = 7681;\nconst IncrementStencilOp = 7682;\nconst DecrementStencilOp = 7683;\nconst IncrementWrapStencilOp = 34055;\nconst DecrementWrapStencilOp = 34056;\nconst InvertStencilOp = 5386;\n\nconst NeverStencilFunc = 512;\nconst LessStencilFunc = 513;\nconst EqualStencilFunc = 514;\nconst LessEqualStencilFunc = 515;\nconst GreaterStencilFunc = 516;\nconst NotEqualStencilFunc = 517;\nconst GreaterEqualStencilFunc = 518;\nconst AlwaysStencilFunc = 519;\n\nconst NeverCompare = 512;\nconst LessCompare = 513;\nconst EqualCompare = 514;\nconst LessEqualCompare = 515;\nconst GreaterCompare = 516;\nconst NotEqualCompare = 517;\nconst GreaterEqualCompare = 518;\nconst AlwaysCompare = 519;\n\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst StreamDrawUsage = 35040;\nconst StaticReadUsage = 35045;\nconst DynamicReadUsage = 35049;\nconst StreamReadUsage = 35041;\nconst StaticCopyUsage = 35046;\nconst DynamicCopyUsage = 35050;\nconst StreamCopyUsage = 35042;\n\nconst GLSL1 = '100';\nconst GLSL3 = '300 es';\n\nconst WebGLCoordinateSystem = 2000;\nconst WebGPUCoordinateSystem = 2001;\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}\n\nconst _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nclass Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tVector2.prototype.isVector2 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\n\t}\n\n}\n\nclass Matrix3 {\n\n\tconstructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tMatrix3.prototype.isMatrix3 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tscale( sx, sy ) {\n\n\t\tthis.premultiply( _m3.makeScale( sx, sy ) );\n\n\t\treturn this;\n\n\t}\n\n\trotate( theta ) {\n\n\t\tthis.premultiply( _m3.makeRotation( - theta ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( tx, ty ) {\n\n\t\tthis.premultiply( _m3.makeTranslation( tx, ty ) );\n\n\t\treturn this;\n\n\t}\n\n\t// for 2D Transforms\n\n\tmakeTranslation( x, y ) {\n\n\t\tif ( x.isVector2 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x.x,\n\t\t\t\t0, 1, x.y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x,\n\t\t\t\t0, 1, y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotation( theta ) {\n\n\t\t// counterclockwise\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0,\n\t\t\ts, c, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0,\n\t\t\t0, y, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nconst _m3 = /*@__PURE__*/ new Matrix3();\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nfunction createElementNS( name ) {\n\n\treturn document.createElementNS( 'http://www.w3.org/1999/xhtml', name );\n\n}\n\nfunction createCanvasElement() {\n\n\tconst canvas = createElementNS( 'canvas' );\n\tcanvas.style.display = 'block';\n\treturn canvas;\n\n}\n\nconst _cache = {};\n\nfunction warnOnce( message ) {\n\n\tif ( message in _cache ) return;\n\n\t_cache[ message ] = true;\n\n\tconsole.warn( message );\n\n}\n\nfunction probeAsync( gl, sync, interval ) {\n\n\treturn new Promise( function ( resolve, reject ) {\n\n\t\tfunction probe() {\n\n\t\t\tswitch ( gl.clientWaitSync( sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0 ) ) {\n\n\t\t\t\tcase gl.WAIT_FAILED:\n\t\t\t\t\treject();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.TIMEOUT_EXPIRED:\n\t\t\t\t\tsetTimeout( probe, interval );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tresolve();\n\n\t\t\t}\n\n\t\t}\n\n\t\tsetTimeout( probe, interval );\n\n\t} );\n\n}\n\nfunction toNormalizedProjectionMatrix( projectionMatrix ) {\n\n\tconst m = projectionMatrix.elements;\n\n\t// Convert [-1, 1] to [0, 1] projection matrix\n\tm[ 2 ] = 0.5 * m[ 2 ] + 0.5 * m[ 3 ];\n\tm[ 6 ] = 0.5 * m[ 6 ] + 0.5 * m[ 7 ];\n\tm[ 10 ] = 0.5 * m[ 10 ] + 0.5 * m[ 11 ];\n\tm[ 14 ] = 0.5 * m[ 14 ] + 0.5 * m[ 15 ];\n\n}\n\nfunction toReversedProjectionMatrix( projectionMatrix ) {\n\n\tconst m = projectionMatrix.elements;\n\tconst isPerspectiveMatrix = m[ 11 ] === - 1;\n\n\t// Reverse [0, 1] projection matrix\n\tif ( isPerspectiveMatrix ) {\n\n\t\tm[ 10 ] = - m[ 10 ] - 1;\n\t\tm[ 14 ] = - m[ 14 ];\n\n\t} else {\n\n\t\tm[ 10 ] = - m[ 10 ];\n\t\tm[ 14 ] = - m[ 14 ] + 1;\n\n\t}\n\n}\n\nconst LINEAR_REC709_TO_XYZ = /*@__PURE__*/ new Matrix3().set(\n\t0.4123908, 0.3575843, 0.1804808,\n\t0.2126390, 0.7151687, 0.0721923,\n\t0.0193308, 0.1191948, 0.9505322\n);\n\nconst XYZ_TO_LINEAR_REC709 = /*@__PURE__*/ new Matrix3().set(\n\t3.2409699, - 1.5373832, - 0.4986108,\n\t- 0.9692436, 1.8759675, 0.0415551,\n\t0.0556301, - 0.2039770, 1.0569715\n);\n\nfunction createColorManagement() {\n\n\tconst ColorManagement = {\n\n\t\tenabled: true,\n\n\t\tworkingColorSpace: LinearSRGBColorSpace,\n\n\t\t/**\n\t\t * Implementations of supported color spaces.\n\t\t *\n\t\t * Required:\n\t\t *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n\t\t *\t- whitePoint: reference white [ x y ]\n\t\t *\t- transfer: transfer function (pre-defined)\n\t\t *\t- toXYZ: Matrix3 RGB to XYZ transform\n\t\t *\t- fromXYZ: Matrix3 XYZ to RGB transform\n\t\t *\t- luminanceCoefficients: RGB luminance coefficients\n\t\t *\n\t\t * Optional:\n\t\t *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n\t\t *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n\t\t *\n\t\t * Reference:\n\t\t * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n\t\t */\n\t\tspaces: {},\n\n\t\tconvert: function ( color, sourceColorSpace, targetColorSpace ) {\n\n\t\t\tif ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {\n\n\t\t\t\treturn color;\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ sourceColorSpace ].transfer === SRGBTransfer ) {\n\n\t\t\t\tcolor.r = SRGBToLinear( color.r );\n\t\t\t\tcolor.g = SRGBToLinear( color.g );\n\t\t\t\tcolor.b = SRGBToLinear( color.b );\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ sourceColorSpace ].primaries !== this.spaces[ targetColorSpace ].primaries ) {\n\n\t\t\t\tcolor.applyMatrix3( this.spaces[ sourceColorSpace ].toXYZ );\n\t\t\t\tcolor.applyMatrix3( this.spaces[ targetColorSpace ].fromXYZ );\n\n\t\t\t}\n\n\t\t\tif ( this.spaces[ targetColorSpace ].transfer === SRGBTransfer ) {\n\n\t\t\t\tcolor.r = LinearToSRGB( color.r );\n\t\t\t\tcolor.g = LinearToSRGB( color.g );\n\t\t\t\tcolor.b = LinearToSRGB( color.b );\n\n\t\t\t}\n\n\t\t\treturn color;\n\n\t\t},\n\n\t\tfromWorkingColorSpace: function ( color, targetColorSpace ) {\n\n\t\t\treturn this.convert( color, this.workingColorSpace, targetColorSpace );\n\n\t\t},\n\n\t\ttoWorkingColorSpace: function ( color, sourceColorSpace ) {\n\n\t\t\treturn this.convert( color, sourceColorSpace, this.workingColorSpace );\n\n\t\t},\n\n\t\tgetPrimaries: function ( colorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].primaries;\n\n\t\t},\n\n\t\tgetTransfer: function ( colorSpace ) {\n\n\t\t\tif ( colorSpace === NoColorSpace ) return LinearTransfer;\n\n\t\t\treturn this.spaces[ colorSpace ].transfer;\n\n\t\t},\n\n\t\tgetLuminanceCoefficients: function ( target, colorSpace = this.workingColorSpace ) {\n\n\t\t\treturn target.fromArray( this.spaces[ colorSpace ].luminanceCoefficients );\n\n\t\t},\n\n\t\tdefine: function ( colorSpaces ) {\n\n\t\t\tObject.assign( this.spaces, colorSpaces );\n\n\t\t},\n\n\t\t// Internal APIs\n\n\t\t_getMatrix: function ( targetMatrix, sourceColorSpace, targetColorSpace ) {\n\n\t\t\treturn targetMatrix\n\t\t\t\t.copy( this.spaces[ sourceColorSpace ].toXYZ )\n\t\t\t\t.multiply( this.spaces[ targetColorSpace ].fromXYZ );\n\n\t\t},\n\n\t\t_getDrawingBufferColorSpace: function ( colorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].outputColorSpaceConfig.drawingBufferColorSpace;\n\n\t\t},\n\n\t\t_getUnpackColorSpace: function ( colorSpace = this.workingColorSpace ) {\n\n\t\t\treturn this.spaces[ colorSpace ].workingColorSpaceConfig.unpackColorSpace;\n\n\t\t}\n\n\t};\n\n\t/******************************************************************************\n\t * sRGB definitions\n\t */\n\n\tconst REC709_PRIMARIES = [ 0.640, 0.330, 0.300, 0.600, 0.150, 0.060 ];\n\tconst REC709_LUMINANCE_COEFFICIENTS = [ 0.2126, 0.7152, 0.0722 ];\n\tconst D65 = [ 0.3127, 0.3290 ];\n\n\tColorManagement.define( {\n\n\t\t[ LinearSRGBColorSpace ]: {\n\t\t\tprimaries: REC709_PRIMARIES,\n\t\t\twhitePoint: D65,\n\t\t\ttransfer: LinearTransfer,\n\t\t\ttoXYZ: LINEAR_REC709_TO_XYZ,\n\t\t\tfromXYZ: XYZ_TO_LINEAR_REC709,\n\t\t\tluminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n\t\t\tworkingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n\t\t\toutputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n\t\t},\n\n\t\t[ SRGBColorSpace ]: {\n\t\t\tprimaries: REC709_PRIMARIES,\n\t\t\twhitePoint: D65,\n\t\t\ttransfer: SRGBTransfer,\n\t\t\ttoXYZ: LINEAR_REC709_TO_XYZ,\n\t\t\tfromXYZ: XYZ_TO_LINEAR_REC709,\n\t\t\tluminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n\t\t\toutputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n\t\t},\n\n\t} );\n\n\treturn ColorManagement;\n\n}\n\nconst ColorManagement = /*@__PURE__*/ createColorManagement();\n\nfunction SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nfunction LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n\nlet _canvas;\n\nclass ImageUtils {\n\n\tstatic getDataURL( image ) {\n\n\t\tif ( /^data:/i.test( image.src ) ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tif ( typeof HTMLCanvasElement === 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tlet canvas;\n\n\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tconst context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n\tstatic sRGBToLinear( image ) {\n\n\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\tconst canvas = createElementNS( 'canvas' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\tconst imageData = context.getImageData( 0, 0, image.width, image.height );\n\t\t\tconst data = imageData.data;\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;\n\n\t\t\t}\n\n\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\treturn canvas;\n\n\t\t} else if ( image.data ) {\n\n\t\t\tconst data = image.data.slice( 0 );\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tif ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {\n\n\t\t\t\t\tdata[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assuming float\n\n\t\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdata: data,\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );\n\t\t\treturn image;\n\n\t\t}\n\n\t}\n\n}\n\nlet _sourceId = 0;\n\nclass Source {\n\n\tconstructor( data = null ) {\n\n\t\tthis.isSource = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _sourceId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.data = data;\n\t\tthis.dataReady = true;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.images[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\t\t\tuuid: this.uuid,\n\t\t\turl: ''\n\t\t};\n\n\t\tconst data = this.data;\n\n\t\tif ( data !== null ) {\n\n\t\t\tlet url;\n\n\t\t\tif ( Array.isArray( data ) ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\turl = [];\n\n\t\t\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( data[ i ].isDataTexture ) {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ].image ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// texture\n\n\t\t\t\turl = serializeImage( data );\n\n\t\t\t}\n\n\t\t\toutput.url = url;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.images[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nfunction serializeImage( image ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t// default images\n\n\t\treturn ImageUtils.getDataURL( image );\n\n\t} else {\n\n\t\tif ( image.data ) {\n\n\t\t\t// images of DataTexture\n\n\t\t\treturn {\n\t\t\t\tdata: Array.from( image.data ),\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\ttype: image.data.constructor.name\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\treturn {};\n\n\t\t}\n\n\t}\n\n}\n\nlet _textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {\n\n\t\tsuper();\n\n\t\tthis.isTexture = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _textureId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.source = new Source( image );\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\t\tthis.channel = 0;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\tthis.colorSpace = colorSpace;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t\tthis.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n\t\tthis.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n\n\t}\n\n\tget image() {\n\n\t\treturn this.source.data;\n\n\t}\n\n\tset image( value = null ) {\n\n\t\tthis.source.data = value;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.source = source.source;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\t\tthis.channel = source.channel;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.colorSpace = source.colorSpace;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\timage: this.source.toJSON( meta ).uuid,\n\n\t\t\tmapping: this.mapping,\n\t\t\tchannel: this.channel,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\tinternalFormat: this.internalFormat,\n\t\t\ttype: this.type,\n\t\t\tcolorSpace: this.colorSpace,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tgenerateMipmaps: this.generateMipmaps,\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.source.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tset needsPMREMUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.pmremVersion ++;\n\n\t\t}\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.DEFAULT_ANISOTROPY = 1;\n\nclass Vector4 {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tVector4.prototype.isVector4 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.z;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.z = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.w;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.w = value;\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\t\tthis.w *= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\t\tthis.w /= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tsetAxisAngleFromQuaternion( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tconst s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetAxisAngleFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tlet angle, x, y, z; // variables for result\n\t\tconst epsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tconst xx = ( m11 + 1 ) / 2;\n\t\t\tconst yy = ( m22 + 1 ) / 2;\n\t\t\tconst zz = ( m33 + 1 ) / 2;\n\t\t\tconst xy = ( m12 + m21 ) / 4;\n\t\t\tconst xz = ( m13 + m31 ) / 4;\n\t\t\tconst yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tlet s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\t\tthis.w = e[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\t\tthis.z = clamp( this.z, min.z, max.z );\n\t\tthis.w = clamp( this.w, min.w, max.w );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\t\tthis.z = clamp( this.z, minVal, maxVal );\n\t\tthis.w = clamp( this.w, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\t\tthis.w = Math.trunc( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\t\tthis.w = v1.w + ( v2.w - v1.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\t\tthis.w = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\t\tyield this.w;\n\n\t}\n\n}\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nclass RenderTarget extends EventDispatcher {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.isRenderTarget = true;\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.depth = 1;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\tconst image = { width: width, height: height, depth: 1 };\n\n\t\toptions = Object.assign( {\n\t\t\tgenerateMipmaps: false,\n\t\t\tinternalFormat: null,\n\t\t\tminFilter: LinearFilter,\n\t\t\tdepthBuffer: true,\n\t\t\tstencilBuffer: false,\n\t\t\tresolveDepthBuffer: true,\n\t\t\tresolveStencilBuffer: true,\n\t\t\tdepthTexture: null,\n\t\t\tsamples: 0,\n\t\t\tcount: 1\n\t\t}, options );\n\n\t\tconst texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\ttexture.flipY = false;\n\t\ttexture.generateMipmaps = options.generateMipmaps;\n\t\ttexture.internalFormat = options.internalFormat;\n\n\t\tthis.textures = [];\n\n\t\tconst count = options.count;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.textures[ i ] = texture.clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\n\t\t}\n\n\t\tthis.depthBuffer = options.depthBuffer;\n\t\tthis.stencilBuffer = options.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = options.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = options.resolveStencilBuffer;\n\n\t\tthis.depthTexture = options.depthTexture;\n\n\t\tthis.samples = options.samples;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this.textures[ 0 ];\n\n\t}\n\n\tset texture( value ) {\n\n\t\tthis.textures[ 0 ] = value;\n\n\t}\n\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tfor ( let i = 0, il = this.textures.length; i < il; i ++ ) {\n\n\t\t\t\tthis.textures[ i ].image.width = width;\n\t\t\t\tthis.textures[ i ].image.height = height;\n\t\t\t\tthis.textures[ i ].image.depth = depth;\n\n\t\t\t}\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.scissor.copy( source.scissor );\n\t\tthis.scissorTest = source.scissorTest;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.textures.length = 0;\n\n\t\tfor ( let i = 0, il = source.textures.length; i < il; i ++ ) {\n\n\t\t\tthis.textures[ i ] = source.textures[ i ].clone();\n\t\t\tthis.textures[ i ].isRenderTargetTexture = true;\n\n\t\t}\n\n\t\t// ensure image object is not shared, see #20328\n\n\t\tconst image = Object.assign( {}, source.texture.image );\n\t\tthis.texture.source = new Source( image );\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\n\t\tthis.resolveDepthBuffer = source.resolveDepthBuffer;\n\t\tthis.resolveStencilBuffer = source.resolveStencilBuffer;\n\n\t\tif ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nclass WebGLRenderTarget extends RenderTarget {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLRenderTarget = true;\n\n\t}\n\n}\n\nclass DataArrayTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper( null );\n\n\t\tthis.isDataArrayTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t\tthis.layerUpdates = new Set();\n\n\t}\n\n\taddLayerUpdate( layerIndex ) {\n\n\t\tthis.layerUpdates.add( layerIndex );\n\n\t}\n\n\tclearLayerUpdates() {\n\n\t\tthis.layerUpdates.clear();\n\n\t}\n\n}\n\nclass WebGLArrayRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLArrayRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new DataArrayTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Data3DTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t// Users can still set in DataTexture3D directly.\n\t\t//\n\t\t//\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n\t\t// \ttexture.anisotropy = 16;\n\t\t//\n\t\t// See #14839\n\n\t\tsuper( null );\n\n\t\tthis.isData3DTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nclass WebGL3DRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGL3DRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new Data3DTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis.isQuaternion = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update = true ) {\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize(); // normalize calls _onChangeCallback()\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\treturn this.copy( qa ).slerp( qb, t );\n\n\t}\n\n\trandom() {\n\n\t\t// sets this quaternion to a uniform random unit quaternnion\n\n\t\t// Ken Shoemake\n\t\t// Uniform random rotations\n\t\t// D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.\n\n\t\tconst theta1 = 2 * Math.PI * Math.random();\n\t\tconst theta2 = 2 * Math.PI * Math.random();\n\n\t\tconst x0 = Math.random();\n\t\tconst r1 = Math.sqrt( 1 - x0 );\n\t\tconst r2 = Math.sqrt( x0 );\n\n\t\treturn this.set(\n\t\t\tr1 * Math.sin( theta1 ),\n\t\t\tr1 * Math.cos( theta1 ),\n\t\t\tr2 * Math.sin( theta2 ),\n\t\t\tr2 * Math.cos( theta2 ),\n\t\t);\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.toArray();\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._w;\n\n\t}\n\n}\n\nclass Vector3 {\n\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\tVector3.prototype.isVector3 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t}\n\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyEuler( euler ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );\n\n\t}\n\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t// quaternion q is assumed to have unit length\n\n\t\tconst vx = this.x, vy = this.y, vz = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// t = 2 * cross( q.xyz, v );\n\t\tconst tx = 2 * ( qy * vz - qz * vy );\n\t\tconst ty = 2 * ( qz * vx - qx * vz );\n\t\tconst tz = 2 * ( qx * vy - qy * vx );\n\n\t\t// v + q.w * t + cross( q.xyz, t );\n\t\tthis.x = vx + qw * tx + qy * tz - qz * ty;\n\t\tthis.y = vy + qw * ty + qz * tx - qx * tz;\n\t\tthis.z = vz + qw * tz + qx * ty - qy * tx;\n\n\t\treturn this;\n\n\t}\n\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = clamp( this.x, min.x, max.x );\n\t\tthis.y = clamp( this.y, min.y, max.y );\n\t\tthis.z = clamp( this.z, min.z, max.z );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = clamp( this.x, minVal, maxVal );\n\t\tthis.y = clamp( this.y, minVal, maxVal );\n\t\tthis.z = clamp( this.z, minVal, maxVal );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( clamp( length, min, max ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = Math.trunc( this.x );\n\t\tthis.y = Math.trunc( this.y );\n\t\tthis.z = Math.trunc( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector$c.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector$c );\n\n\t}\n\n\treflect( normal ) {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\treturn this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\tsetFromEuler( e ) {\n\n\t\tthis.x = e._x;\n\t\tthis.y = e._y;\n\t\tthis.z = e._z;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromColor( c ) {\n\n\t\tthis.x = c.r;\n\t\tthis.y = c.g;\n\t\tthis.z = c.b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\trandomDirection() {\n\n\t\t// https://mathworld.wolfram.com/SpherePointPicking.html\n\n\t\tconst theta = Math.random() * Math.PI * 2;\n\t\tconst u = Math.random() * 2 - 1;\n\t\tconst c = Math.sqrt( 1 - u * u );\n\n\t\tthis.x = c * Math.cos( theta );\n\t\tthis.y = u;\n\t\tthis.z = c * Math.sin( theta );\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\n\t}\n\n}\n\nconst _vector$c = /*@__PURE__*/ new Vector3();\nconst _quaternion$4 = /*@__PURE__*/ new Quaternion();\n\nclass Box3 {\n\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox3 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromArray( array ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\tthis.expandByPoint( _vector$b.fromArray( array, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( _vector$b.fromBufferAttribute( attribute, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object, precise = false ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object, precise );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\texpandByObject( object, precise = false ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t// precise AABB computation based on vertex data requires at least a position attribute.\n\t\t\t// instancing isn't supported so far and uses the normal (conservative) code path.\n\n\t\t\tif ( precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true ) {\n\n\t\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t\tif ( object.isMesh === true ) {\n\n\t\t\t\t\t\tobject.getVertexPosition( i, _vector$b );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_vector$b.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_vector$b.applyMatrix4( object.matrixWorld );\n\t\t\t\t\tthis.expandByPoint( _vector$b );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( object.boundingBox !== undefined ) {\n\n\t\t\t\t\t// object-level bounding box\n\n\t\t\t\t\tif ( object.boundingBox === null ) {\n\n\t\t\t\t\t\tobject.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$4.copy( object.boundingBox );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// geometry-level bounding box\n\n\t\t\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$4.copy( geometry.boundingBox );\n\n\t\t\t\t}\n\n\t\t\t\t_box$4.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tthis.union( _box$4 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ], precise );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x >= this.min.x && point.x <= this.max.x &&\n\t\t\tpoint.y >= this.min.y && point.y <= this.max.y &&\n\t\t\tpoint.z >= this.min.z && point.z <= this.max.z;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x >= this.min.x && box.min.x <= this.max.x &&\n\t\t\tbox.max.y >= this.min.y && box.min.y <= this.max.y &&\n\t\t\tbox.max.z >= this.min.z && box.min.z <= this.max.z;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector$b );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0$2.subVectors( triangle.a, _center );\n\t\t_v1$7.subVectors( triangle.b, _center );\n\t\t_v2$4.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1$7, _v0$2 );\n\t\t_f1.subVectors( _v2$4, _v1$7 );\n\t\t_f2.subVectors( _v0$2, _v2$4 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$b ).distanceTo( point );\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t} else {\n\n\t\t\tthis.getCenter( target.center );\n\n\t\t\ttarget.radius = this.getSize( _vector$b ).length() * 0.5;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector$b = /*@__PURE__*/ new Vector3();\n\nconst _box$4 = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0$2 = /*@__PURE__*/ new Vector3();\nconst _v1$7 = /*@__PURE__*/ new Vector3();\nconst _v2$4 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the separating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the separating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is separating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nconst _box$3 = /*@__PURE__*/ new Box3();\nconst _v1$6 = /*@__PURE__*/ new Vector3();\nconst _v2$3 = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\tthis.isSphere = true;\n\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box$3.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.center.copy( point );\n\n\t\t\tthis.radius = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_v1$6.subVectors( point, this.center );\n\n\t\tconst lengthSq = _v1$6.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t// calculate the minimal sphere\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\n\t\t\tconst delta = ( length - this.radius ) * 0.5;\n\n\t\t\tthis.center.addScaledVector( _v1$6, delta / length );\n\n\t\t\tthis.radius += delta;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunion( sphere ) {\n\n\t\tif ( sphere.isEmpty() ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.copy( sphere );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.center.equals( sphere.center ) === true ) {\n\n\t\t\t this.radius = Math.max( this.radius, sphere.radius );\n\n\t\t} else {\n\n\t\t\t_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$a = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal$1 = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, t );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector$a ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector$a.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t\treturn _vector$a.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector$a.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector$a.dot( this.direction );\n\t\tconst d2 = _vector$a.dot( _vector$a ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if t1 is behind the ray - if so, return null\n\t\tif ( t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector$a ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal$1.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal$1 );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal$1 );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix4 {\n\n\tconstructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tMatrix4.prototype.isMatrix4 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tcopyPosition( m ) {\n\n\t\tconst te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix3( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractRotation( m ) {\n\n\t\t// this method does not support reflection matrices\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();\n\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();\n\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();\n\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromEuler( euler ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromQuaternion( q ) {\n\n\t\treturn this.compose( _zero, q, _one );\n\n\t}\n\n\tlookAt( eye, target, up ) {\n\n\t\tconst te = this.elements;\n\n\t\t_z.subVectors( eye, target );\n\n\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t// eye and target are in the same position\n\n\t\t\t_z.z = 1;\n\n\t\t}\n\n\t\t_z.normalize();\n\t\t_x.crossVectors( up, _z );\n\n\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t// up and z are parallel\n\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t_z.x += 0.0001;\n\n\t\t\t} else {\n\n\t\t\t\t_z.z += 0.0001;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t}\n\n\t\t_x.normalize();\n\t\t_y.crossVectors( _z, _x );\n\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t}\n\n\ttranspose() {\n\n\t\tconst te = this.elements;\n\t\tlet tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tsetPosition( x, y, z ) {\n\n\t\tconst te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tinvert() {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\tscale( v ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxScaleOnAxis() {\n\n\t\tconst te = this.elements;\n\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t}\n\n\tmakeTranslation( x, y, z ) {\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x.x,\n\t\t\t\t0, 1, 0, x.y,\n\t\t\t\t0, 0, 1, x.z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationX( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationY( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationZ( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationAxis( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tconst c = Math.cos( angle );\n\t\tconst s = Math.sin( angle );\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeShear( xy, xz, yx, yz, zx, zy ) {\n\n\t\tthis.set(\n\n\t\t\t1, yx, zx, 0,\n\t\t\txy, 1, zy, 0,\n\t\t\txz, yz, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tdecompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tlet sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\tconst sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\tconst sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = this.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\tposition.x = te[ 12 ];\n\t\tposition.y = te[ 13 ];\n\t\tposition.z = te[ 14 ];\n\n\t\t// scale the rotation part\n\t\t_m1$2.copy( this );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1$2.elements[ 0 ] *= invSX;\n\t\t_m1$2.elements[ 1 ] *= invSX;\n\t\t_m1$2.elements[ 2 ] *= invSX;\n\n\t\t_m1$2.elements[ 4 ] *= invSY;\n\t\t_m1$2.elements[ 5 ] *= invSY;\n\t\t_m1$2.elements[ 6 ] *= invSY;\n\n\t\t_m1$2.elements[ 8 ] *= invSZ;\n\t\t_m1$2.elements[ 9 ] *= invSZ;\n\t\t_m1$2.elements[ 10 ] *= invSZ;\n\n\t\tquaternion.setFromRotationMatrix( _m1$2 );\n\n\t\tscale.x = sx;\n\t\tscale.y = sy;\n\t\tscale.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tmakePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = 2 * near / ( right - left );\n\t\tconst y = 2 * near / ( top - bottom );\n\n\t\tconst a = ( right + left ) / ( right - left );\n\t\tconst b = ( top + bottom ) / ( top - bottom );\n\n\t\tlet c, d;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tc = - ( far + near ) / ( far - near );\n\t\t\td = ( - 2 * far * near ) / ( far - near );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tc = - far / ( far - near );\n\t\t\td = ( - far * near ) / ( far - near );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a; \tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b; \tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c; \tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t}\n\n\tmakeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst w = 1.0 / ( right - left );\n\t\tconst h = 1.0 / ( top - bottom );\n\t\tconst p = 1.0 / ( far - near );\n\n\t\tconst x = ( right + left ) * w;\n\t\tconst y = ( top + bottom ) * h;\n\n\t\tlet z, zInv;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tz = ( far + near ) * p;\n\t\t\tzInv = - 2 * p;\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tz = near * p;\n\t\t\tzInv = - 1 * p;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\t\tte[ 8 ] = 0; \t\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0; \t\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0; \t\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0; \t\tte[ 6 ] = 0;\t\tte[ 10 ] = zInv;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0; \t\tte[ 7 ] = 0;\t\tte[ 11 ] = 0;\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n}\n\nconst _v1$5 = /*@__PURE__*/ new Vector3();\nconst _m1$2 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nconst _matrix$2 = /*@__PURE__*/ new Matrix4();\nconst _quaternion$3 = /*@__PURE__*/ new Quaternion();\n\nclass Euler {\n\n\tconstructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {\n\n\t\tthis.isEuler = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget order() {\n\n\t\treturn this._order;\n\n\t}\n\n\tset order( value ) {\n\n\t\tthis._order = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, order = this._order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t}\n\n\tcopy( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m, order = this._order, update = true ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements;\n\t\tconst m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tconst m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tconst m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromQuaternion( q, order, update ) {\n\n\t\t_matrix$2.makeRotationFromQuaternion( q );\n\n\t\treturn this.setFromRotationMatrix( _matrix$2, order, update );\n\n\t}\n\n\tsetFromVector3( v, order = this._order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order );\n\n\t}\n\n\treorder( newOrder ) {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t_quaternion$3.setFromEuler( this );\n\n\t\treturn this.setFromQuaternion( _quaternion$3, newOrder );\n\n\t}\n\n\tequals( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t}\n\n\tfromArray( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._order;\n\n\t}\n\n}\n\nEuler.DEFAULT_ORDER = 'XYZ';\n\nclass Layers {\n\n\tconstructor() {\n\n\t\tthis.mask = 1 | 0;\n\n\t}\n\n\tset( channel ) {\n\n\t\tthis.mask = ( 1 << channel | 0 ) >>> 0;\n\n\t}\n\n\tenable( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t}\n\n\tenableAll() {\n\n\t\tthis.mask = 0xffffffff | 0;\n\n\t}\n\n\ttoggle( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t}\n\n\tdisable( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t}\n\n\tdisableAll() {\n\n\t\tthis.mask = 0;\n\n\t}\n\n\ttest( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n\tisEnabled( channel ) {\n\n\t\treturn ( this.mask & ( 1 << channel | 0 ) ) !== 0;\n\n\t}\n\n}\n\nlet _object3DId = 0;\n\nconst _v1$4 = /*@__PURE__*/ new Vector3();\nconst _q1 = /*@__PURE__*/ new Quaternion();\nconst _m1$1 = /*@__PURE__*/ new Matrix4();\nconst _target = /*@__PURE__*/ new Vector3();\n\nconst _position$3 = /*@__PURE__*/ new Vector3();\nconst _scale$2 = /*@__PURE__*/ new Vector3();\nconst _quaternion$2 = /*@__PURE__*/ new Quaternion();\n\nconst _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );\nconst _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nconst _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );\n\nconst _addedEvent = { type: 'added' };\nconst _removedEvent = { type: 'removed' };\n\nconst _childaddedEvent = { type: 'childadded', child: null };\nconst _childremovedEvent = { type: 'childremoved', child: null };\n\nclass Object3D extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isObject3D = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DEFAULT_UP.clone();\n\n\t\tconst position = new Vector3();\n\t\tconst rotation = new Euler();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation._onChange( onRotationChange );\n\t\tquaternion._onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n\n\t\tthis.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.animations = [];\n\n\t\tthis.userData = {};\n\n\t}\n\n\tonBeforeShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\tonAfterShadow( /* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */ ) {}\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tonAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tthis.matrix.premultiply( matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tthis.quaternion.premultiply( q );\n\n\t\treturn this;\n\n\t}\n\n\tsetRotationFromAxisAngle( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t}\n\n\tsetRotationFromEuler( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t}\n\n\tsetRotationFromMatrix( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t}\n\n\tsetRotationFromQuaternion( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t}\n\n\trotateOnAxis( axis, angle ) {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.multiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateOnWorldAxis( axis, angle ) {\n\n\t\t// rotate object on axis in world space\n\t\t// axis is assumed to be normalized\n\t\t// method assumes no rotated parent\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.premultiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\treturn this.rotateOnAxis( _xAxis, angle );\n\n\t}\n\n\trotateY( angle ) {\n\n\t\treturn this.rotateOnAxis( _yAxis, angle );\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\treturn this.rotateOnAxis( _zAxis, angle );\n\n\t}\n\n\ttranslateOnAxis( axis, distance ) {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_v1$4.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\tthis.position.add( _v1$4.multiplyScalar( distance ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslateX( distance ) {\n\n\t\treturn this.translateOnAxis( _xAxis, distance );\n\n\t}\n\n\ttranslateY( distance ) {\n\n\t\treturn this.translateOnAxis( _yAxis, distance );\n\n\t}\n\n\ttranslateZ( distance ) {\n\n\t\treturn this.translateOnAxis( _zAxis, distance );\n\n\t}\n\n\tlocalToWorld( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t}\n\n\tworldToLocal( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );\n\n\t}\n\n\tlookAt( x, y, z ) {\n\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\t_target.copy( x );\n\n\t\t} else {\n\n\t\t\t_target.set( x, y, z );\n\n\t\t}\n\n\t\tconst parent = this.parent;\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_position$3.setFromMatrixPosition( this.matrixWorld );\n\n\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t_m1$1.lookAt( _position$3, _target, this.up );\n\n\t\t} else {\n\n\t\t\t_m1$1.lookAt( _target, _position$3, this.up );\n\n\t\t}\n\n\t\tthis.quaternion.setFromRotationMatrix( _m1$1 );\n\n\t\tif ( parent ) {\n\n\t\t\t_m1$1.extractRotation( parent.matrixWorld );\n\t\t\t_q1.setFromRotationMatrix( _m1$1 );\n\t\t\tthis.quaternion.premultiply( _q1.invert() );\n\n\t\t}\n\n\t}\n\n\tadd( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object can\\'t be added as a child of itself.', object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object && object.isObject3D ) {\n\n\t\t\tobject.removeFromParent();\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t\t_childaddedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t\t_childaddedEvent.child = null;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t\t_childremovedEvent.child = object;\n\t\t\tthis.dispatchEvent( _childremovedEvent );\n\t\t\t_childremovedEvent.child = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremoveFromParent() {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tparent.remove( this );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclear() {\n\n\t\treturn this.remove( ... this.children );\n\n\t}\n\n\tattach( object ) {\n\n\t\t// adds object as a child of this, while maintaining the object's world transform\n\n\t\t// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_m1$1.copy( this.matrixWorld ).invert();\n\n\t\tif ( object.parent !== null ) {\n\n\t\t\tobject.parent.updateWorldMatrix( true, false );\n\n\t\t\t_m1$1.multiply( object.parent.matrixWorld );\n\n\t\t}\n\n\t\tobject.applyMatrix4( _m1$1 );\n\n\t\tobject.removeFromParent();\n\t\tobject.parent = this;\n\t\tthis.children.push( object );\n\n\t\tobject.updateWorldMatrix( false, true );\n\n\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t_childaddedEvent.child = object;\n\t\tthis.dispatchEvent( _childaddedEvent );\n\t\t_childaddedEvent.child = null;\n\n\t\treturn this;\n\n\t}\n\n\tgetObjectById( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t}\n\n\tgetObjectByName( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t}\n\n\tgetObjectByProperty( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( let i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = this.children[ i ];\n\t\t\tconst object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tgetObjectsByProperty( name, value, result = [] ) {\n\n\t\tif ( this[ name ] === value ) result.push( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].getObjectsByProperty( name, value, result );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgetWorldPosition( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t}\n\n\tgetWorldQuaternion( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, target, _scale$2 );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldScale( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, _quaternion$2, target );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t}\n\n\traycast( /* raycaster, intersects */ ) {}\n\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseVisible( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseAncestors( callback ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.matrixWorldAutoUpdate === true ) {\n\n\t\t\t\tif ( this.parent === null ) {\n\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// make sure descendants are updated if required\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst child = children[ i ];\n\n\t\t\tchild.updateMatrixWorld( force );\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( updateParents === true && parent !== null ) {\n\n\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t}\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldAutoUpdate === true ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// make sure descendants are updated\n\n\t\tif ( updateChildren === true ) {\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tchild.updateWorldMatrix( false, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\t// meta is a string when called from JSON.stringify\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tconst output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tshapes: {},\n\t\t\t\tskeletons: {},\n\t\t\t\tanimations: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tconst object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\tif ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;\n\n\t\tobject.layers = this.layers.mask;\n\t\tobject.matrix = this.matrix.toArray();\n\t\tobject.up = this.up.toArray();\n\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t// object specific properties\n\n\t\tif ( this.isInstancedMesh ) {\n\n\t\t\tobject.type = 'InstancedMesh';\n\t\t\tobject.count = this.count;\n\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\tif ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();\n\n\t\t}\n\n\t\tif ( this.isBatchedMesh ) {\n\n\t\t\tobject.type = 'BatchedMesh';\n\t\t\tobject.perObjectFrustumCulled = this.perObjectFrustumCulled;\n\t\t\tobject.sortObjects = this.sortObjects;\n\n\t\t\tobject.drawRanges = this._drawRanges;\n\t\t\tobject.reservedRanges = this._reservedRanges;\n\n\t\t\tobject.visibility = this._visibility;\n\t\t\tobject.active = this._active;\n\t\t\tobject.bounds = this._bounds.map( bound => ( {\n\t\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\t\tboxMin: bound.box.min.toArray(),\n\t\t\t\tboxMax: bound.box.max.toArray(),\n\n\t\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\t\tsphereRadius: bound.sphere.radius,\n\t\t\t\tsphereCenter: bound.sphere.center.toArray()\n\t\t\t} ) );\n\n\t\t\tobject.maxInstanceCount = this._maxInstanceCount;\n\t\t\tobject.maxVertexCount = this._maxVertexCount;\n\t\t\tobject.maxIndexCount = this._maxIndexCount;\n\n\t\t\tobject.geometryInitialized = this._geometryInitialized;\n\t\t\tobject.geometryCount = this._geometryCount;\n\n\t\t\tobject.matricesTexture = this._matricesTexture.toJSON( meta );\n\n\t\t\tif ( this._colorsTexture !== null ) object.colorsTexture = this._colorsTexture.toJSON( meta );\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tobject.boundingSphere = {\n\t\t\t\t\tcenter: object.boundingSphere.center.toArray(),\n\t\t\t\t\tradius: object.boundingSphere.radius\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tobject.boundingBox = {\n\t\t\t\t\tmin: object.boundingBox.min.toArray(),\n\t\t\t\t\tmax: object.boundingBox.max.toArray()\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tfunction serialize( library, element ) {\n\n\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t}\n\n\t\t\treturn element.uuid;\n\n\t\t}\n\n\t\tif ( this.isScene ) {\n\n\t\t\tif ( this.background ) {\n\n\t\t\t\tif ( this.background.isColor ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON();\n\n\t\t\t\t} else if ( this.background.isTexture ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON( meta ).uuid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {\n\n\t\t\t\tobject.environment = this.environment.toJSON( meta ).uuid;\n\n\t\t\t}\n\n\t\t} else if ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.isSkinnedMesh ) {\n\n\t\t\tobject.bindMode = this.bindMode;\n\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\tif ( this.skeleton !== undefined ) {\n\n\t\t\t\tserialize( meta.skeletons, this.skeleton );\n\n\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\tconst uuids = [];\n\n\t\t\t\tfor ( let i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = uuids;\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.animations.length > 0 ) {\n\n\t\t\tobject.animations = [];\n\n\t\t\tfor ( let i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\t\tconst animation = this.animations[ i ];\n\n\t\t\t\tobject.animations.push( serialize( meta.animations, animation ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst geometries = extractFromCache( meta.geometries );\n\t\t\tconst materials = extractFromCache( meta.materials );\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst shapes = extractFromCache( meta.shapes );\n\t\t\tconst skeletons = extractFromCache( meta.skeletons );\n\t\t\tconst animations = extractFromCache( meta.animations );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\t\t\tif ( skeletons.length > 0 ) output.skeletons = skeletons;\n\t\t\tif ( animations.length > 0 ) output.animations = animations;\n\t\t\tif ( nodes.length > 0 ) output.nodes = nodes;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t}\n\n\tclone( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t}\n\n\tcopy( source, recursive = true ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.rotation.order = source.rotation.order;\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\tthis.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.layers.mask = source.layers.mask;\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.animations = source.animations.slice();\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tconst child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nObject3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nObject3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\nObject3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n\nconst _v0$1 = /*@__PURE__*/ new Vector3();\nconst _v1$3 = /*@__PURE__*/ new Vector3();\nconst _v2$2 = /*@__PURE__*/ new Vector3();\nconst _v3$2 = /*@__PURE__*/ new Vector3();\n\nconst _vab = /*@__PURE__*/ new Vector3();\nconst _vac = /*@__PURE__*/ new Vector3();\nconst _vbc = /*@__PURE__*/ new Vector3();\nconst _vap = /*@__PURE__*/ new Vector3();\nconst _vbp = /*@__PURE__*/ new Vector3();\nconst _vcp = /*@__PURE__*/ new Vector3();\n\nconst _v40 = /*@__PURE__*/ new Vector4();\nconst _v41 = /*@__PURE__*/ new Vector4();\nconst _v42 = /*@__PURE__*/ new Vector4();\n\nclass Triangle {\n\n\tconstructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t}\n\n\tstatic getNormal( a, b, c, target ) {\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0$1.subVectors( a, b );\n\t\ttarget.cross( _v0$1 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t}\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tstatic getBarycoord( point, a, b, c, target ) {\n\n\t\t_v0$1.subVectors( c, a );\n\t\t_v1$3.subVectors( b, a );\n\t\t_v2$2.subVectors( point, a );\n\n\t\tconst dot00 = _v0$1.dot( _v0$1 );\n\t\tconst dot01 = _v0$1.dot( _v1$3 );\n\t\tconst dot02 = _v0$1.dot( _v2$2 );\n\t\tconst dot11 = _v1$3.dot( _v1$3 );\n\t\tconst dot12 = _v1$3.dot( _v2$2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\ttarget.set( 0, 0, 0 );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t}\n\n\tstatic containsPoint( point, a, b, c ) {\n\n\t\t// if the triangle is degenerate then we can't contain a point\n\t\tif ( this.getBarycoord( point, a, b, c, _v3$2 ) === null ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn ( _v3$2.x >= 0 ) && ( _v3$2.y >= 0 ) && ( ( _v3$2.x + _v3$2.y ) <= 1 );\n\n\t}\n\n\tstatic getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {\n\n\t\tif ( this.getBarycoord( point, p1, p2, p3, _v3$2 ) === null ) {\n\n\t\t\ttarget.x = 0;\n\t\t\ttarget.y = 0;\n\t\t\tif ( 'z' in target ) target.z = 0;\n\t\t\tif ( 'w' in target ) target.w = 0;\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( v1, _v3$2.x );\n\t\ttarget.addScaledVector( v2, _v3$2.y );\n\t\ttarget.addScaledVector( v3, _v3$2.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic getInterpolatedAttribute( attr, i1, i2, i3, barycoord, target ) {\n\n\t\t_v40.setScalar( 0 );\n\t\t_v41.setScalar( 0 );\n\t\t_v42.setScalar( 0 );\n\n\t\t_v40.fromBufferAttribute( attr, i1 );\n\t\t_v41.fromBufferAttribute( attr, i2 );\n\t\t_v42.fromBufferAttribute( attr, i3 );\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( _v40, barycoord.x );\n\t\ttarget.addScaledVector( _v41, barycoord.y );\n\t\ttarget.addScaledVector( _v42, barycoord.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic isFrontFacing( a, b, c, direction ) {\n\n\t\t_v0$1.subVectors( c, b );\n\t\t_v1$3.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n\tset( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPointsAndIndices( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAttributeAndIndices( attribute, i0, i1, i2 ) {\n\n\t\tthis.a.fromBufferAttribute( attribute, i0 );\n\t\tthis.b.fromBufferAttribute( attribute, i1 );\n\t\tthis.c.fromBufferAttribute( attribute, i2 );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t}\n\n\tgetArea() {\n\n\t\t_v0$1.subVectors( this.c, this.b );\n\t\t_v1$3.subVectors( this.a, this.b );\n\n\t\treturn _v0$1.cross( _v1$3 ).length() * 0.5;\n\n\t}\n\n\tgetMidpoint( target ) {\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t}\n\n\tgetNormal( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t}\n\n\tgetPlane( target ) {\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t}\n\n\tgetBarycoord( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t}\n\n\tgetInterpolation( point, v1, v2, v3, target ) {\n\n\t\treturn Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t}\n\n\tisFrontFacing( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t}\n\n\tclosestPointToPoint( p, target ) {\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t}\n\n\tequals( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n}\n\nconst _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb( p, q, t ) {\n\n\tif ( t < 0 ) t += 1;\n\tif ( t > 1 ) t -= 1;\n\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\tif ( t < 1 / 2 ) return q;\n\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\treturn p;\n\n}\n\nclass Color {\n\n\tconstructor( r, g, b ) {\n\n\t\tthis.isColor = true;\n\n\t\tthis.r = 1;\n\t\tthis.g = 1;\n\t\tthis.b = 1;\n\n\t\treturn this.set( r, g, b );\n\n\t}\n\n\tset( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\n\t\t\tconst value = r;\n\n\t\t\tif ( value && value.isColor ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.setRGB( r, g, b );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetHex( hex, colorSpace = SRGBColorSpace ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\th = euclideanModulo( h, 1 );\n\t\ts = clamp( s, 0, 1 );\n\t\tl = clamp( l, 0, 1 );\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tconst p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tconst q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetStyle( style, colorSpace = SRGBColorSpace ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tlet m;\n\n\t\tif ( m = /^(\\w+)\\(([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tlet color;\n\t\t\tconst name = m[ 1 ];\n\t\t\tconst components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setHSL(\n\t\t\t\t\t\t\tparseFloat( color[ 1 ] ) / 360,\n\t\t\t\t\t\t\tparseFloat( color[ 2 ] ) / 100,\n\t\t\t\t\t\t\tparseFloat( color[ 3 ] ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color model ' + style );\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f\\d]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tconst hex = m[ 1 ];\n\t\t\tconst size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\treturn this.setRGB(\n\t\t\t\t\tparseInt( hex.charAt( 0 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 1 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 2 ), 16 ) / 15,\n\t\t\t\t\tcolorSpace\n\t\t\t\t);\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\treturn this.setHex( parseInt( hex, 16 ), colorSpace );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Invalid hex color ' + style );\n\n\t\t\t}\n\n\t\t} else if ( style && style.length > 0 ) {\n\n\t\t\treturn this.setColorName( style, colorSpace );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetColorName( style, colorSpace = SRGBColorSpace ) {\n\n\t\t// color keywords\n\t\tconst hex = _colorKeywords[ style.toLowerCase() ];\n\n\t\tif ( hex !== undefined ) {\n\n\t\t\t// red\n\t\t\tthis.setHex( hex, colorSpace );\n\n\t\t} else {\n\n\t\t\t// unknown color\n\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t}\n\n\tcopy( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t}\n\n\tcopySRGBToLinear( color ) {\n\n\t\tthis.r = SRGBToLinear( color.r );\n\t\tthis.g = SRGBToLinear( color.g );\n\t\tthis.b = SRGBToLinear( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tcopyLinearToSRGB( color ) {\n\n\t\tthis.r = LinearToSRGB( color.r );\n\t\tthis.g = LinearToSRGB( color.g );\n\t\tthis.b = LinearToSRGB( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tconvertSRGBToLinear() {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t}\n\n\tconvertLinearToSRGB() {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t}\n\n\tgetHex( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\treturn Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );\n\n\t}\n\n\tgetHexString( colorSpace = SRGBColorSpace ) {\n\n\t\treturn ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );\n\n\t}\n\n\tgetHSL( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tconst max = Math.max( r, g, b );\n\t\tconst min = Math.min( r, g, b );\n\n\t\tlet hue, saturation;\n\t\tconst lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tconst delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t}\n\n\tgetRGB( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\ttarget.r = _color.r;\n\t\ttarget.g = _color.g;\n\t\ttarget.b = _color.b;\n\n\t\treturn target;\n\n\t}\n\n\tgetStyle( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tif ( colorSpace !== SRGBColorSpace ) {\n\n\t\t\t// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\n\t\t\treturn `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;\n\n\t\t}\n\n\t\treturn `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;\n\n\t}\n\n\toffsetHSL( h, s, l ) {\n\n\t\tthis.getHSL( _hslA );\n\n\t\treturn this.setHSL( _hslA.h + h, _hslA.s + s, _hslA.l + l );\n\n\t}\n\n\tadd( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t}\n\n\taddColors( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t}\n\n\tlerp( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpColors( color1, color2, alpha ) {\n\n\t\tthis.r = color1.r + ( color2.r - color1.r ) * alpha;\n\t\tthis.g = color1.g + ( color2.g - color1.g ) * alpha;\n\t\tthis.b = color1.b + ( color2.b - color1.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpHSL( color, alpha ) {\n\n\t\tthis.getHSL( _hslA );\n\t\tcolor.getHSL( _hslB );\n\n\t\tconst h = lerp( _hslA.h, _hslB.h, alpha );\n\t\tconst s = lerp( _hslA.s, _hslB.s, alpha );\n\t\tconst l = lerp( _hslA.l, _hslB.l, alpha );\n\n\t\tthis.setHSL( h, s, l );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\tthis.r = v.x;\n\t\tthis.g = v.y;\n\t\tthis.b = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst r = this.r, g = this.g, b = this.b;\n\t\tconst e = m.elements;\n\n\t\tthis.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;\n\t\tthis.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;\n\t\tthis.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.r = attribute.getX( index );\n\t\tthis.g = attribute.getY( index );\n\t\tthis.b = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.getHex();\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.r;\n\t\tyield this.g;\n\t\tyield this.b;\n\n\t}\n\n}\n\nconst _color = /*@__PURE__*/ new Color();\n\nColor.NAMES = _colorKeywords;\n\nlet _materialId = 0;\n\nclass Material extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isMaterial = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _materialId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.vertexColors = false;\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\t\tthis.alphaHash = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\t\tthis.blendColor = new Color( 0, 0, 0 );\n\t\tthis.blendAlpha = 0;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.stencilWriteMask = 0xff;\n\t\tthis.stencilFunc = AlwaysStencilFunc;\n\t\tthis.stencilRef = 0;\n\t\tthis.stencilFuncMask = 0xff;\n\t\tthis.stencilFail = KeepStencilOp;\n\t\tthis.stencilZFail = KeepStencilOp;\n\t\tthis.stencilZPass = KeepStencilOp;\n\t\tthis.stencilWrite = false;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.shadowSide = null;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.dithering = false;\n\n\t\tthis.alphaToCoverage = false;\n\t\tthis.premultipliedAlpha = false;\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.visible = true;\n\n\t\tthis.toneMapped = true;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\n\t\tthis._alphaTest = 0;\n\n\t}\n\n\tget alphaTest() {\n\n\t\treturn this._alphaTest;\n\n\t}\n\n\tset alphaTest( value ) {\n\n\t\tif ( this._alphaTest > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._alphaTest = value;\n\n\t}\n\n\t// onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}\n\n\tonBeforeCompile( /* shaderobject, renderer */ ) {}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.onBeforeCompile.toString();\n\n\t}\n\n\tsetValues( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( const key in values ) {\n\n\t\t\tconst newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRootObject ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.sheen !== undefined ) data.sheen = this.sheen;\n\t\tif ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();\n\t\tif ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;\n\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\tif ( this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\tif ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;\n\t\tif ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\tif ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;\n\t\tif ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\tif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {\n\n\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {\n\n\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {\n\n\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;\n\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.dispersion !== undefined ) data.dispersion = this.dispersion;\n\n\t\tif ( this.iridescence !== undefined ) data.iridescence = this.iridescence;\n\t\tif ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;\n\t\tif ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n\n\t\tif ( this.iridescenceMap && this.iridescenceMap.isTexture ) {\n\n\t\t\tdata.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {\n\n\t\t\tdata.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;\n\t\tif ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;\n\n\t\tif ( this.anisotropyMap && this.anisotropyMap.isTexture ) {\n\n\t\t\tdata.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\n\t\tif ( this.lightMap && this.lightMap.isTexture ) {\n\n\t\t\tdata.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\n\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n\t\t}\n\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\tif ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;\n\t\tif ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\n\t\t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\n\t\t}\n\n\t\tif ( this.envMapRotation !== undefined ) data.envMapRotation = this.envMapRotation.toArray();\n\t\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n\t\tif ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;\n\t\tif ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;\n\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.transmission !== undefined ) data.transmission = this.transmission;\n\t\tif ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;\n\t\tif ( this.thickness !== undefined ) data.thickness = this.thickness;\n\t\tif ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;\n\t\tif ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;\n\t\tif ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors === true ) data.vertexColors = true;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = true;\n\n\t\tif ( this.blendSrc !== SrcAlphaFactor ) data.blendSrc = this.blendSrc;\n\t\tif ( this.blendDst !== OneMinusSrcAlphaFactor ) data.blendDst = this.blendDst;\n\t\tif ( this.blendEquation !== AddEquation ) data.blendEquation = this.blendEquation;\n\t\tif ( this.blendSrcAlpha !== null ) data.blendSrcAlpha = this.blendSrcAlpha;\n\t\tif ( this.blendDstAlpha !== null ) data.blendDstAlpha = this.blendDstAlpha;\n\t\tif ( this.blendEquationAlpha !== null ) data.blendEquationAlpha = this.blendEquationAlpha;\n\t\tif ( this.blendColor && this.blendColor.isColor ) data.blendColor = this.blendColor.getHex();\n\t\tif ( this.blendAlpha !== 0 ) data.blendAlpha = this.blendAlpha;\n\n\t\tif ( this.depthFunc !== LessEqualDepth ) data.depthFunc = this.depthFunc;\n\t\tif ( this.depthTest === false ) data.depthTest = this.depthTest;\n\t\tif ( this.depthWrite === false ) data.depthWrite = this.depthWrite;\n\t\tif ( this.colorWrite === false ) data.colorWrite = this.colorWrite;\n\n\t\tif ( this.stencilWriteMask !== 0xff ) data.stencilWriteMask = this.stencilWriteMask;\n\t\tif ( this.stencilFunc !== AlwaysStencilFunc ) data.stencilFunc = this.stencilFunc;\n\t\tif ( this.stencilRef !== 0 ) data.stencilRef = this.stencilRef;\n\t\tif ( this.stencilFuncMask !== 0xff ) data.stencilFuncMask = this.stencilFuncMask;\n\t\tif ( this.stencilFail !== KeepStencilOp ) data.stencilFail = this.stencilFail;\n\t\tif ( this.stencilZFail !== KeepStencilOp ) data.stencilZFail = this.stencilZFail;\n\t\tif ( this.stencilZPass !== KeepStencilOp ) data.stencilZPass = this.stencilZPass;\n\t\tif ( this.stencilWrite === true ) data.stencilWrite = this.stencilWrite;\n\n\t\t// rotation (SpriteMaterial)\n\t\tif ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\tif ( this.polygonOffset === true ) data.polygonOffset = true;\n\t\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tif ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.alphaHash === true ) data.alphaHash = true;\n\t\tif ( this.alphaToCoverage === true ) data.alphaToCoverage = true;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = true;\n\t\tif ( this.forceSinglePass === true ) data.forceSinglePass = true;\n\n\t\tif ( this.wireframe === true ) data.wireframe = true;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\tif ( this.flatShading === true ) data.flatShading = true;\n\n\t\tif ( this.visible === false ) data.visible = false;\n\n\t\tif ( this.toneMapped === false ) data.toneMapped = false;\n\n\t\tif ( this.fog === false ) data.fog = false;\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\tthis.blendColor.copy( source.blendColor );\n\t\tthis.blendAlpha = source.blendAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\tthis.stencilFunc = source.stencilFunc;\n\t\tthis.stencilRef = source.stencilRef;\n\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\tthis.stencilFail = source.stencilFail;\n\t\tthis.stencilZFail = source.stencilZFail;\n\t\tthis.stencilZPass = source.stencilZPass;\n\t\tthis.stencilWrite = source.stencilWrite;\n\n\t\tconst srcPlanes = source.clippingPlanes;\n\t\tlet dstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tconst n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\t\tthis.clipIntersection = source.clipIntersection;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tthis.shadowSide = source.shadowSide;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.dithering = source.dithering;\n\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaHash = source.alphaHash;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\tthis.forceSinglePass = source.forceSinglePass;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.toneMapped = source.toneMapped;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tonBuild( /* shaderobject, renderer */ ) {\n\n\t\tconsole.warn( 'Material: onBuild() has been removed.' ); // @deprecated, r166\n\n\t}\n\n}\n\nclass MeshBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshBasicMaterial = true;\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst _tables = /*@__PURE__*/ _generateTables();\n\nfunction _generateTables() {\n\n\t// float32 to float16 helpers\n\n\tconst buffer = new ArrayBuffer( 4 );\n\tconst floatView = new Float32Array( buffer );\n\tconst uint32View = new Uint32Array( buffer );\n\n\tconst baseTable = new Uint32Array( 512 );\n\tconst shiftTable = new Uint32Array( 512 );\n\n\tfor ( let i = 0; i < 256; ++ i ) {\n\n\t\tconst e = i - 127;\n\n\t\t// very small number (0, -0)\n\n\t\tif ( e < - 27 ) {\n\n\t\t\tbaseTable[ i ] = 0x0000;\n\t\t\tbaseTable[ i | 0x100 ] = 0x8000;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// small number (denorm)\n\n\t\t} else if ( e < - 14 ) {\n\n\t\t\tbaseTable[ i ] = 0x0400 >> ( - e - 14 );\n\t\t\tbaseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;\n\t\t\tshiftTable[ i ] = - e - 1;\n\t\t\tshiftTable[ i | 0x100 ] = - e - 1;\n\n\t\t\t// normal number\n\n\t\t} else if ( e <= 15 ) {\n\n\t\t\tbaseTable[ i ] = ( e + 15 ) << 10;\n\t\t\tbaseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t\t// large number (Infinity, -Infinity)\n\n\t\t} else if ( e < 128 ) {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// stay (NaN, Infinity, -Infinity)\n\n\t\t} else {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t}\n\n\t}\n\n\t// float16 to float32 helpers\n\n\tconst mantissaTable = new Uint32Array( 2048 );\n\tconst exponentTable = new Uint32Array( 64 );\n\tconst offsetTable = new Uint32Array( 64 );\n\n\tfor ( let i = 1; i < 1024; ++ i ) {\n\n\t\tlet m = i << 13; // zero pad mantissa bits\n\t\tlet e = 0; // zero exponent\n\n\t\t// normalized\n\t\twhile ( ( m & 0x00800000 ) === 0 ) {\n\n\t\t\tm <<= 1;\n\t\t\te -= 0x00800000; // decrement exponent\n\n\t\t}\n\n\t\tm &= ~ 0x00800000; // clear leading 1 bit\n\t\te += 0x38800000; // adjust bias\n\n\t\tmantissaTable[ i ] = m | e;\n\n\t}\n\n\tfor ( let i = 1024; i < 2048; ++ i ) {\n\n\t\tmantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );\n\n\t}\n\n\tfor ( let i = 1; i < 31; ++ i ) {\n\n\t\texponentTable[ i ] = i << 23;\n\n\t}\n\n\texponentTable[ 31 ] = 0x47800000;\n\texponentTable[ 32 ] = 0x80000000;\n\n\tfor ( let i = 33; i < 63; ++ i ) {\n\n\t\texponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );\n\n\t}\n\n\texponentTable[ 63 ] = 0xc7800000;\n\n\tfor ( let i = 1; i < 64; ++ i ) {\n\n\t\tif ( i !== 32 ) {\n\n\t\t\toffsetTable[ i ] = 1024;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tfloatView: floatView,\n\t\tuint32View: uint32View,\n\t\tbaseTable: baseTable,\n\t\tshiftTable: shiftTable,\n\t\tmantissaTable: mantissaTable,\n\t\texponentTable: exponentTable,\n\t\toffsetTable: offsetTable\n\t};\n\n}\n\n// float32 to float16\n\nfunction toHalfFloat( val ) {\n\n\tif ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );\n\n\tval = clamp( val, - 65504, 65504 );\n\n\t_tables.floatView[ 0 ] = val;\n\tconst f = _tables.uint32View[ 0 ];\n\tconst e = ( f >> 23 ) & 0x1ff;\n\treturn _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );\n\n}\n\n// float16 to float32\n\nfunction fromHalfFloat( val ) {\n\n\tconst m = val >> 10;\n\t_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];\n\treturn _tables.floatView[ 0 ];\n\n}\n\nconst DataUtils = {\n\ttoHalfFloat: toHalfFloat,\n\tfromHalfFloat: fromHalfFloat,\n};\n\nconst _vector$9 = /*@__PURE__*/ new Vector3();\nconst _vector2$1 = /*@__PURE__*/ new Vector2();\n\nclass BufferAttribute {\n\n\tconstructor( array, itemSize, normalized = false ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.isBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRanges = [];\n\t\tthis.gpuType = FloatType;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.usage = source.usage;\n\t\tthis.gpuType = source.gpuType;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( let i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyArray( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tif ( this.itemSize === 2 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector2$1.fromBufferAttribute( this, i );\n\t\t\t\t_vector2$1.applyMatrix3( m );\n\n\t\t\t\tthis.setXY( i, _vector2$1.x, _vector2$1.y );\n\n\t\t\t}\n\n\t\t} else if ( this.itemSize === 3 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector$9.fromBufferAttribute( this, i );\n\t\t\t\t_vector$9.applyMatrix3( m );\n\n\t\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$9.fromBufferAttribute( this, i );\n\n\t\t\t_vector$9.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\t// Matching BufferAttribute constructor, do not normalize the array.\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.itemSize + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.array[ index * this.itemSize + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.array[ index * this.itemSize ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.array[ index * this.itemSize + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.array[ index * this.itemSize + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.array[ index * this.itemSize + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.from( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( this.usage !== StaticDrawUsage ) data.usage = this.usage;\n\n\t\treturn data;\n\n\t}\n\n}\n\n//\n\nclass Int8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8ClampedArray( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t\tthis.isFloat16BufferAttribute = true;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = fromHalfFloat( this.array[ index * this.itemSize ] );\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = toHalfFloat( x );\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\t\tthis.array[ index + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nclass Float32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nlet _id$1 = 0;\n\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box$2 = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector$8 = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBufferGeometry = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id$1 ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.indirect = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\t\tthis.morphTargetsRelative = false;\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\tthis.userData = {};\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tconst l = Math.min( points.length, positionAttribute.count ); // make sure data do not exceed buffer size\n\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box$2.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.min, _box$2.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( this.boundingBox.max, _box$2.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$2.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$2.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box$2.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$2.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box$2.expandByPoint( _vector$8 );\n\n\t\t\t\t\t\t_vector$8.addVectors( _box$2.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box$2.expandByPoint( _vector$8 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box$2.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box$2.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box$2.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector$8.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector$8.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector$8.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector$8.fromBufferAttribute( normals, i );\n\n\t\t\t_vector$8.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t}\n\n\t}\n\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nconst _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();\nconst _ray$3 = /*@__PURE__*/ new Ray();\nconst _sphere$6 = /*@__PURE__*/ new Sphere();\nconst _sphereHitAt = /*@__PURE__*/ new Vector3();\n\nconst _vA$1 = /*@__PURE__*/ new Vector3();\nconst _vB$1 = /*@__PURE__*/ new Vector3();\nconst _vC$1 = /*@__PURE__*/ new Vector3();\n\nconst _tempA = /*@__PURE__*/ new Vector3();\nconst _morphA = /*@__PURE__*/ new Vector3();\n\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\n\nclass Mesh extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isMesh = true;\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.attributes.position;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\n\t\ttarget.fromBufferAttribute( position, index );\n\n\t\tconst morphInfluences = this.morphTargetInfluences;\n\n\t\tif ( morphPosition && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morphAttribute, index );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( target ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttarget.add( _morphA );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$6.copy( geometry.boundingSphere );\n\t\t_sphere$6.applyMatrix4( matrixWorld );\n\n\t\t// check distance from ray origin to bounding sphere\n\n\t\t_ray$3.copy( raycaster.ray ).recast( raycaster.near );\n\n\t\tif ( _sphere$6.containsPoint( _ray$3.origin ) === false ) {\n\n\t\t\tif ( _ray$3.intersectSphere( _sphere$6, _sphereHitAt ) === null ) return;\n\n\t\t\tif ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;\n\n\t\t}\n\n\t\t// convert ray to local space of mesh\n\n\t\t_inverseMatrix$3.copy( matrixWorld ).invert();\n\t\t_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$3 );\n\n\t}\n\n\t_computeIntersections( raycaster, intersects, rayLocalSpace ) {\n\n\t\tlet intersection;\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.attributes.position;\n\t\tconst uv = geometry.attributes.uv;\n\t\tconst uv1 = geometry.attributes.uv1;\n\t\tconst normal = geometry.attributes.normal;\n\t\tconst groups = geometry.groups;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = i;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection$1( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {\n\n\tobject.getVertexPosition( a, _vA$1 );\n\tobject.getVertexPosition( b, _vB$1 );\n\tobject.getVertexPosition( c, _vC$1 );\n\n\tconst intersection = checkIntersection$1( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tconst barycoord = new Vector3();\n\t\tTriangle.getBarycoord( _intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord );\n\n\t\tif ( uv ) {\n\n\t\t\tintersection.uv = Triangle.getInterpolatedAttribute( uv, a, b, c, barycoord, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\tintersection.uv1 = Triangle.getInterpolatedAttribute( uv1, a, b, c, barycoord, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\tintersection.normal = Triangle.getInterpolatedAttribute( normal, a, b, c, barycoord, new Vector3() );\n\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.barycoord = barycoord;\n\n\t}\n\n\treturn intersection;\n\n}\n\nclass BoxGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n\t}\n\n}\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms( src ) {\n\n\tconst dst = {};\n\n\tfor ( const u in src ) {\n\n\t\tdst[ u ] = {};\n\n\t\tfor ( const p in src[ u ] ) {\n\n\t\t\tconst property = src[ u ][ p ];\n\n\t\t\tif ( property && ( property.isColor ||\n\t\t\t\tproperty.isMatrix3 || property.isMatrix4 ||\n\t\t\t\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\n\t\t\t\tproperty.isTexture || property.isQuaternion ) ) {\n\n\t\t\t\tif ( property.isRenderTargetTexture ) {\n\n\t\t\t\t\tconsole.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );\n\t\t\t\t\tdst[ u ][ p ] = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdst[ u ][ p ] = property.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( Array.isArray( property ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.slice();\n\n\t\t\t} else {\n\n\t\t\t\tdst[ u ][ p ] = property;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction mergeUniforms( uniforms ) {\n\n\tconst merged = {};\n\n\tfor ( let u = 0; u < uniforms.length; u ++ ) {\n\n\t\tconst tmp = cloneUniforms( uniforms[ u ] );\n\n\t\tfor ( const p in tmp ) {\n\n\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t}\n\n\t}\n\n\treturn merged;\n\n}\n\nfunction cloneUniformsGroups( src ) {\n\n\tconst dst = [];\n\n\tfor ( let u = 0; u < src.length; u ++ ) {\n\n\t\tdst.push( src[ u ].clone() );\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction getUnlitUniformColorSpace( renderer ) {\n\n\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\tif ( currentRenderTarget === null ) {\n\n\t\t// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398\n\t\treturn renderer.outputColorSpace;\n\n\t}\n\n\t// https://github.com/mrdoob/three.js/issues/27868\n\tif ( currentRenderTarget.isXRRenderTarget === true ) {\n\n\t\treturn currentRenderTarget.texture.colorSpace;\n\n\t}\n\n\treturn ColorManagement.workingColorSpace;\n\n}\n\n// Legacy\n\nconst UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\nclass ShaderMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShaderMaterial = true;\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\t\tthis.uniformsGroups = [];\n\n\t\tthis.vertexShader = default_vertex;\n\t\tthis.fragmentShader = default_fragment;\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.forceSinglePass = true;\n\n\t\tthis.extensions = {\n\t\t\tclipCullDistance: false, // set to use vertex shader clipping\n\t\t\tmultiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv1': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\t\tthis.uniformsNeedUpdate = false;\n\n\t\tthis.glslVersion = null;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = cloneUniforms( source.uniforms );\n\t\tthis.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );\n\n\t\tthis.defines = Object.assign( {}, source.defines );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.extensions = Object.assign( {}, source.extensions );\n\n\t\tthis.glslVersion = source.glslVersion;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.glslVersion = this.glslVersion;\n\t\tdata.uniforms = {};\n\n\t\tfor ( const name in this.uniforms ) {\n\n\t\t\tconst uniform = this.uniforms[ name ];\n\t\t\tconst value = uniform.value;\n\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 't',\n\t\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isColor ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'c',\n\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v2',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\n\t\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\tdata.lights = this.lights;\n\t\tdata.clipping = this.clipping;\n\n\t\tconst extensions = {};\n\n\t\tfor ( const key in this.extensions ) {\n\n\t\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t\t}\n\n\t\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass Camera extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isCamera = true;\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t\tthis.projectionMatrix = new Matrix4();\n\t\tthis.projectionMatrixInverse = new Matrix4();\n\n\t\tthis.coordinateSystem = WebGLCoordinateSystem;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\tthis.coordinateSystem = source.coordinateSystem;\n\n\t\treturn this;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\treturn super.getWorldDirection( target ).negate();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tsuper.updateWorldMatrix( updateParents, updateChildren );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _v3$1 = /*@__PURE__*/ new Vector3();\nconst _minTarget = /*@__PURE__*/ new Vector2();\nconst _maxTarget = /*@__PURE__*/ new Vector2();\n\n\nclass PerspectiveCamera extends Camera {\n\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isPerspectiveCamera = true;\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\tgetEffectiveFOV() {\n\n\t\treturn RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.\n\t * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.\n\t */\n\tgetViewBounds( distance, minTarget, maxTarget ) {\n\n\t\t_v3$1.set( - 1, - 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tminTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );\n\n\t\t_v3$1.set( 1, 1, 0.5 ).applyMatrix4( this.projectionMatrixInverse );\n\n\t\tmaxTarget.set( _v3$1.x, _v3$1.y ).multiplyScalar( - distance / _v3$1.z );\n\n\t}\n\n\t/**\n\t * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.\n\t * Copies the result into the target Vector2, where x is width and y is height.\n\t */\n\tgetViewSize( distance, target ) {\n\n\t\tthis.getViewBounds( distance, _minTarget, _maxTarget );\n\n\t\treturn target.subVectors( _maxTarget, _minTarget );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst fov = - 90; // negative fov is not an error\nconst aspect = 1;\n\nclass CubeCamera extends Object3D {\n\n\tconstructor( near, far, renderTarget ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.coordinateSystem = null;\n\t\tthis.activeMipmapLevel = 0;\n\n\t\tconst cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.layers = this.layers;\n\t\tthis.add( cameraPX );\n\n\t\tconst cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.layers = this.layers;\n\t\tthis.add( cameraNX );\n\n\t\tconst cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.layers = this.layers;\n\t\tthis.add( cameraPY );\n\n\t\tconst cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.layers = this.layers;\n\t\tthis.add( cameraNY );\n\n\t\tconst cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.layers = this.layers;\n\t\tthis.add( cameraPZ );\n\n\t\tconst cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.layers = this.layers;\n\t\tthis.add( cameraNZ );\n\n\t}\n\n\tupdateCoordinateSystem() {\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tconst cameras = this.children.concat();\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;\n\n\t\tfor ( const camera of cameras ) this.remove( camera );\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, 1, 0 );\n\t\t\tcameraPX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, 1, 0 );\n\t\t\tcameraNX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, - 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tfor ( const camera of cameras ) {\n\n\t\t\tthis.add( camera );\n\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\tupdate( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tconst { renderTarget, activeMipmapLevel } = this;\n\n\t\tif ( this.coordinateSystem !== renderer.coordinateSystem ) {\n\n\t\t\tthis.coordinateSystem = renderer.coordinateSystem;\n\n\t\t\tthis.updateCoordinateSystem();\n\n\t\t}\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\tconst currentActiveCubeFace = renderer.getActiveCubeFace();\n\t\tconst currentActiveMipmapLevel = renderer.getActiveMipmapLevel();\n\n\t\tconst currentXrEnabled = renderer.xr.enabled;\n\n\t\trenderer.xr.enabled = false;\n\n\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderer.setRenderTarget( renderTarget, 0, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPX );\n\n\t\trenderer.setRenderTarget( renderTarget, 1, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNX );\n\n\t\trenderer.setRenderTarget( renderTarget, 2, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPY );\n\n\t\trenderer.setRenderTarget( renderTarget, 3, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNY );\n\n\t\trenderer.setRenderTarget( renderTarget, 4, activeMipmapLevel );\n\t\trenderer.render( scene, cameraPZ );\n\n\t\t// mipmaps are generated during the last call of render()\n\t\t// at this point, all sides of the cube render target are defined\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderer.setRenderTarget( renderTarget, 5, activeMipmapLevel );\n\t\trenderer.render( scene, cameraNZ );\n\n\t\trenderer.setRenderTarget( currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\n\t\trenderTarget.texture.needsPMREMUpdate = true;\n\n\t}\n\n}\n\nclass CubeTexture extends Texture {\n\n\tconstructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tsuper( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tget images() {\n\n\t\treturn this.image;\n\n\t}\n\n\tset images( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n}\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, size, options );\n\n\t\tthis.isWebGLCubeRenderTarget = true;\n\n\t\tconst image = { width: size, height: size, depth: 1 };\n\t\tconst images = [ image, image, image, image, image, image ];\n\n\t\tthis.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n\t\t// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture ) {\n\n\t\tthis.texture.type = texture.type;\n\t\tthis.texture.colorSpace = texture.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\tthis.texture.minFilter = texture.minFilter;\n\t\tthis.texture.magFilter = texture.magFilter;\n\n\t\tconst shader = {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t};\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\tname: 'CubemapFromEquirect',\n\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tside: BackSide,\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tmaterial.uniforms.tEquirect.value = texture;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst currentMinFilter = texture.minFilter;\n\n\t\t// Avoid blurred poles\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\t\tcamera.update( renderer, mesh );\n\n\t\ttexture.minFilter = currentMinFilter;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n\tclear( renderer, color, depth, stencil ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( this, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n}\n\nclass FogExp2 {\n\n\tconstructor( color, density = 0.00025 ) {\n\n\t\tthis.isFogExp2 = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = density;\n\n\t}\n\n\tclone() {\n\n\t\treturn new FogExp2( this.color, this.density );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tname: this.name,\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t}\n\n}\n\nclass Fog {\n\n\tconstructor( color, near = 1, far = 1000 ) {\n\n\t\tthis.isFog = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Fog( this.color, this.near, this.far );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tname: this.name,\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t}\n\n}\n\nclass Scene extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isScene = true;\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.environment = null;\n\t\tthis.fog = null;\n\n\t\tthis.backgroundBlurriness = 0;\n\t\tthis.backgroundIntensity = 1;\n\t\tthis.backgroundRotation = new Euler();\n\n\t\tthis.environmentIntensity = 1;\n\t\tthis.environmentRotation = new Euler();\n\n\t\tthis.overrideMaterial = null;\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.environment !== null ) this.environment = source.environment.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\n\t\tthis.backgroundBlurriness = source.backgroundBlurriness;\n\t\tthis.backgroundIntensity = source.backgroundIntensity;\n\t\tthis.backgroundRotation.copy( source.backgroundRotation );\n\n\t\tthis.environmentIntensity = source.environmentIntensity;\n\t\tthis.environmentRotation.copy( source.environmentRotation );\n\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n\t\tif ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;\n\t\tif ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;\n\t\tdata.object.backgroundRotation = this.backgroundRotation.toArray();\n\n\t\tif ( this.environmentIntensity !== 1 ) data.object.environmentIntensity = this.environmentIntensity;\n\t\tdata.object.environmentRotation = this.environmentRotation.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InterleavedBuffer {\n\n\tconstructor( array, stride ) {\n\n\t\tthis.isInterleavedBuffer = true;\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRanges = [];\n\n\t\tthis.version = 0;\n\n\t\tthis.uuid = generateUUID();\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\taddUpdateRange( start, count ) {\n\n\t\tthis.updateRanges.push( { start, count } );\n\n\t}\n\n\tclearUpdateRanges() {\n\n\t\tthis.updateRanges.length = 0;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( let i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;\n\n\t\t}\n\n\t\tconst array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );\n\n\t\tconst ib = new this.constructor( array, this.stride );\n\t\tib.setUsage( this.usage );\n\n\t\treturn ib;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\t// generate UUID for array buffer if necessary\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );\n\n\t\t}\n\n\t\t//\n\n\t\treturn {\n\t\t\tuuid: this.uuid,\n\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tstride: this.stride\n\t\t};\n\n\t}\n\n}\n\nconst _vector$7 = /*@__PURE__*/ new Vector3();\n\nclass InterleavedBufferAttribute {\n\n\tconstructor( interleavedBuffer, itemSize, offset, normalized = false ) {\n\n\t\tthis.isInterleavedBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized;\n\n\t}\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t}\n\n\tget array() {\n\n\t\treturn this.data.array;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tthis.data.needsUpdate = value;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.data.count; i < l; i ++ ) {\n\n\t\t\t_vector$7.fromBufferAttribute( this, i );\n\n\t\t\t_vector$7.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$7.fromBufferAttribute( this, i );\n\n\t\t\t_vector$7.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$7.fromBufferAttribute( this, i );\n\n\t\t\t_vector$7.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index, component ) {\n\n\t\tlet value = this.array[ index * this.data.stride + this.offset + component ];\n\n\t\tif ( this.normalized ) value = denormalize( value, this.array );\n\n\t\treturn value;\n\n\t}\n\n\tsetComponent( index, component, value ) {\n\n\t\tif ( this.normalized ) value = normalize( value, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + component ] = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.data.array[ index * this.data.stride + this.offset ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );\n\n\t\t} else {\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );\n\n\t\t\t}\n\n\t\t\treturn new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );\n\n\t\t}\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// de-interleave data and save it as an ordinary buffer attribute for now\n\n\t\t\treturn {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t} else {\n\n\t\t\t// save as true interleaved attribute\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\tdata: this.data.uuid,\n\t\t\t\toffset: this.offset,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n\nclass SpriteMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isSpriteMaterial = true;\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/ new Vector3();\nconst _worldScale = /*@__PURE__*/ new Vector3();\nconst _mvPosition = /*@__PURE__*/ new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/ new Vector2();\nconst _rotatedPosition = /*@__PURE__*/ new Vector2();\nconst _viewWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _uvA = /*@__PURE__*/ new Vector2();\nconst _uvB = /*@__PURE__*/ new Vector2();\nconst _uvC = /*@__PURE__*/ new Vector2();\n\nclass Sprite extends Object3D {\n\n\tconstructor( material = new SpriteMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isSprite = true;\n\n\t\tthis.type = 'Sprite';\n\n\t\tif ( _geometry === undefined ) {\n\n\t\t\t_geometry = new BufferGeometry();\n\n\t\t\tconst float32Array = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5, 0, 0, 0,\n\t\t\t\t0.5, - 0.5, 0, 1, 0,\n\t\t\t\t0.5, 0.5, 0, 1, 1,\n\t\t\t\t- 0.5, 0.5, 0, 0, 1\n\t\t\t] );\n\n\t\t\tconst interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\t\t\t_geometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\t\t_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\t\t_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\t}\n\n\t\tthis.geometry = _geometry;\n\t\tthis.material = material;\n\n\t\tthis.center = new Vector2( 0.5, 0.5 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.' );\n\n\t\t}\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\n\t\t_viewWorldMatrix.copy( raycaster.camera.matrixWorld );\n\t\tthis.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );\n\n\t\t_mvPosition.setFromMatrixPosition( this.modelViewMatrix );\n\n\t\tif ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {\n\n\t\t\t_worldScale.multiplyScalar( - _mvPosition.z );\n\n\t\t}\n\n\t\tconst rotation = this.material.rotation;\n\t\tlet sin, cos;\n\n\t\tif ( rotation !== 0 ) {\n\n\t\t\tcos = Math.cos( rotation );\n\t\t\tsin = Math.sin( rotation );\n\n\t\t}\n\n\t\tconst center = this.center;\n\n\t\ttransformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\n\t\t_uvA.set( 0, 0 );\n\t\t_uvB.set( 1, 0 );\n\t\t_uvC.set( 1, 1 );\n\n\t\t// check first triangle\n\t\tlet intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );\n\n\t\tif ( intersect === null ) {\n\n\t\t\t// check second triangle\n\t\t\ttransformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\t\t_uvB.set( 0, 1 );\n\n\t\t\tintersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );\n\t\t\tif ( intersect === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( _intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectPoint.clone(),\n\t\t\tuv: Triangle.getInterpolation( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),\n\t\t\tface: null,\n\t\t\tobject: this\n\n\t\t} );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\tthis.material = source.material;\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\n\n\t// compute position in camera space\n\t_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\n\n\t// to check if rotation is not zero\n\tif ( sin !== undefined ) {\n\n\t\t_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );\n\t\t_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );\n\n\t} else {\n\n\t\t_rotatedPosition.copy( _alignedPosition );\n\n\t}\n\n\n\tvertexPosition.copy( mvPosition );\n\tvertexPosition.x += _rotatedPosition.x;\n\tvertexPosition.y += _rotatedPosition.y;\n\n\t// transform to world space\n\tvertexPosition.applyMatrix4( _viewWorldMatrix );\n\n}\n\nconst _v1$2 = /*@__PURE__*/ new Vector3();\nconst _v2$1 = /*@__PURE__*/ new Vector3();\n\nclass LOD extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis._currentLevel = 0;\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tisLOD: {\n\t\t\t\tvalue: true,\n\t\t\t}\n\t\t} );\n\n\t\tthis.autoUpdate = true;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tconst levels = source.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance, level.hysteresis );\n\n\t\t}\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\taddLevel( object, distance = 0, hysteresis = 0 ) {\n\n\t\tdistance = Math.abs( distance );\n\n\t\tconst levels = this.levels;\n\n\t\tlet l;\n\n\t\tfor ( l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );\n\n\t\tthis.add( object );\n\n\t\treturn this;\n\n\t}\n\n\tremoveLevel( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0; i < levels.length; i ++ ) {\n\n\t\t\tif ( levels[ i ].distance === distance ) {\n\n\t\t\t\tconst removedElements = levels.splice( i, 1 );\n\t\t\t\tthis.remove( removedElements[ 0 ].object );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tgetCurrentLevel() {\n\n\t\treturn this._currentLevel;\n\n\t}\n\n\n\n\tgetObjectForDistance( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance < levelDistance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo( _v1$2 );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 1 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t_v2$1.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;\n\n\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance >= levelDistance ) {\n\n\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._currentLevel = i - 1;\n\n\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.autoUpdate === false ) data.object.autoUpdate = false;\n\n\t\tdata.object.levels = [];\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance,\n\t\t\t\thysteresis: level.hysteresis\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _basePosition = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\n\nconst _vector3 = /*@__PURE__*/ new Vector3();\nconst _matrix4 = /*@__PURE__*/ new Matrix4();\nconst _vertex = /*@__PURE__*/ new Vector3();\n\nconst _sphere$5 = /*@__PURE__*/ new Sphere();\nconst _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();\nconst _ray$2 = /*@__PURE__*/ new Ray();\n\nclass SkinnedMesh extends Mesh {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkinnedMesh = true;\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = AttachedBindMode;\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingBox.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tthis.getVertexPosition( i, _vertex );\n\t\t\tthis.boundingSphere.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.bindMode = source.bindMode;\n\t\tthis.bindMatrix.copy( source.bindMatrix );\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\n\n\t\tthis.skeleton = source.skeleton;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$5.copy( this.boundingSphere );\n\t\t_sphere$5.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$5 ) === false ) return;\n\n\t\t// convert ray to local space of skinned mesh\n\n\t\t_inverseMatrix$2.copy( matrixWorld ).invert();\n\t\t_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tif ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$2 );\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tsuper.getVertexPosition( index, target );\n\n\t\tthis.applyBoneTransform( index, target );\n\n\t\treturn target;\n\n\t}\n\n\tbind( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.copy( bindMatrix ).invert();\n\n\t}\n\n\tpose() {\n\n\t\tthis.skeleton.pose();\n\n\t}\n\n\tnormalizeSkinWeights() {\n\n\t\tconst vector = new Vector4();\n\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.fromBufferAttribute( skinWeight, i );\n\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.bindMode === AttachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.matrixWorld ).invert();\n\n\t\t} else if ( this.bindMode === DetachedBindMode ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.bindMatrix ).invert();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t}\n\n\tapplyBoneTransform( index, vector ) {\n\n\t\tconst skeleton = this.skeleton;\n\t\tconst geometry = this.geometry;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_basePosition.copy( vector ).applyMatrix4( this.bindMatrix );\n\n\t\tvector.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\n\t\t\t\t_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\tvector.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn vector.applyMatrix4( this.bindMatrixInverse );\n\n\t}\n\n}\n\nclass Bone extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBone = true;\n\n\t\tthis.type = 'Bone';\n\n\t}\n\n}\n\nclass DataTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isDataTexture = true;\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\n\nclass Skeleton {\n\n\tconstructor( bones = [], boneInverses = [] ) {\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.bones = bones.slice( 0 );\n\t\tthis.boneInverses = boneInverses;\n\t\tthis.boneMatrices = null;\n\n\t\tthis.boneTexture = null;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\n\n\t\t// calculate inverse bone matrices if necessary\n\n\t\tif ( boneInverses.length === 0 ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\t// handle special case\n\n\t\t\tif ( bones.length !== boneInverses.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcalculateInverses() {\n\n\t\tthis.boneInverses.length = 0;\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\tpose() {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== null ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t}\n\n\tcomputeBoneTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tboneMatrices.set( this.boneMatrices ); // copy current values\n\n\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\tboneTexture.needsUpdate = true;\n\n\t\tthis.boneMatrices = boneMatrices;\n\t\tthis.boneTexture = boneTexture;\n\n\t\treturn this;\n\n\t}\n\n\tgetBoneByName( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tdispose( ) {\n\n\t\tif ( this.boneTexture !== null ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = null;\n\n\t\t}\n\n\t}\n\n\tfromJSON( json, bones ) {\n\n\t\tthis.uuid = json.uuid;\n\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\n\n\t\t\tconst uuid = json.bones[ i ];\n\t\t\tlet bone = bones[ uuid ];\n\n\t\t\tif ( bone === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\n\t\t\t\tbone = new Bone();\n\n\t\t\t}\n\n\t\t\tthis.bones.push( bone );\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\n\n\t\t}\n\n\t\tthis.init();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Skeleton',\n\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t},\n\t\t\tbones: [],\n\t\t\tboneInverses: []\n\t\t};\n\n\t\tdata.uuid = this.uuid;\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\t\t\tdata.bones.push( bone.uuid );\n\n\t\t\tconst boneInverse = boneInverses[ i ];\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InstancedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, itemSize, normalized );\n\n\t\tthis.isInstancedBufferAttribute = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\n\t\tdata.isInstancedBufferAttribute = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _box3 = /*@__PURE__*/ new Box3();\nconst _identity = /*@__PURE__*/ new Matrix4();\nconst _mesh$1 = /*@__PURE__*/ new Mesh();\nconst _sphere$4 = /*@__PURE__*/ new Sphere();\n\nclass InstancedMesh extends Mesh {\n\n\tconstructor( geometry, material, count ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isInstancedMesh = true;\n\n\t\tthis.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );\n\t\tthis.instanceColor = null;\n\t\tthis.morphTexture = null;\n\n\t\tthis.count = count;\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.setMatrixAt( i, _identity );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingBox.union( _box3 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_sphere$4.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingSphere.union( _sphere$4 );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\n\t\tif ( source.morphTexture !== null ) this.morphTexture = source.morphTexture.clone();\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\n\n\t\tthis.count = source.count;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( index, color ) {\n\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tgetMatrixAt( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tgetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tconst len = objectInfluences.length + 1; // All influences + the baseInfluenceSum\n\n\t\tconst dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tobjectInfluences[ i ] = array[ dataIndex + i ];\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh$1.geometry = this.geometry;\n\t\t_mesh$1.material = this.material;\n\n\t\tif ( _mesh$1.material === undefined ) return;\n\n\t\t// test with bounding sphere first\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$4.copy( this.boundingSphere );\n\t\t_sphere$4.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;\n\n\t\t// now test each instance\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh$1.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh$1.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t}\n\n\tsetColorAt( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ).fill( 1 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tsetMatrixAt( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tsetMorphAt( index, object ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tconst len = objectInfluences.length + 1; // morphBaseInfluence + all influences\n\n\t\tif ( this.morphTexture === null ) {\n\n\t\t\tthis.morphTexture = new DataTexture( new Float32Array( len * this.count ), len, this.count, RedFormat, FloatType );\n\n\t\t}\n\n\t\tconst array = this.morphTexture.source.data.data;\n\n\t\tlet morphInfluencesSum = 0;\n\n\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t}\n\n\t\tconst morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\tconst dataIndex = len * index;\n\n\t\tarray[ dataIndex ] = morphBaseInfluence;\n\n\t\tarray.set( objectInfluences, dataIndex + 1 );\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\tif ( this.morphTexture !== null ) {\n\n\t\t\tthis.morphTexture.dispose();\n\t\t\tthis.morphTexture = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\tthis.isPlane = true;\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = normal;\n\t\tthis.constant = constant;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\treturn target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( line.start ).addScaledVector( direction, t );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _sphere$3 = /*@__PURE__*/ new Sphere();\nconst _vector$6 = /*@__PURE__*/ new Vector3();\n\nclass Frustum {\n\n\tconstructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {\n\n\t\tthis.planes = [ p0, p1, p2, p3, p4, p5 ];\n\n\t}\n\n\tset( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tconst planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( frustum ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst planes = this.planes;\n\t\tconst me = m.elements;\n\t\tconst me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tconst me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tconst me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tconst me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tintersectsObject( object ) {\n\n\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\n\t\t\t_sphere$3.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t} else {\n\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t}\n\n\t\treturn this.intersectsSphere( _sphere$3 );\n\n\t}\n\n\tintersectsSprite( sprite ) {\n\n\t\t_sphere$3.center.set( 0, 0, 0 );\n\t\t_sphere$3.radius = 0.7071067811865476;\n\t\t_sphere$3.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere$3 );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst planes = this.planes;\n\t\tconst center = sphere.center;\n\t\tconst negRadius = - sphere.radius;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = planes[ i ];\n\n\t\t\t// corner at max distance\n\n\t\t\t_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\tif ( plane.distanceToPoint( _vector$6 ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nfunction ascIdSort( a, b ) {\n\n\treturn a - b;\n\n}\n\nfunction sortOpaque( a, b ) {\n\n\treturn a.z - b.z;\n\n}\n\nfunction sortTransparent( a, b ) {\n\n\treturn b.z - a.z;\n\n}\n\nclass MultiDrawRenderList {\n\n\tconstructor() {\n\n\t\tthis.index = 0;\n\t\tthis.pool = [];\n\t\tthis.list = [];\n\n\t}\n\n\tpush( start, count, z, index ) {\n\n\t\tconst pool = this.pool;\n\t\tconst list = this.list;\n\t\tif ( this.index >= pool.length ) {\n\n\t\t\tpool.push( {\n\n\t\t\t\tstart: - 1,\n\t\t\t\tcount: - 1,\n\t\t\t\tz: - 1,\n\t\t\t\tindex: - 1,\n\n\t\t\t} );\n\n\t\t}\n\n\t\tconst item = pool[ this.index ];\n\t\tlist.push( item );\n\t\tthis.index ++;\n\n\t\titem.start = start;\n\t\titem.count = count;\n\t\titem.z = z;\n\t\titem.index = index;\n\n\t}\n\n\treset() {\n\n\t\tthis.list.length = 0;\n\t\tthis.index = 0;\n\n\t}\n\n}\n\nconst _matrix$1 = /*@__PURE__*/ new Matrix4();\nconst _whiteColor = /*@__PURE__*/ new Color( 1, 1, 1 );\nconst _frustum = /*@__PURE__*/ new Frustum();\nconst _box$1 = /*@__PURE__*/ new Box3();\nconst _sphere$2 = /*@__PURE__*/ new Sphere();\nconst _vector$5 = /*@__PURE__*/ new Vector3();\nconst _forward = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\nconst _renderList = /*@__PURE__*/ new MultiDrawRenderList();\nconst _mesh = /*@__PURE__*/ new Mesh();\nconst _batchIntersects = [];\n\n// copies data from attribute \"src\" into \"target\" starting at \"targetOffset\"\nfunction copyAttributeData( src, target, targetOffset = 0 ) {\n\n\tconst itemSize = target.itemSize;\n\tif ( src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor ) {\n\n\t\t// use the component getters and setters if the array data cannot\n\t\t// be copied directly\n\t\tconst vertexCount = src.count;\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\ttarget.setComponent( i + targetOffset, c, src.getComponent( i, c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// faster copy approach using typed array set function\n\t\ttarget.array.set( src.array, targetOffset * itemSize );\n\n\t}\n\n\ttarget.needsUpdate = true;\n\n}\n\n// safely copies array contents to a potentially smaller array\nfunction copyArrayContents( src, target ) {\n\n\tif ( src.constructor !== target.constructor ) {\n\n\t\t// if arrays are of a different type (eg due to index size increasing) then data must be per-element copied\n\t\tconst len = Math.min( src.length, target.length );\n\t\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\t\ttarget[ i ] = src[ i ];\n\n\t\t}\n\n\t} else {\n\n\t\t// if the arrays use the same data layout we can use a fast block copy\n\t\tconst len = Math.min( src.length, target.length );\n\t\ttarget.set( new src.constructor( src.buffer, 0, len ) );\n\n\t}\n\n}\n\nclass BatchedMesh extends Mesh {\n\n\tget maxInstanceCount() {\n\n\t\treturn this._maxInstanceCount;\n\n\t}\n\n\tget instanceCount() {\n\n\t\treturn this._instanceInfo.length - this._availableInstanceIds.length;\n\n\t}\n\n\tget unusedVertexCount() {\n\n\t\treturn this._maxVertexCount - this._nextVertexStart;\n\n\t}\n\n\tget unusedIndexCount() {\n\n\t\treturn this._maxIndexCount - this._nextIndexStart;\n\n\t}\n\n\tconstructor( maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material ) {\n\n\t\tsuper( new BufferGeometry(), material );\n\n\t\tthis.isBatchedMesh = true;\n\t\tthis.perObjectFrustumCulled = true;\n\t\tthis.sortObjects = true;\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\tthis.customSort = null;\n\n\t\t// stores visible, active, and geometry id per instance and reserved buffer ranges for geometries\n\t\tthis._instanceInfo = [];\n\t\tthis._geometryInfo = [];\n\n\t\t// instance, geometry ids that have been set as inactive, and are available to be overwritten\n\t\tthis._availableInstanceIds = [];\n\t\tthis._availableGeometryIds = [];\n\n\t\t// used to track where the next point is that geometry should be inserted\n\t\tthis._nextIndexStart = 0;\n\t\tthis._nextVertexStart = 0;\n\t\tthis._geometryCount = 0;\n\n\t\t// flags\n\t\tthis._visibilityChanged = true;\n\t\tthis._geometryInitialized = false;\n\n\t\t// cached user options\n\t\tthis._maxInstanceCount = maxInstanceCount;\n\t\tthis._maxVertexCount = maxVertexCount;\n\t\tthis._maxIndexCount = maxIndexCount;\n\n\t\t// buffers for multi draw\n\t\tthis._multiDrawCounts = new Int32Array( maxInstanceCount );\n\t\tthis._multiDrawStarts = new Int32Array( maxInstanceCount );\n\t\tthis._multiDrawCount = 0;\n\t\tthis._multiDrawInstances = null;\n\n\t\t// Local matrix per geometry by using data texture\n\t\tthis._matricesTexture = null;\n\t\tthis._indirectTexture = null;\n\t\tthis._colorsTexture = null;\n\n\t\tthis._initMatricesTexture();\n\t\tthis._initIndirectTexture();\n\n\t}\n\n\t_initMatricesTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = Math.ceil( size / 4 ) * 4;\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst matricesArray = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tconst matricesTexture = new DataTexture( matricesArray, size, size, RGBAFormat, FloatType );\n\n\t\tthis._matricesTexture = matricesTexture;\n\n\t}\n\n\t_initIndirectTexture() {\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\tconst indirectArray = new Uint32Array( size * size );\n\t\tconst indirectTexture = new DataTexture( indirectArray, size, size, RedIntegerFormat, UnsignedIntType );\n\n\t\tthis._indirectTexture = indirectTexture;\n\n\t}\n\n\t_initColorsTexture() {\n\n\t\tlet size = Math.sqrt( this._maxInstanceCount );\n\t\tsize = Math.ceil( size );\n\n\t\t// 4 floats per RGBA pixel initialized to white\n\t\tconst colorsArray = new Float32Array( size * size * 4 ).fill( 1 );\n\t\tconst colorsTexture = new DataTexture( colorsArray, size, size, RGBAFormat, FloatType );\n\t\tcolorsTexture.colorSpace = ColorManagement.workingColorSpace;\n\n\t\tthis._colorsTexture = colorsTexture;\n\n\t}\n\n\t_initializeGeometry( reference ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst maxVertexCount = this._maxVertexCount;\n\t\tconst maxIndexCount = this._maxIndexCount;\n\t\tif ( this._geometryInitialized === false ) {\n\n\t\t\tfor ( const attributeName in reference.attributes ) {\n\n\t\t\t\tconst srcAttribute = reference.getAttribute( attributeName );\n\t\t\t\tconst { array, itemSize, normalized } = srcAttribute;\n\n\t\t\t\tconst dstArray = new array.constructor( maxVertexCount * itemSize );\n\t\t\t\tconst dstAttribute = new BufferAttribute( dstArray, itemSize, normalized );\n\n\t\t\t\tgeometry.setAttribute( attributeName, dstAttribute );\n\n\t\t\t}\n\n\t\t\tif ( reference.getIndex() !== null ) {\n\n\t\t\t\t// Reserve last u16 index for primitive restart.\n\t\t\t\tconst indexArray = maxVertexCount > 65535\n\t\t\t\t\t? new Uint32Array( maxIndexCount )\n\t\t\t\t\t: new Uint16Array( maxIndexCount );\n\n\t\t\t\tgeometry.setIndex( new BufferAttribute( indexArray, 1 ) );\n\n\t\t\t}\n\n\t\t\tthis._geometryInitialized = true;\n\n\t\t}\n\n\t}\n\n\t// Make sure the geometry is compatible with the existing combined geometry attributes\n\t_validateGeometry( geometry ) {\n\n\t\t// check to ensure the geometries are using consistent attributes and indices\n\t\tconst batchGeometry = this.geometry;\n\t\tif ( Boolean( geometry.getIndex() ) !== Boolean( batchGeometry.getIndex() ) ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: All geometries must consistently have \"index\".' );\n\n\t\t}\n\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\tif ( ! geometry.hasAttribute( attributeName ) ) {\n\n\t\t\t\tthrow new Error( `THREE.BatchedMesh: Added geometry missing \"${ attributeName }\". All geometries must have consistent attributes.` );\n\n\t\t\t}\n\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tif ( srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized ) {\n\n\t\t\t\tthrow new Error( 'THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvalidateInstanceId( instanceId ) {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tif ( instanceId < 0 || instanceId >= instanceInfo.length || instanceInfo[ instanceId ].active === false ) {\n\n\t\t\tthrow new Error( `THREE.BatchedMesh: Invalid instanceId ${instanceId}. Instance is either out of range or has been deleted.` );\n\n\t\t}\n\n\t}\n\n\tvalidateGeometryId( geometryId ) {\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tif ( geometryId < 0 || geometryId >= geometryInfoList.length || geometryInfoList[ geometryId ].active === false ) {\n\n\t\t\tthrow new Error( `THREE.BatchedMesh: Invalid geometryId ${geometryId}. Geometry is either out of range or has been deleted.` );\n\n\t\t}\n\n\t}\n\n\n\tsetCustomSort( func ) {\n\n\t\tthis.customSort = func;\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst boundingBox = this.boundingBox;\n\t\tconst instanceInfo = this._instanceInfo;\n\n\t\tboundingBox.makeEmpty();\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].active === false ) continue;\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\tthis.getBoundingBoxAt( geometryId, _box$1 ).applyMatrix4( _matrix$1 );\n\t\t\tboundingBox.union( _box$1 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\t\tconst instanceInfo = this._instanceInfo;\n\n\t\tboundingSphere.makeEmpty();\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].active === false ) continue;\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\tthis.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );\n\t\t\tboundingSphere.union( _sphere$2 );\n\n\t\t}\n\n\t}\n\n\taddInstance( geometryId ) {\n\n\t\tconst atCapacity = this._instanceInfo.length >= this.maxInstanceCount;\n\n\t\t// ensure we're not over geometry\n\t\tif ( atCapacity && this._availableInstanceIds.length === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Maximum item count reached.' );\n\n\t\t}\n\n\t\tconst instanceInfo = {\n\t\t\tvisible: true,\n\t\t\tactive: true,\n\t\t\tgeometryIndex: geometryId,\n\t\t};\n\n\t\tlet drawId = null;\n\n\t\t// Prioritize using previously freed instance ids\n\t\tif ( this._availableInstanceIds.length > 0 ) {\n\n\t\t\tthis._availableInstanceIds.sort( ascIdSort );\n\n\t\t\tdrawId = this._availableInstanceIds.shift();\n\t\t\tthis._instanceInfo[ drawId ] = instanceInfo;\n\n\t\t} else {\n\n\t\t\tdrawId = this._instanceInfo.length;\n\t\t\tthis._instanceInfo.push( instanceInfo );\n\n\t\t}\n\n\t\tconst matricesTexture = this._matricesTexture;\n\t\t_matrix$1.identity().toArray( matricesTexture.image.data, drawId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\tconst colorsTexture = this._colorsTexture;\n\t\tif ( colorsTexture ) {\n\n\t\t\t_whiteColor.toArray( colorsTexture.image.data, drawId * 4 );\n\t\t\tcolorsTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tthis._visibilityChanged = true;\n\t\treturn drawId;\n\n\t}\n\n\taddGeometry( geometry, reservedVertexCount = - 1, reservedIndexCount = - 1 ) {\n\n\t\tthis._initializeGeometry( geometry );\n\n\t\tthis._validateGeometry( geometry );\n\n\t\tconst geometryInfo = {\n\t\t\t// geometry information\n\t\t\tvertexStart: - 1,\n\t\t\tvertexCount: - 1,\n\t\t\treservedVertexCount: - 1,\n\n\t\t\tindexStart: - 1,\n\t\t\tindexCount: - 1,\n\t\t\treservedIndexCount: - 1,\n\n\t\t\t// draw range information\n\t\t\tstart: - 1,\n\t\t\tcount: - 1,\n\n\t\t\t// state\n\t\t\tboundingBox: null,\n\t\t\tboundingSphere: null,\n\t\t\tactive: true,\n\t\t};\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tgeometryInfo.vertexStart = this._nextVertexStart;\n\t\tgeometryInfo.reservedVertexCount = reservedVertexCount === - 1 ? geometry.getAttribute( 'position' ).count : reservedVertexCount;\n\n\t\tconst index = geometry.getIndex();\n\t\tconst hasIndex = index !== null;\n\t\tif ( hasIndex ) {\n\n\t\t\tgeometryInfo.indexStart = this._nextIndexStart;\n\t\t\tgeometryInfo.reservedIndexCount = reservedIndexCount === - 1 ? index.count : reservedIndexCount;\n\n\t\t}\n\n\t\tif (\n\t\t\tgeometryInfo.indexStart !== - 1 &&\n\t\t\tgeometryInfo.indexStart + geometryInfo.reservedIndexCount > this._maxIndexCount ||\n\t\t\tgeometryInfo.vertexStart + geometryInfo.reservedVertexCount > this._maxVertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.' );\n\n\t\t}\n\n\t\t// update id\n\t\tlet geometryId;\n\t\tif ( this._availableGeometryIds.length > 0 ) {\n\n\t\t\tthis._availableGeometryIds.sort( ascIdSort );\n\n\t\t\tgeometryId = this._availableGeometryIds.shift();\n\t\t\tgeometryInfoList[ geometryId ] = geometryInfo;\n\n\n\t\t} else {\n\n\t\t\tgeometryId = this._geometryCount;\n\t\t\tthis._geometryCount ++;\n\t\t\tgeometryInfoList.push( geometryInfo );\n\n\t\t}\n\n\t\t// update the geometry\n\t\tthis.setGeometryAt( geometryId, geometry );\n\n\t\t// increment the next geometry position\n\t\tthis._nextIndexStart = geometryInfo.indexStart + geometryInfo.reservedIndexCount;\n\t\tthis._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;\n\n\t\treturn geometryId;\n\n\t}\n\n\tsetGeometryAt( geometryId, geometry ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Maximum geometry count reached.' );\n\n\t\t}\n\n\t\tthis._validateGeometry( geometry );\n\n\t\tconst batchGeometry = this.geometry;\n\t\tconst hasIndex = batchGeometry.getIndex() !== null;\n\t\tconst dstIndex = batchGeometry.getIndex();\n\t\tconst srcIndex = geometry.getIndex();\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif (\n\t\t\thasIndex &&\n\t\t\tsrcIndex.count > geometryInfo.reservedIndexCount ||\n\t\t\tgeometry.attributes.position.count > geometryInfo.reservedVertexCount\n\t\t) {\n\n\t\t\tthrow new Error( 'THREE.BatchedMesh: Reserved space not large enough for provided geometry.' );\n\n\t\t}\n\n\t\t// copy geometry buffer data over\n\t\tconst vertexStart = geometryInfo.vertexStart;\n\t\tconst reservedVertexCount = geometryInfo.reservedVertexCount;\n\t\tgeometryInfo.vertexCount = geometry.getAttribute( 'position' ).count;\n\n\t\tfor ( const attributeName in batchGeometry.attributes ) {\n\n\t\t\t// copy attribute data\n\t\t\tconst srcAttribute = geometry.getAttribute( attributeName );\n\t\t\tconst dstAttribute = batchGeometry.getAttribute( attributeName );\n\t\t\tcopyAttributeData( srcAttribute, dstAttribute, vertexStart );\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tconst itemSize = srcAttribute.itemSize;\n\t\t\tfor ( let i = srcAttribute.count, l = reservedVertexCount; i < l; i ++ ) {\n\n\t\t\t\tconst index = vertexStart + i;\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tdstAttribute.setComponent( index, c, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdstAttribute.needsUpdate = true;\n\t\t\tdstAttribute.addUpdateRange( vertexStart * itemSize, reservedVertexCount * itemSize );\n\n\t\t}\n\n\t\t// copy index\n\t\tif ( hasIndex ) {\n\n\t\t\tconst indexStart = geometryInfo.indexStart;\n\t\t\tconst reservedIndexCount = geometryInfo.reservedIndexCount;\n\t\t\tgeometryInfo.indexCount = geometry.getIndex().count;\n\n\t\t\t// copy index data over\n\t\t\tfor ( let i = 0; i < srcIndex.count; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart + srcIndex.getX( i ) );\n\n\t\t\t}\n\n\t\t\t// fill the rest in with zeroes\n\t\t\tfor ( let i = srcIndex.count, l = reservedIndexCount; i < l; i ++ ) {\n\n\t\t\t\tdstIndex.setX( indexStart + i, vertexStart );\n\n\t\t\t}\n\n\t\t\tdstIndex.needsUpdate = true;\n\t\t\tdstIndex.addUpdateRange( indexStart, geometryInfo.reservedIndexCount );\n\n\t\t}\n\n\t\t// update the draw range\n\t\tgeometryInfo.start = hasIndex ? geometryInfo.indexStart : geometryInfo.vertexStart;\n\t\tgeometryInfo.count = hasIndex ? geometryInfo.indexCount : geometryInfo.vertexCount;\n\n\t\t// store the bounding boxes\n\t\tgeometryInfo.boundingBox = null;\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tgeometryInfo.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tgeometryInfo.boundingSphere = null;\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tgeometryInfo.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tthis._visibilityChanged = true;\n\t\treturn geometryId;\n\n\t}\n\n\tdeleteGeometry( geometryId ) {\n\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tif ( geometryId >= geometryInfoList.length || geometryInfoList[ geometryId ].active === false ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// delete any instances associated with this geometry\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( instanceInfo[ i ].geometryIndex === geometryId ) {\n\n\t\t\t\tthis.deleteInstance( i );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryInfoList[ geometryId ].active = false;\n\t\tthis._availableGeometryIds.push( geometryId );\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteInstance( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tthis._instanceInfo[ instanceId ].active = false;\n\t\tthis._availableInstanceIds.push( instanceId );\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\toptimize() {\n\n\t\t// track the next indices to copy data to\n\t\tlet nextVertexStart = 0;\n\t\tlet nextIndexStart = 0;\n\n\t\t// Iterate over all geometry ranges in order sorted from earliest in the geometry buffer to latest\n\t\t// in the geometry buffer. Because draw range objects can be reused there is no guarantee of their order.\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst indices = geometryInfoList\n\t\t\t.map( ( e, i ) => i )\n\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\treturn geometryInfoList[ a ].vertexStart - geometryInfoList[ b ].vertexStart;\n\n\t\t\t} );\n\n\t\tconst geometry = this.geometry;\n\t\tfor ( let i = 0, l = geometryInfoList.length; i < l; i ++ ) {\n\n\t\t\t// if a geometry range is inactive then don't copy anything\n\t\t\tconst index = indices[ i ];\n\t\t\tconst geometryInfo = geometryInfoList[ index ];\n\t\t\tif ( geometryInfo.active === false ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if a geometry contains an index buffer then shift it, as well\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tif ( geometryInfo.indexStart !== nextIndexStart ) {\n\n\t\t\t\t\tconst { indexStart, vertexStart, reservedIndexCount } = geometryInfo;\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tconst array = index.array;\n\n\t\t\t\t\t// shift the index pointers based on how the vertex data will shift\n\t\t\t\t\t// adjusting the index must happen first so the original vertex start value is available\n\t\t\t\t\tconst elementDelta = nextVertexStart - vertexStart;\n\t\t\t\t\tfor ( let j = indexStart; j < indexStart + reservedIndexCount; j ++ ) {\n\n\t\t\t\t\t\tarray[ j ] = array[ j ] + elementDelta;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex.array.copyWithin( nextIndexStart, indexStart, indexStart + reservedIndexCount );\n\t\t\t\t\tindex.addUpdateRange( nextIndexStart, reservedIndexCount );\n\n\t\t\t\t\tgeometryInfo.indexStart = nextIndexStart;\n\n\t\t\t\t}\n\n\t\t\t\tnextIndexStart += geometryInfo.reservedIndexCount;\n\n\t\t\t}\n\n\t\t\t// if a geometry needs to be moved then copy attribute data to overwrite unused space\n\t\t\tif ( geometryInfo.vertexStart !== nextVertexStart ) {\n\n\t\t\t\tconst { vertexStart, reservedVertexCount } = geometryInfo;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\t\tconst attribute = attributes[ key ];\n\t\t\t\t\tconst { array, itemSize } = attribute;\n\t\t\t\t\tarray.copyWithin( nextVertexStart * itemSize, vertexStart * itemSize, ( vertexStart + reservedVertexCount ) * itemSize );\n\t\t\t\t\tattribute.addUpdateRange( nextVertexStart * itemSize, reservedVertexCount * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometryInfo.vertexStart = nextVertexStart;\n\n\t\t\t}\n\n\t\t\tnextVertexStart += geometryInfo.reservedVertexCount;\n\t\t\tgeometryInfo.start = geometry.index ? geometryInfo.indexStart : geometryInfo.vertexStart;\n\n\t\t\t// step the next geometry points to the shifted position\n\t\t\tthis._nextIndexStart = geometry.index ? geometryInfo.indexStart + geometryInfo.reservedIndexCount : 0;\n\t\t\tthis._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get bounding box and compute it if it doesn't exist\n\tgetBoundingBoxAt( geometryId, target ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding box\n\t\tconst geometry = this.geometry;\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif ( geometryInfo.boundingBox === null ) {\n\n\t\t\tconst box = new Box3();\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\t\t\tfor ( let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\tbox.expandByPoint( _vector$5.fromBufferAttribute( position, iv ) );\n\n\t\t\t}\n\n\t\t\tgeometryInfo.boundingBox = box;\n\n\t\t}\n\n\t\ttarget.copy( geometryInfo.boundingBox );\n\t\treturn target;\n\n\t}\n\n\t// get bounding sphere and compute it if it doesn't exist\n\tgetBoundingSphereAt( geometryId, target ) {\n\n\t\tif ( geometryId >= this._geometryCount ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// compute bounding sphere\n\t\tconst geometry = this.geometry;\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\tif ( geometryInfo.boundingSphere === null ) {\n\n\t\t\tconst sphere = new Sphere();\n\t\t\tthis.getBoundingBoxAt( geometryId, _box$1 );\n\t\t\t_box$1.getCenter( sphere.center );\n\n\t\t\tconst index = geometry.index;\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tlet maxRadiusSq = 0;\n\t\t\tfor ( let i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i ++ ) {\n\n\t\t\t\tlet iv = i;\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\tiv = index.getX( iv );\n\n\t\t\t\t}\n\n\t\t\t\t_vector$5.fromBufferAttribute( position, iv );\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, sphere.center.distanceToSquared( _vector$5 ) );\n\n\t\t\t}\n\n\t\t\tsphere.radius = Math.sqrt( maxRadiusSq );\n\t\t\tgeometryInfo.boundingSphere = sphere;\n\n\t\t}\n\n\t\ttarget.copy( geometryInfo.boundingSphere );\n\t\treturn target;\n\n\t}\n\n\tsetMatrixAt( instanceId, matrix ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst matricesArray = this._matricesTexture.image.data;\n\t\tmatrix.toArray( matricesArray, instanceId * 16 );\n\t\tmatricesTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetMatrixAt( instanceId, matrix ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\treturn matrix.fromArray( this._matricesTexture.image.data, instanceId * 16 );\n\n\t}\n\n\tsetColorAt( instanceId, color ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tif ( this._colorsTexture === null ) {\n\n\t\t\tthis._initColorsTexture();\n\n\t\t}\n\n\t\tcolor.toArray( this._colorsTexture.image.data, instanceId * 4 );\n\t\tthis._colorsTexture.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( instanceId, color ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\treturn color.fromArray( this._colorsTexture.image.data, instanceId * 4 );\n\n\t}\n\n\tsetVisibleAt( instanceId, value ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\tif ( this._instanceInfo[ instanceId ].visible === value ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis._instanceInfo[ instanceId ].visible = value;\n\t\tthis._visibilityChanged = true;\n\n\t\treturn this;\n\n\t}\n\n\tgetVisibleAt( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\treturn this._instanceInfo[ instanceId ].visible;\n\n\t}\n\n\tsetGeometryIdAt( instanceId, geometryId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\t\tthis.validateGeometryId( geometryId );\n\n\t\tthis._instanceInfo[ instanceId ].geometryIndex = geometryId;\n\n\t\treturn this;\n\n\t}\n\n\tgetGeometryIdAt( instanceId ) {\n\n\t\tthis.validateInstanceId( instanceId );\n\n\t\treturn this._instanceInfo[ instanceId ].geometryIndex;\n\n\t}\n\n\tgetGeometryRangeAt( geometryId, target = {} ) {\n\n\t\tthis.validateGeometryId( geometryId );\n\n\t\tconst geometryInfo = this._geometryInfo[ geometryId ];\n\t\ttarget.vertexStart = geometryInfo.vertexStart;\n\t\ttarget.vertexCount = geometryInfo.vertexCount;\n\t\ttarget.reservedVertexCount = geometryInfo.reservedVertexCount;\n\n\t\ttarget.indexStart = geometryInfo.indexStart;\n\t\ttarget.indexCount = geometryInfo.indexCount;\n\t\ttarget.reservedIndexCount = geometryInfo.reservedIndexCount;\n\n\t\ttarget.start = geometryInfo.start;\n\t\ttarget.count = geometryInfo.count;\n\n\t\treturn target;\n\n\t}\n\n\tsetInstanceCount( maxInstanceCount ) {\n\n\t\t// shrink the available instances as much as possible\n\t\tconst availableInstanceIds = this._availableInstanceIds;\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tavailableInstanceIds.sort( ascIdSort );\n\t\twhile ( availableInstanceIds[ availableInstanceIds.length - 1 ] === instanceInfo.length ) {\n\n\t\t\tinstanceInfo.pop();\n\t\t\tavailableInstanceIds.pop();\n\n\t\t}\n\n\t\t// throw an error if it can't be shrunk to the desired size\n\t\tif ( maxInstanceCount < instanceInfo.length ) {\n\n\t\t\tthrow new Error( `BatchedMesh: Instance ids outside the range ${ maxInstanceCount } are being used. Cannot shrink instance count.` );\n\n\t\t}\n\n\t\t// copy the multi draw counts\n\t\tconst multiDrawCounts = new Int32Array( maxInstanceCount );\n\t\tconst multiDrawStarts = new Int32Array( maxInstanceCount );\n\t\tcopyArrayContents( this._multiDrawCounts, multiDrawCounts );\n\t\tcopyArrayContents( this._multiDrawStarts, multiDrawStarts );\n\n\t\tthis._multiDrawCounts = multiDrawCounts;\n\t\tthis._multiDrawStarts = multiDrawStarts;\n\t\tthis._maxInstanceCount = maxInstanceCount;\n\n\t\t// update texture data for instance sampling\n\t\tconst indirectTexture = this._indirectTexture;\n\t\tconst matricesTexture = this._matricesTexture;\n\t\tconst colorsTexture = this._colorsTexture;\n\n\t\tindirectTexture.dispose();\n\t\tthis._initIndirectTexture();\n\t\tcopyArrayContents( indirectTexture.image.data, this._indirectTexture.image.data );\n\n\t\tmatricesTexture.dispose();\n\t\tthis._initMatricesTexture();\n\t\tcopyArrayContents( matricesTexture.image.data, this._matricesTexture.image.data );\n\n\t\tif ( colorsTexture ) {\n\n\t\t\tcolorsTexture.dispose();\n\t\t\tthis._initColorsTexture();\n\t\t\tcopyArrayContents( colorsTexture.image.data, this._colorsTexture.image.data );\n\n\t\t}\n\n\t}\n\n\tsetGeometrySize( maxVertexCount, maxIndexCount ) {\n\n\t\t// Check if we can shrink to the requested vertex attribute size\n\t\tconst validRanges = [ ...this._geometryInfo ].filter( info => info.active );\n\t\tconst requiredVertexLength = Math.max( ...validRanges.map( range => range.vertexStart + range.reservedVertexCount ) );\n\t\tif ( requiredVertexLength > maxVertexCount ) {\n\n\t\t\tthrow new Error( `BatchedMesh: Geometry vertex values are being used outside the range ${ maxIndexCount }. Cannot shrink further.` );\n\n\t\t}\n\n\t\t// Check if we can shrink to the requested index attribute size\n\t\tif ( this.geometry.index ) {\n\n\t\t\tconst requiredIndexLength = Math.max( ...validRanges.map( range => range.indexStart + range.reservedIndexCount ) );\n\t\t\tif ( requiredIndexLength > maxIndexCount ) {\n\n\t\t\t\tthrow new Error( `BatchedMesh: Geometry index values are being used outside the range ${ maxIndexCount }. Cannot shrink further.` );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\t// dispose of the previous geometry\n\t\tconst oldGeometry = this.geometry;\n\t\toldGeometry.dispose();\n\n\t\t// recreate the geometry needed based on the previous variant\n\t\tthis._maxVertexCount = maxVertexCount;\n\t\tthis._maxIndexCount = maxIndexCount;\n\n\t\tif ( this._geometryInitialized ) {\n\n\t\t\tthis._geometryInitialized = false;\n\t\t\tthis.geometry = new BufferGeometry();\n\t\t\tthis._initializeGeometry( oldGeometry );\n\n\t\t}\n\n\t\t// copy data from the previous geometry\n\t\tconst geometry = this.geometry;\n\t\tif ( oldGeometry.index ) {\n\n\t\t\tcopyArrayContents( oldGeometry.index.array, geometry.index.array );\n\n\t\t}\n\n\t\tfor ( const key in oldGeometry.attributes ) {\n\n\t\t\tcopyArrayContents( oldGeometry.attributes[ key ].array, geometry.attributes[ key ].array );\n\n\t\t}\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst batchGeometry = this.geometry;\n\n\t\t// iterate over each geometry\n\t\t_mesh.material = this.material;\n\t\t_mesh.geometry.index = batchGeometry.index;\n\t\t_mesh.geometry.attributes = batchGeometry.attributes;\n\t\tif ( _mesh.geometry.boundingBox === null ) {\n\n\t\t\t_mesh.geometry.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t_mesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( ! instanceInfo[ i ].visible || ! instanceInfo[ i ].active ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t_mesh.geometry.setDrawRange( geometryInfo.start, geometryInfo.count );\n\n\t\t\t// get the intersects\n\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\t\t\tthis.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );\n\t\t\tthis.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );\n\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\t// add batch id to the intersects\n\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersect.batchId = i;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_batchIntersects.length = 0;\n\n\t\t}\n\n\t\t_mesh.material = null;\n\t\t_mesh.geometry.index = null;\n\t\t_mesh.geometry.attributes = {};\n\t\t_mesh.geometry.setDrawRange( 0, Infinity );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.geometry = source.geometry.clone();\n\t\tthis.perObjectFrustumCulled = source.perObjectFrustumCulled;\n\t\tthis.sortObjects = source.sortObjects;\n\t\tthis.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;\n\t\tthis.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;\n\n\t\tthis._geometryInfo = source._geometryInfo.map( info => ( {\n\t\t\t...info,\n\n\t\t\tboundingBox: info.boundingBox !== null ? info.boundingBox.clone() : null,\n\t\t\tboundingSphere: info.boundingSphere !== null ? info.boundingSphere.clone() : null,\n\t\t} ) );\n\t\tthis._instanceInfo = source._instanceInfo.map( info => ( { ...info } ) );\n\n\t\tthis._maxInstanceCount = source._maxInstanceCount;\n\t\tthis._maxVertexCount = source._maxVertexCount;\n\t\tthis._maxIndexCount = source._maxIndexCount;\n\n\t\tthis._geometryInitialized = source._geometryInitialized;\n\t\tthis._geometryCount = source._geometryCount;\n\t\tthis._multiDrawCounts = source._multiDrawCounts.slice();\n\t\tthis._multiDrawStarts = source._multiDrawStarts.slice();\n\n\t\tthis._matricesTexture = source._matricesTexture.clone();\n\t\tthis._matricesTexture.image.data = this._matricesTexture.image.data.slice();\n\n\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\tthis._colorsTexture = source._colorsTexture.clone();\n\t\t\tthis._colorsTexture.image.data = this._colorsTexture.image.data.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\t// Assuming the geometry is not shared with other meshes\n\t\tthis.geometry.dispose();\n\n\t\tthis._matricesTexture.dispose();\n\t\tthis._matricesTexture = null;\n\n\t\tthis._indirectTexture.dispose();\n\t\tthis._indirectTexture = null;\n\n\t\tif ( this._colorsTexture !== null ) {\n\n\t\t\tthis._colorsTexture.dispose();\n\t\t\tthis._colorsTexture = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tonBeforeRender( renderer, scene, camera, geometry, material/*, _group*/ ) {\n\n\t\t// if visibility has not changed and frustum culling and object sorting is not required\n\t\t// then skip iterating over all items\n\t\tif ( ! this._visibilityChanged && ! this.perObjectFrustumCulled && ! this.sortObjects ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// the indexed version of the multi draw function requires specifying the start\n\t\t// offset in bytes.\n\t\tconst index = geometry.getIndex();\n\t\tconst bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;\n\n\t\tconst instanceInfo = this._instanceInfo;\n\t\tconst multiDrawStarts = this._multiDrawStarts;\n\t\tconst multiDrawCounts = this._multiDrawCounts;\n\t\tconst geometryInfoList = this._geometryInfo;\n\t\tconst perObjectFrustumCulled = this.perObjectFrustumCulled;\n\t\tconst indirectTexture = this._indirectTexture;\n\t\tconst indirectArray = indirectTexture.image.data;\n\n\t\t// prepare the frustum in the local frame\n\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t_matrix$1\n\t\t\t\t.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse )\n\t\t\t\t.multiply( this.matrixWorld );\n\t\t\t_frustum.setFromProjectionMatrix(\n\t\t\t\t_matrix$1,\n\t\t\t\trenderer.coordinateSystem\n\t\t\t);\n\n\t\t}\n\n\t\tlet multiDrawCount = 0;\n\t\tif ( this.sortObjects ) {\n\n\t\t\t// get the camera position in the local frame\n\t\t\t_matrix$1.copy( this.matrixWorld ).invert();\n\t\t\t_vector$5.setFromMatrixPosition( camera.matrixWorld ).applyMatrix4( _matrix$1 );\n\t\t\t_forward.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld ).transformDirection( _matrix$1 );\n\n\t\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\t\tif ( instanceInfo[ i ].visible && instanceInfo[ i ].active ) {\n\n\t\t\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\n\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\t\t\tthis.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\tculled = ! _frustum.intersectsSphere( _sphere$2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\t// get the distance from camera used for sorting\n\t\t\t\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t\t\t\tconst z = _temp.subVectors( _sphere$2.center, _vector$5 ).dot( _forward );\n\t\t\t\t\t\t_renderList.push( geometryInfo.start, geometryInfo.count, z, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Sort the draw ranges and prep for rendering\n\t\t\tconst list = _renderList.list;\n\t\t\tconst customSort = this.customSort;\n\t\t\tif ( customSort === null ) {\n\n\t\t\t\tlist.sort( material.transparent ? sortTransparent : sortOpaque );\n\n\t\t\t} else {\n\n\t\t\t\tcustomSort.call( this, list, camera );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = list.length; i < l; i ++ ) {\n\n\t\t\t\tconst item = list[ i ];\n\t\t\t\tmultiDrawStarts[ multiDrawCount ] = item.start * bytesPerElement;\n\t\t\t\tmultiDrawCounts[ multiDrawCount ] = item.count;\n\t\t\t\tindirectArray[ multiDrawCount ] = item.index;\n\t\t\t\tmultiDrawCount ++;\n\n\t\t\t}\n\n\t\t\t_renderList.reset();\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = instanceInfo.length; i < l; i ++ ) {\n\n\t\t\t\tif ( instanceInfo[ i ].visible && instanceInfo[ i ].active ) {\n\n\t\t\t\t\tconst geometryId = instanceInfo[ i ].geometryIndex;\n\n\t\t\t\t\t// determine whether the batched geometry is within the frustum\n\t\t\t\t\tlet culled = false;\n\t\t\t\t\tif ( perObjectFrustumCulled ) {\n\n\t\t\t\t\t\t// get the bounds in world space\n\t\t\t\t\t\tthis.getMatrixAt( i, _matrix$1 );\n\t\t\t\t\t\tthis.getBoundingSphereAt( geometryId, _sphere$2 ).applyMatrix4( _matrix$1 );\n\t\t\t\t\t\tculled = ! _frustum.intersectsSphere( _sphere$2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! culled ) {\n\n\t\t\t\t\t\tconst geometryInfo = geometryInfoList[ geometryId ];\n\t\t\t\t\t\tmultiDrawStarts[ multiDrawCount ] = geometryInfo.start * bytesPerElement;\n\t\t\t\t\t\tmultiDrawCounts[ multiDrawCount ] = geometryInfo.count;\n\t\t\t\t\t\tindirectArray[ multiDrawCount ] = i;\n\t\t\t\t\t\tmultiDrawCount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tindirectTexture.needsUpdate = true;\n\t\tthis._multiDrawCount = multiDrawCount;\n\t\tthis._visibilityChanged = false;\n\n\t}\n\n\tonBeforeShadow( renderer, object, camera, shadowCamera, geometry, depthMaterial/* , group */ ) {\n\n\t\tthis.onBeforeRender( renderer, null, shadowCamera, geometry, depthMaterial );\n\n\t}\n\n}\n\nclass LineBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineBasicMaterial = true;\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vStart = /*@__PURE__*/ new Vector3();\nconst _vEnd = /*@__PURE__*/ new Vector3();\n\nconst _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _ray$1 = /*@__PURE__*/ new Ray();\nconst _sphere$1 = /*@__PURE__*/ new Sphere();\n\nconst _intersectPointOnRay = /*@__PURE__*/ new Vector3();\nconst _intersectPointOnSegment = /*@__PURE__*/ new Vector3();\n\nclass Line extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isLine = true;\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t_vStart.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t_vEnd.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i ] += _vStart.distanceTo( _vEnd );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$1.copy( geometry.boundingSphere );\n\t\t_sphere$1.applyMatrix4( matrixWorld );\n\t\t_sphere$1.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix$1.copy( matrixWorld ).invert();\n\t\t_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst a = index.getX( end - 1 );\n\t\t\t\tconst b = index.getX( start );\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, a, b );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, i, i + 1 );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.isLineLoop ) {\n\n\t\t\t\tconst intersect = checkIntersection( this, raycaster, _ray$1, localThresholdSq, end - 1, start );\n\n\t\t\t\tif ( intersect ) {\n\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection( object, raycaster, ray, thresholdSq, a, b ) {\n\n\tconst positionAttribute = object.geometry.attributes.position;\n\n\t_vStart.fromBufferAttribute( positionAttribute, a );\n\t_vEnd.fromBufferAttribute( positionAttribute, b );\n\n\tconst distSq = ray.distanceSqToSegment( _vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment );\n\n\tif ( distSq > thresholdSq ) return;\n\n\t_intersectPointOnRay.applyMatrix4( object.matrixWorld ); // Move back to world space for distance calculation\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectPointOnRay );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t// point: raycaster.ray.at( distance ),\n\t\tpoint: _intersectPointOnSegment.clone().applyMatrix4( object.matrixWorld ),\n\t\tindex: a,\n\t\tface: null,\n\t\tfaceIndex: null,\n\t\tbarycoord: null,\n\t\tobject: object\n\n\t};\n\n}\n\nconst _start = /*@__PURE__*/ new Vector3();\nconst _end = /*@__PURE__*/ new Vector3();\n\nclass LineSegments extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments = true;\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [];\n\n\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t_start.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t_end.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineLoop extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineLoop = true;\n\n\t\tthis.type = 'LineLoop';\n\n\t}\n\n}\n\nclass PointsMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isPointsMaterial = true;\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _position$2 = /*@__PURE__*/ new Vector3();\n\nclass Points extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isPoints = true;\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = Array.isArray( source.material ) ? source.material.slice() : source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\n\n\t\t\t\tconst a = index.getX( i );\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\ttestPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\ttestPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tfaceIndex: null,\n\t\t\tbarycoord: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nclass Group extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isGroup = true;\n\n\t\tthis.type = 'Group';\n\n\t}\n\n}\n\nclass VideoTexture extends Texture {\n\n\tconstructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isVideoTexture = true;\n\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tconst scope = this;\n\n\t\tfunction updateVideo() {\n\n\t\t\tscope.needsUpdate = true;\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t\tif ( 'requestVideoFrameCallback' in video ) {\n\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.image ).copy( this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst video = this.image;\n\t\tconst hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n\t\tif ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass FramebufferTexture extends Texture {\n\n\tconstructor( width, height ) {\n\n\t\tsuper( { width, height } );\n\n\t\tthis.isFramebufferTexture = true;\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nclass CompressedTexture extends Texture {\n\n\tconstructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCompressedTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n}\n\nclass CompressedArrayTexture extends CompressedTexture {\n\n\tconstructor( mipmaps, width, height, depth, format, type ) {\n\n\t\tsuper( mipmaps, width, height, format, type );\n\n\t\tthis.isCompressedArrayTexture = true;\n\t\tthis.image.depth = depth;\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.layerUpdates = new Set();\n\n\t}\n\n\taddLayerUpdate( layerIndex ) {\n\n\t\tthis.layerUpdates.add( layerIndex );\n\n\t}\n\n\tclearLayerUpdates() {\n\n\t\tthis.layerUpdates.clear();\n\n\t}\n\n}\n\nclass CompressedCubeTexture extends CompressedTexture {\n\n\tconstructor( images, format, type ) {\n\n\t\tsuper( undefined, images[ 0 ].width, images[ 0 ].height, format, type, CubeReflectionMapping );\n\n\t\tthis.isCompressedCubeTexture = true;\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.image = images;\n\n\t}\n\n}\n\nclass CanvasTexture extends Texture {\n\n\tconstructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isCanvasTexture = true;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nclass DepthTexture extends Texture {\n\n\tconstructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat ) {\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t\t}\n\n\t\tif ( type === undefined && format === DepthFormat ) type = UnsignedIntType;\n\t\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isDepthTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.compareFunction = null;\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.compareFunction = source.compareFunction;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n\n\tconstructor() {\n\n\t\tthis.type = 'Curve';\n\n\t\tthis.arcLengthDivisions = 200;\n\n\t}\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t}\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t}\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get total curve arc length\n\n\tgetLength() {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t}\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths( divisions = this.arcLengthDivisions ) {\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t}\n\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t}\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t}\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t}\n\n\tcomputeFrenetFrames( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass EllipseCurve extends Curve {\n\n\tconstructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.isEllipseCurve = true;\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst twoPi = Math.PI * 2;\n\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tconst samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\tlet x = this.aX + this.xRadius * Math.cos( angle );\n\t\tlet y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tconst cos = Math.cos( this.aRotation );\n\t\t\tconst sin = Math.sin( this.aRotation );\n\n\t\t\tconst tx = x - this.aX;\n\t\t\tconst ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass ArcCurve extends EllipseCurve {\n\n\tconstructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tsuper( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\tthis.isArcCurve = true;\n\n\t\tthis.type = 'ArcCurve';\n\n\t}\n\n}\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tlet c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tlet t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tlet t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nconst tmp = /*@__PURE__*/ new Vector3();\nconst px = /*@__PURE__*/ new CubicPoly();\nconst py = /*@__PURE__*/ new CubicPoly();\nconst pz = /*@__PURE__*/ new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n\n\tconstructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {\n\n\t\tsuper();\n\n\t\tthis.isCatmullRomCurve3 = true;\n\n\t\tthis.type = 'CatmullRomCurve3';\n\n\t\tthis.points = points;\n\t\tthis.closed = closed;\n\t\tthis.curveType = curveType;\n\t\tthis.tension = tension;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst l = points.length;\n\n\t\tconst p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\tlet intPoint = Math.floor( p );\n\t\tlet weight = p - intPoint;\n\n\t\tif ( this.closed ) {\n\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1;\n\n\t\t}\n\n\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\tp0 = tmp;\n\n\t\t}\n\n\t\tconst p1 = points[ intPoint % l ];\n\t\tconst p2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = tmp;\n\n\t\t}\n\n\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\tlet dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\tlet dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\tlet dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t// safety check for repeated points\n\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t\t}\n\n\t\tpoint.set(\n\t\t\tpx.calc( weight ),\n\t\t\tpy.calc( weight ),\n\t\t\tpz.calc( weight )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\tthis.closed = source.closed;\n\t\tthis.curveType = source.curveType;\n\t\tthis.tension = source.tension;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\tdata.closed = this.closed;\n\t\tdata.curveType = this.curveType;\n\t\tdata.tension = this.tension;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t\t}\n\n\t\tthis.closed = json.closed;\n\t\tthis.curveType = json.curveType;\n\t\tthis.tension = json.tension;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Bezier Curves formulas obtained from\n * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tconst v0 = ( p2 - p0 ) * 0.5;\n\tconst v1 = ( p3 - p1 ) * 0.5;\n\tconst t2 = t * t;\n\tconst t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tconst k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nclass CubicBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve = true;\n\n\t\tthis.type = 'CubicBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass CubicBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve3 = true;\n\n\t\tthis.type = 'CubicBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve extends Curve {\n\n\tconstructor( v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve = true;\n\n\t\tthis.type = 'LineCurve';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector2() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve3 extends Curve {\n\n\tconstructor( v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve3 = true;\n\n\t\tthis.type = 'LineCurve3';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve = true;\n\n\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve3 = true;\n\n\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SplineCurve extends Curve {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isSplineCurve = true;\n\n\t\tthis.type = 'SplineCurve';\n\n\t\tthis.points = points;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst p = ( points.length - 1 ) * t;\n\n\t\tconst intPoint = Math.floor( p );\n\t\tconst weight = p - intPoint;\n\n\t\tconst p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tconst p1 = points[ intPoint ];\n\t\tconst p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tconst p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tpoint.set(\n\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nvar Curves = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tArcCurve: ArcCurve,\n\tCatmullRomCurve3: CatmullRomCurve3,\n\tCubicBezierCurve: CubicBezierCurve,\n\tCubicBezierCurve3: CubicBezierCurve3,\n\tEllipseCurve: EllipseCurve,\n\tLineCurve: LineCurve,\n\tLineCurve3: LineCurve3,\n\tQuadraticBezierCurve: QuadraticBezierCurve,\n\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\tSplineCurve: SplineCurve\n});\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tconst lineType = ( startPoint.isVector2 === true ) ? 'LineCurve' : 'LineCurve3';\n\t\t\tthis.curves.push( new Curves[ lineType ]( endPoint, startPoint ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u, optionalTarget );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength() {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths() {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = curve.isEllipseCurve ? divisions * 2\n\t\t\t\t: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1\n\t\t\t\t\t: curve.isSplineCurve ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Path extends CurvePath {\n\n\tconstructor( points ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Path';\n\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( let i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tconst curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tconst curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tconst curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts /*Array of Vector*/ ) {\n\n\t\tconst npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tconst curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t}\n\n\tarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tabsarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t}\n\n\tabsellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tconst firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tconst lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LatheGeometry extends BufferGeometry {\n\n\tconstructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\t\tconst initNormals = [];\n\t\tconst normals = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tconst normal = new Vector3();\n\t\tconst curNormal = new Vector3();\n\t\tconst prevNormal = new Vector3();\n\t\tlet dx = 0;\n\t\tlet dy = 0;\n\n\t\t// pre-compute normals for initial \"meridian\"\n\n\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\tswitch ( j ) {\n\n\t\t\t\tcase 0:\t\t\t\t// special handling for 1st vertex on path\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tprevNormal.copy( normal );\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ( points.length - 1 ):\t// special handling for last Vertex on path\n\n\t\t\t\t\tinitNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t\t\t// default handling for all vertices in between\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tcurNormal.copy( normal );\n\n\t\t\t\t\tnormal.x += prevNormal.x;\n\t\t\t\t\tnormal.y += prevNormal.y;\n\t\t\t\t\tnormal.z += prevNormal.z;\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tprevNormal.copy( curNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices, uvs and normals\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// normal\n\n\t\t\t\tconst x = initNormals[ 3 * j + 0 ] * sin;\n\t\t\t\tconst y = initNormals[ 3 * j + 1 ];\n\t\t\t\tconst z = initNormals[ 3 * j + 0 ] * cos;\n\n\t\t\t\tnormals.push( x, y, z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( c, d, b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\n\n\t}\n\n}\n\nclass CapsuleGeometry extends LatheGeometry {\n\n\tconstructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {\n\n\t\tconst path = new Path();\n\t\tpath.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );\n\t\tpath.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );\n\n\t\tsuper( path.getPoints( capSegments ), radialSegments );\n\n\t\tthis.type = 'CapsuleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tlength: length,\n\t\t\tcapSegments: capSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );\n\n\t}\n\n}\n\nclass CircleGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tsegments = Math.max( 3, segments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass CylinderGeometry extends BufferGeometry {\n\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tif ( radiusTop > 0 || y !== 0 ) {\n\n\t\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\t\tgroupCount += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( radiusBottom > 0 || y !== heightSegments - 1 ) {\n\n\t\t\t\t\t\tindices.push( b, c, d );\n\t\t\t\t\t\tgroupCount += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ConeGeometry extends CylinderGeometry {\n\n\tconstructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass PolyhedronGeometry extends BufferGeometry {\n\n\tconstructor( vertices = [], indices = [], radius = 1, detail = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivision with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );\n\n\t}\n\n}\n\nclass DodecahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tconst r = 1 / t;\n\n\t\tconst vertices = [\n\n\t\t\t// (1, 1, 1)\n\t\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t\t// (0, 1/, )\n\t\t\t0, - r, - t, 0, - r, t,\n\t\t\t0, r, - t, 0, r, t,\n\n\t\t\t// (1/, , 0)\n\t\t\t- r, - t, 0, - r, t, 0,\n\t\t\tr, - t, 0, r, t, 0,\n\n\t\t\t// (, 0, 1/)\n\t\t\t- t, 0, - r, t, 0, - r,\n\t\t\t- t, 0, r, t, 0, r\n\t\t];\n\n\t\tconst indices = [\n\t\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new DodecahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1$1 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\nconst _triangle = /*@__PURE__*/ new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null, thresholdAngle = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry,\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\t\tconst thresholdDot = Math.cos( DEG2RAD * thresholdAngle );\n\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\t\tconst indexArr = [ 0, 0, 0 ];\n\t\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\t\tconst hashes = new Array( 3 );\n\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\t\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst { a, b, c } = _triangle;\n\t\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t\t// create hashes for the edge from the vertices\n\t\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t\t// skip degenerate triangles\n\t\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over every edge\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\t\tfor ( const key in edgeData ) {\n\n\t\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t\t_v1$1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\t\tvertices.push( _v1$1.x, _v1$1.y, _v1$1.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Shape extends Path {\n\n\tconstructor( points ) {\n\n\t\tsuper( points );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.type = 'Shape';\n\n\t\tthis.holes = [];\n\n\t}\n\n\tgetPointsHoles( divisions ) {\n\n\t\tconst holesPts = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t}\n\n\t// get points of shape and holes (keypoints based on segments parameter)\n\n\textractPoints( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = source.holes[ i ];\n\n\t\t\tthis.holes.push( hole.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.holes = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = this.holes[ i ];\n\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.uuid = json.uuid;\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = json.holes[ i ];\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.4)\n */\n\nconst Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim = 2 ) {\n\n\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\tconst outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;\n\t\tlet outerNode = linkedList( data, 0, outerLen, dim, true );\n\t\tconst triangles = [];\n\n\t\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\n\n\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( let i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 32767 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tlet i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tlet p = start,\n\t\tagain;\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tlet stop = ear,\n\t\tprev, next;\n\n\t// iterate through ears, slicing them one by one\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim | 0 );\n\t\t\ttriangles.push( ear.i / dim | 0 );\n\t\t\ttriangles.push( next.i / dim | 0 );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertex leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( filterPoints( ear ), triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar( ear ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\tlet p = c.next;\n\twhile ( p !== a ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\t// z-order range for the current triangle bbox;\n\tconst minZ = zOrder( x0, y0, minX, minY, invSize ),\n\t\tmaxZ = zOrder( x1, y1, minX, minY, invSize );\n\n\tlet p = ear.prevZ,\n\t\tn = ear.nextZ;\n\n\t// look for points inside the triangle in both directions\n\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\t// look for remaining points in decreasing z-order\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t}\n\n\t// look for remaining points in increasing z-order\n\twhile ( n && n.z <= maxZ ) {\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tconst a = p.prev,\n\t\t\tb = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim | 0 );\n\t\t\ttriangles.push( p.i / dim | 0 );\n\t\t\ttriangles.push( b.i / dim | 0 );\n\n\t\t\t// remove two nodes involved\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn filterPoints( p );\n\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\tlet a = start;\n\tdo {\n\n\t\tlet b = a.next.next;\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\tlet c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tconst queue = [];\n\tlet i, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\touterNode = eliminateHole( queue[ i ], outerNode );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole( hole, outerNode ) {\n\n\tconst bridge = findHoleBridge( hole, outerNode );\n\tif ( ! bridge ) {\n\n\t\treturn outerNode;\n\n\t}\n\n\tconst bridgeReverse = splitPolygon( bridge, hole );\n\n\t// filter collinear points around the cuts\n\tfilterPoints( bridgeReverse, bridgeReverse.next );\n\treturn filterPoints( bridge, bridge.next );\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge( hole, outerNode ) {\n\n\tlet p = outerNode,\n\t\tqx = - Infinity,\n\t\tm;\n\n\tconst hx = hole.x, hy = hole.y;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tconst x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\tif ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tconst stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y;\n\tlet tanMin = Infinity, tan;\n\n\tp = m;\n\n\tdo {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== stop );\n\n\treturn m;\n\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector( m, p ) {\n\n\treturn area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;\n\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tif ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked( list ) {\n\n\tlet i, p, q, e, tail, numMerges, pSize, qSize,\n\t\tinSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\tx = ( x - minX ) * invSize | 0;\n\ty = ( y - minY ) * invSize | 0;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost( start ) {\n\n\tlet p = start,\n\t\tleftmost = start;\n\tdo {\n\n\t\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&\n           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&\n           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges\n           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible\n            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors\n            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case\n\n}\n\n// signed area of a triangle\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tconst o1 = sign( area( p1, q1, p2 ) );\n\tconst o2 = sign( area( p1, q1, q2 ) );\n\tconst o3 = sign( area( p2, q2, p1 ) );\n\tconst o4 = sign( area( p2, q2, q1 ) );\n\n\tif ( o1 !== o2 && o3 !== o4 ) return true; // general case\n\n\tif ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\tif ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\tif ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\tif ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\treturn false;\n\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment( p, q, r ) {\n\n\treturn q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );\n\n}\n\nfunction sign( num ) {\n\n\treturn num > 0 ? 1 : num < 0 ? - 1 : 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon( a, b ) {\n\n\tlet p = a;\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\tintersects( p, p.next, a, b ) ) return true;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside( a, b ) {\n\n\tlet p = a,\n\t\tinside = false;\n\tconst px = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\n\t\t\tinside = ! inside;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon( a, b ) {\n\n\tconst a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode( i, x, y, last ) {\n\n\tconst p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertex index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertex nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = 0;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tlet sum = 0;\n\tfor ( let i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\nclass ShapeUtils {\n\n\t// calculate area of the contour polygon\n\n\tstatic area( contour ) {\n\n\t\tconst n = contour.length;\n\t\tlet a = 0.0;\n\n\t\tfor ( let p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t}\n\n\tstatic isClockWise( pts ) {\n\n\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t}\n\n\tstatic triangulateShape( contour, holes ) {\n\n\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\tconst holeIndices = []; // array of hole indices\n\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\tremoveDupEndPts( contour );\n\t\taddContour( vertices, contour );\n\n\t\t//\n\n\t\tlet holeIndex = contour.length;\n\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfor ( let i = 0; i < holes.length; i ++ ) {\n\n\t\t\tholeIndices.push( holeIndex );\n\t\t\tholeIndex += holes[ i ].length;\n\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t}\n\n\t\treturn faces;\n\n\t}\n\n}\n\nfunction removeDupEndPts( points ) {\n\n\tconst l = points.length;\n\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\tpoints.pop();\n\n\t}\n\n}\n\nfunction addContour( vertices, contour ) {\n\n\tfor ( let i = 0; i < contour.length; i ++ ) {\n\n\t\tvertices.push( contour[ i ].x );\n\t\tvertices.push( contour[ i ].y );\n\n\t}\n\n}\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\n\nclass ExtrudeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tconst depth = options.depth !== undefined ? options.depth : 1;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\n\n\t\t\t\treturn pt.clone().addScaledVector( vec, size );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length, flen = faces.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON$1( shapes, options, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\tconst extrudePath = data.options.extrudePath;\n\n\t\tif ( extrudePath !== undefined ) {\n\n\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t}\n\n\t\treturn new ExtrudeGeometry( geometryShapes, data.options );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON$1( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tdata.options = Object.assign( {}, options );\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\nclass IcosahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tconst vertices = [\n\t\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t\t0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t\tt, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t\t1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t\t3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t\t4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new IcosahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass OctahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t\t1, 3, 4,\t1, 4, 2\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new OctahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass PlaneGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tconst width_half = width / 2;\n\t\tconst height_half = height / 2;\n\n\t\tconst gridX = Math.floor( widthSegments );\n\t\tconst gridY = Math.floor( heightSegments );\n\n\t\tconst gridX1 = gridX + 1;\n\t\tconst gridY1 = gridY + 1;\n\n\t\tconst segment_width = width / gridX;\n\t\tconst segment_height = height / gridY;\n\n\t\t//\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tconst x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );\n\n\t}\n\n}\n\nclass RingGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthetaSegments = Math.max( 3, thetaSegments );\n\t\tphiSegments = Math.max( 1, phiSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ShapeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet groupStart = 0;\n\t\tlet groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\tconst points = shape.extractPoints( curveSegments );\n\n\t\t\tlet shapeVertices = points.shape;\n\t\t\tconst shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\treturn new ShapeGeometry( geometryShapes, data.curveSegments );\n\n\t}\n\n}\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\nclass SphereGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy === 0 && thetaStart === 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy === heightSegments && thetaEnd === Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass TetrahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TetrahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass TorusGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\ttubularSegments = Math.floor( tubularSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst center = new Vector3();\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tconst b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tconst c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tconst d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );\n\n\t}\n\n}\n\nclass TorusKnotGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\ttubularSegments = Math.floor( tubularSegments );\n\t\tradialSegments = Math.floor( radialSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segment\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );\n\n\t}\n\n}\n\nclass TubeGeometry extends BufferGeometry {\n\n\tconstructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\treturn new TubeGeometry(\n\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\tdata.tubularSegments,\n\t\t\tdata.radius,\n\t\t\tdata.radialSegments,\n\t\t\tdata.closed\n\t\t);\n\n\t}\n\n}\n\nclass WireframeGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'WireframeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\t// buffer\n\n\t\t\tconst vertices = [];\n\t\t\tconst edges = new Set();\n\n\t\t\t// helper variables\n\n\t\t\tconst start = new Vector3();\n\t\t\tconst end = new Vector3();\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// create a data structure that contains all edges without duplicates\n\n\t\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tconst group = groups[ o ];\n\n\t\t\t\t\tconst groupStart = group.start;\n\t\t\t\t\tconst groupCount = group.count;\n\n\t\t\t\t\tfor ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index1 = indices.getX( i + j );\n\t\t\t\t\t\t\tconst index2 = indices.getX( i + ( j + 1 ) % 3 );\n\n\t\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\n\n\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction isUniqueEdge( start, end, edges ) {\n\n\tconst hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n\tconst hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n\tif ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {\n\n\t\treturn false;\n\n\t} else {\n\n\t\tedges.add( hash1 );\n\t\tedges.add( hash2 );\n\t\treturn true;\n\n\t}\n\n}\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBoxGeometry: BoxGeometry,\n\tCapsuleGeometry: CapsuleGeometry,\n\tCircleGeometry: CircleGeometry,\n\tConeGeometry: ConeGeometry,\n\tCylinderGeometry: CylinderGeometry,\n\tDodecahedronGeometry: DodecahedronGeometry,\n\tEdgesGeometry: EdgesGeometry,\n\tExtrudeGeometry: ExtrudeGeometry,\n\tIcosahedronGeometry: IcosahedronGeometry,\n\tLatheGeometry: LatheGeometry,\n\tOctahedronGeometry: OctahedronGeometry,\n\tPlaneGeometry: PlaneGeometry,\n\tPolyhedronGeometry: PolyhedronGeometry,\n\tRingGeometry: RingGeometry,\n\tShapeGeometry: ShapeGeometry,\n\tSphereGeometry: SphereGeometry,\n\tTetrahedronGeometry: TetrahedronGeometry,\n\tTorusGeometry: TorusGeometry,\n\tTorusKnotGeometry: TorusKnotGeometry,\n\tTubeGeometry: TubeGeometry,\n\tWireframeGeometry: WireframeGeometry\n});\n\nclass ShadowMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShadowMaterial = true;\n\n\t\tthis.type = 'ShadowMaterial';\n\n\t\tthis.color = new Color( 0x000000 );\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass RawShaderMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.isRawShaderMaterial = true;\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n}\n\nclass MeshStandardMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshStandardMaterial = true;\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 1.0;\n\t\tthis.metalness = 0.0;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhysicalMaterial = true;\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.anisotropyRotation = 0;\n\t\tthis.anisotropyMap = null;\n\n\t\tthis.clearcoatMap = null;\n\t\tthis.clearcoatRoughness = 0.0;\n\t\tthis.clearcoatRoughnessMap = null;\n\t\tthis.clearcoatNormalScale = new Vector2( 1, 1 );\n\t\tthis.clearcoatNormalMap = null;\n\n\t\tthis.ior = 1.5;\n\n\t\tObject.defineProperty( this, 'reflectivity', {\n\t\t\tget: function () {\n\n\t\t\t\treturn ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );\n\n\t\t\t},\n\t\t\tset: function ( reflectivity ) {\n\n\t\t\t\tthis.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );\n\n\t\t\t}\n\t\t} );\n\n\t\tthis.iridescenceMap = null;\n\t\tthis.iridescenceIOR = 1.3;\n\t\tthis.iridescenceThicknessRange = [ 100, 400 ];\n\t\tthis.iridescenceThicknessMap = null;\n\n\t\tthis.sheenColor = new Color( 0x000000 );\n\t\tthis.sheenColorMap = null;\n\t\tthis.sheenRoughness = 1.0;\n\t\tthis.sheenRoughnessMap = null;\n\n\t\tthis.transmissionMap = null;\n\n\t\tthis.thickness = 0;\n\t\tthis.thicknessMap = null;\n\t\tthis.attenuationDistance = Infinity;\n\t\tthis.attenuationColor = new Color( 1, 1, 1 );\n\n\t\tthis.specularIntensity = 1.0;\n\t\tthis.specularIntensityMap = null;\n\t\tthis.specularColor = new Color( 1, 1, 1 );\n\t\tthis.specularColorMap = null;\n\n\t\tthis._anisotropy = 0;\n\t\tthis._clearcoat = 0;\n\t\tthis._dispersion = 0;\n\t\tthis._iridescence = 0;\n\t\tthis._sheen = 0.0;\n\t\tthis._transmission = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget anisotropy() {\n\n\t\treturn this._anisotropy;\n\n\t}\n\n\tset anisotropy( value ) {\n\n\t\tif ( this._anisotropy > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._anisotropy = value;\n\n\t}\n\n\tget clearcoat() {\n\n\t\treturn this._clearcoat;\n\n\t}\n\n\tset clearcoat( value ) {\n\n\t\tif ( this._clearcoat > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._clearcoat = value;\n\n\t}\n\n\tget iridescence() {\n\n\t\treturn this._iridescence;\n\n\t}\n\n\tset iridescence( value ) {\n\n\t\tif ( this._iridescence > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._iridescence = value;\n\n\t}\n\n\tget dispersion() {\n\n\t\treturn this._dispersion;\n\n\t}\n\n\tset dispersion( value ) {\n\n\t\tif ( this._dispersion > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._dispersion = value;\n\n\t}\n\n\tget sheen() {\n\n\t\treturn this._sheen;\n\n\t}\n\n\tset sheen( value ) {\n\n\t\tif ( this._sheen > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._sheen = value;\n\n\t}\n\n\tget transmission() {\n\n\t\treturn this._transmission;\n\n\t}\n\n\tset transmission( value ) {\n\n\t\tif ( this._transmission > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._transmission = value;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.anisotropy = source.anisotropy;\n\t\tthis.anisotropyRotation = source.anisotropyRotation;\n\t\tthis.anisotropyMap = source.anisotropyMap;\n\n\t\tthis.clearcoat = source.clearcoat;\n\t\tthis.clearcoatMap = source.clearcoatMap;\n\t\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\t\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\t\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\t\tthis.clearcoatNormalScale.copy( source.clearcoatNormalScale );\n\n\t\tthis.dispersion = source.dispersion;\n\t\tthis.ior = source.ior;\n\n\t\tthis.iridescence = source.iridescence;\n\t\tthis.iridescenceMap = source.iridescenceMap;\n\t\tthis.iridescenceIOR = source.iridescenceIOR;\n\t\tthis.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];\n\t\tthis.iridescenceThicknessMap = source.iridescenceThicknessMap;\n\n\t\tthis.sheen = source.sheen;\n\t\tthis.sheenColor.copy( source.sheenColor );\n\t\tthis.sheenColorMap = source.sheenColorMap;\n\t\tthis.sheenRoughness = source.sheenRoughness;\n\t\tthis.sheenRoughnessMap = source.sheenRoughnessMap;\n\n\t\tthis.transmission = source.transmission;\n\t\tthis.transmissionMap = source.transmissionMap;\n\n\t\tthis.thickness = source.thickness;\n\t\tthis.thicknessMap = source.thicknessMap;\n\t\tthis.attenuationDistance = source.attenuationDistance;\n\t\tthis.attenuationColor.copy( source.attenuationColor );\n\n\t\tthis.specularIntensity = source.specularIntensity;\n\t\tthis.specularIntensityMap = source.specularIntensityMap;\n\t\tthis.specularColor.copy( source.specularColor );\n\t\tthis.specularColorMap = source.specularColorMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhongMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhongMaterial = true;\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshToonMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshToonMaterial = true;\n\n\t\tthis.defines = { 'TOON': '' };\n\n\t\tthis.type = 'MeshToonMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\t\tthis.gradientMap = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\t\tthis.gradientMap = source.gradientMap;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshNormalMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshNormalMaterial = true;\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshLambertMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshLambertMaterial = true;\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapRotation = new Euler();\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapRotation.copy( source.envMapRotation );\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshDepthMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDepthMaterial = true;\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshDistanceMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDistanceMaterial = true;\n\n\t\tthis.type = 'MeshDistanceMaterial';\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshMatcapMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshMatcapMaterial = true;\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.type = 'MeshMatcapMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.matcap = null;\n\n\t\tthis.map = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.matcap = source.matcap;\n\n\t\tthis.map = source.map;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineDashedMaterial extends LineBasicMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineDashedMaterial = true;\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// converts an array to a specific type\nfunction convertArray( array, type, forceClone ) {\n\n\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t! forceClone && array.constructor === type ) return array;\n\n\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\treturn new type( array ); // create typed array\n\n\t}\n\n\treturn Array.prototype.slice.call( array ); // create Array\n\n}\n\nfunction isTypedArray( object ) {\n\n\treturn ArrayBuffer.isView( object ) &&\n\t\t! ( object instanceof DataView );\n\n}\n\n// returns an array by which times and values can be sorted\nfunction getKeyframeOrder( times ) {\n\n\tfunction compareTime( i, j ) {\n\n\t\treturn times[ i ] - times[ j ];\n\n\t}\n\n\tconst n = times.length;\n\tconst result = new Array( n );\n\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\tresult.sort( compareTime );\n\n\treturn result;\n\n}\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nfunction sortedArray( values, stride, order ) {\n\n\tconst nValues = values.length;\n\tconst result = new values.constructor( nValues );\n\n\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\tconst srcOffset = order[ i ] * stride;\n\n\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n// function for parsing AOS keyframe formats\nfunction flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\tlet i = 1, key = jsonKeys[ 0 ];\n\n\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\tkey = jsonKeys[ i ++ ];\n\n\t}\n\n\tif ( key === undefined ) return; // no data\n\n\tlet value = key[ valuePropertyName ];\n\tif ( value === undefined ) return; // no data\n\n\tif ( Array.isArray( value ) ) {\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else if ( value.toArray !== undefined ) {\n\n\t\t// ...assume THREE.Math-ish\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else {\n\n\t\t// otherwise push as-is\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( value );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t}\n\n}\n\nfunction subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\tconst clip = sourceClip.clone();\n\n\tclip.name = name;\n\n\tconst tracks = [];\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tconst track = clip.tracks[ i ];\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( times.length === 0 ) continue;\n\n\t\ttrack.times = convertArray( times, track.times.constructor );\n\t\ttrack.values = convertArray( values, track.values.constructor );\n\n\t\ttracks.push( track );\n\n\t}\n\n\tclip.tracks = tracks;\n\n\t// find minimum .times value across all tracks in the trimmed clip\n\n\tlet minStartTime = Infinity;\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t}\n\n\t}\n\n\t// shift all tracks such that clip begins at t=0\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t}\n\n\tclip.resetDuration();\n\n\treturn clip;\n\n}\n\nfunction makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\tif ( fps <= 0 ) fps = 30;\n\n\tconst numTracks = referenceClip.tracks.length;\n\tconst referenceTime = referenceFrame / fps;\n\n\t// Make each track's values relative to the values at the reference frame\n\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t// Skip this track if it's non-numeric\n\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t} );\n\n\t\tif ( targetTrack === undefined ) continue;\n\n\t\tlet referenceOffset = 0;\n\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t}\n\n\t\tlet targetOffset = 0;\n\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t}\n\n\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\tlet referenceValue;\n\n\t\t// Find the value to subtract out of the track\n\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\treferenceValue = referenceTrack.values.slice( startIndex, endIndex );\n\n\t\t} else {\n\n\t\t\t// Interpolate to the reference value\n\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\treferenceValue = interpolant.resultBuffer.slice( startIndex, endIndex );\n\n\t\t}\n\n\t\t// Conjugate the quaternion\n\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t}\n\n\t\t// Subtract the reference value from all of the track values\n\n\t\tconst numTimes = targetTrack.times.length;\n\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart,\n\t\t\t\t\treferenceValue,\n\t\t\t\t\t0,\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\treturn targetClip;\n\n}\n\nconst AnimationUtils = {\n\tconvertArray: convertArray,\n\tisTypedArray: isTypedArray,\n\tgetKeyframeOrder: getKeyframeOrder,\n\tsortedArray: sortedArray,\n\tflattenJSON: flattenJSON,\n\tsubclip: subclip,\n\tmakeClipAdditive: makeClipAdditive\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t\tthis.settings = null;\n\t\tthis.DefaultSettings_ = {};\n\n\t}\n\n\tevaluate( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t}\n\n\tgetSettings_() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t// Template methods for derived classes:\n\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t}\n\n\tintervalChanged_( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n}\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = - 0;\n\t\tthis._offsetPrev = - 0;\n\t\tthis._weightNext = - 0;\n\t\tthis._offsetNext = - 0;\n\n\t\tthis.DefaultSettings_ = {\n\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\n\t\t};\n\n\t}\n\n\tintervalChanged_( i1, t0, t1 ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet iPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nclass LinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceding\n * the parameter.\n */\n\nclass DiscreteInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n}\n\nclass KeyframeTrack {\n\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = convertArray( times, this.TimeBufferType );\n\t\tthis.values = convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': convertArray( track.times, Array ),\n\t\t\t\t'values': convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t// move all keyframes either forwards or backwards in time\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = times.slice( from, to );\n\t\t\tthis.values = this.values.slice( from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize() {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = this.times.slice(),\n\t\t\tvalues = this.values.slice(),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = times.slice( 0, writeIndex );\n\t\t\tthis.values = values.slice( 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst times = this.times.slice();\n\t\tconst values = this.values.slice();\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {\n\n\t// No interpolation parameter because only InterpolateDiscrete is valid.\n\tconstructor( name, times, values ) {\n\n\t\tsuper( name, times, values );\n\n\t}\n\n}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tlet offset = i1 * stride;\n\n\t\tfor ( let end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\n// DefaultInterpolation is inherited;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {\n\n\t// No interpolation parameter because only InterpolateDiscrete is valid.\n\tconstructor( name, times, values ) {\n\n\t\tsuper( name, times, values );\n\n\t}\n\n}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n\nclass AnimationClip {\n\n\tconstructor( name = '', duration = - 1, tracks = [], blendMode = NormalAnimationBlendMode ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = duration;\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = getKeyframeOrder( times );\n\t\t\ttimes = sortedArray( times, 1, order );\n\t\t\tvalues = sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t// parse the animation.hierarchy format\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tflattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * fps;\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tflattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nconst Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\nclass LoadingManager {\n\n\tconstructor( onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet isLoading = false;\n\t\tlet itemsLoaded = 0;\n\t\tlet itemsTotal = 0;\n\t\tlet urlModifier = undefined;\n\t\tconst handlers = [];\n\n\t\t// Refer to #5689 for the reason why we don't set .onStart\n\t\t// in the constructor\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.resolveURL = function ( url ) {\n\n\t\t\tif ( urlModifier ) {\n\n\t\t\t\treturn urlModifier( url );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t};\n\n\t\tthis.setURLModifier = function ( transform ) {\n\n\t\t\turlModifier = transform;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.addHandler = function ( regex, loader ) {\n\n\t\t\thandlers.push( regex, loader );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.removeHandler = function ( regex ) {\n\n\t\t\tconst index = handlers.indexOf( regex );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\thandlers.splice( index, 2 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.getHandler = function ( file ) {\n\n\t\t\tfor ( let i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tconst regex = handlers[ i ];\n\t\t\t\tconst loader = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t}\n\n}\n\nconst DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();\n\nclass Loader {\n\n\tconstructor( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.crossOrigin = 'anonymous';\n\t\tthis.withCredentials = false;\n\t\tthis.path = '';\n\t\tthis.resourcePath = '';\n\t\tthis.requestHeader = {};\n\n\t}\n\n\tload( /* url, onLoad, onProgress, onError */ ) {}\n\n\tloadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.load( url, resolve, onProgress, reject );\n\n\t\t} );\n\n\t}\n\n\tparse( /* data */ ) {}\n\n\tsetCrossOrigin( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t}\n\n\tsetWithCredentials( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t}\n\n\tsetResourcePath( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n\tsetRequestHeader( requestHeader ) {\n\n\t\tthis.requestHeader = requestHeader;\n\t\treturn this;\n\n\t}\n\n}\n\nLoader.DEFAULT_MATERIAL_NAME = '__DEFAULT';\n\nconst loading = {};\n\nclass HttpError extends Error {\n\n\tconstructor( message, response ) {\n\n\t\tsuper( message );\n\t\tthis.response = response;\n\n\t}\n\n}\n\nclass FileLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tsetTimeout( () => {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Initialise array for duplicate requests\n\t\tloading[ url ] = [];\n\n\t\tloading[ url ].push( {\n\t\t\tonLoad: onLoad,\n\t\t\tonProgress: onProgress,\n\t\t\tonError: onError,\n\t\t} );\n\n\t\t// create request\n\t\tconst req = new Request( url, {\n\t\t\theaders: new Headers( this.requestHeader ),\n\t\t\tcredentials: this.withCredentials ? 'include' : 'same-origin',\n\t\t\t// An abort controller could be added within a future PR\n\t\t} );\n\n\t\t// record states ( avoid data race )\n\t\tconst mimeType = this.mimeType;\n\t\tconst responseType = this.responseType;\n\n\t\t// start the fetch\n\t\tfetch( req )\n\t\t\t.then( response => {\n\n\t\t\t\tif ( response.status === 200 || response.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( response.status === 0 ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n\t\t\t\t\tif ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {\n\n\t\t\t\t\t\treturn response;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\t// Nginx needs X-File-Size check\n\t\t\t\t\t// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n\t\t\t\t\tconst contentLength = response.headers.get( 'X-File-Size' ) || response.headers.get( 'Content-Length' );\n\t\t\t\t\tconst total = contentLength ? parseInt( contentLength ) : 0;\n\t\t\t\t\tconst lengthComputable = total !== 0;\n\t\t\t\t\tlet loaded = 0;\n\n\t\t\t\t\t// periodically read data into the new stream tracking while download progress\n\t\t\t\t\tconst stream = new ReadableStream( {\n\t\t\t\t\t\tstart( controller ) {\n\n\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\tfunction readData() {\n\n\t\t\t\t\t\t\t\treader.read().then( ( { done, value } ) => {\n\n\t\t\t\t\t\t\t\t\tif ( done ) {\n\n\t\t\t\t\t\t\t\t\t\tcontroller.close();\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\n\n\t\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tcontroller.enqueue( value );\n\t\t\t\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}, ( e ) => {\n\n\t\t\t\t\t\t\t\t\tcontroller.error( e );\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn new Response( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new HttpError( `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( response => {\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\n\t\t\t\t\t\treturn response.arrayBuffer();\n\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\treturn response.blob();\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\treturn response.text()\n\t\t\t\t\t\t\t.then( text => {\n\n\t\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\t\treturn parser.parseFromString( text, mimeType );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\treturn response.json();\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( mimeType === undefined ) {\n\n\t\t\t\t\t\t\treturn response.text();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// sniff encoding\n\t\t\t\t\t\t\tconst re = /charset=\"?([^;\"\\s]*)\"?/i;\n\t\t\t\t\t\t\tconst exec = re.exec( mimeType );\n\t\t\t\t\t\t\tconst label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;\n\t\t\t\t\t\t\tconst decoder = new TextDecoder( label );\n\t\t\t\t\t\t\treturn response.arrayBuffer().then( ab => decoder.decode( ab ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( data => {\n\n\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\tCache.add( url, data );\n\n\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( data );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( err => {\n\n\t\t\t\t// Abort errors and other errors are handled the same\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tif ( callbacks === undefined ) {\n\n\t\t\t\t\t// When onLoad was called and url was deleted in `loading`\n\t\t\t\t\tthis.manager.itemError( url );\n\t\t\t\t\tthrow err;\n\n\t\t\t\t}\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( err );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t} )\n\t\t\t.finally( () => {\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\tthis.manager.itemStart( url );\n\n\t}\n\n\tsetResponseType( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t}\n\n\tsetMimeType( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n}\n\nclass AnimationLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst animations = [];\n\n\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\tconst clip = AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass CompressedTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.image = images;\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.image = images;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass ImageLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst image = createElementNS( 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction removeEventListeners() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.slice( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n}\n\nclass CubeTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( urls, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new CubeTexture();\n\t\ttexture.colorSpace = SRGBColorSpace;\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass DataTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst texture = new DataTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tlet texData;\n\n\t\t\ttry {\n\n\t\t\t\ttexData = scope.parse( buffer );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) {\n\n\t\t\t\t\tonError( error );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = texData.colorSpace;\n\n\t\t\t}\n\n\t\t\tif ( texData.flipY !== undefined ) {\n\n\t\t\t\ttexture.flipY = texData.flipY;\n\n\t\t\t}\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\tif ( texData.generateMipmaps !== undefined ) {\n\n\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass TextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass Light extends Object3D {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.isLight = true;\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity;\n\n\t}\n\n\tdispose() {\n\n\t\t// Empty here in base class; some subclasses override.\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\t\tif ( this.target !== undefined ) data.object.target = this.target.uuid;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass HemisphereLight extends Light {\n\n\tconstructor( skyColor, groundColor, intensity ) {\n\n\t\tsuper( skyColor, intensity );\n\n\t\tthis.isHemisphereLight = true;\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();\nconst _lookTarget$1 = /*@__PURE__*/ new Vector3();\n\nclass LightShadow {\n\n\tconstructor( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.intensity = 1;\n\n\t\tthis.bias = 0;\n\t\tthis.normalBias = 0;\n\t\tthis.radius = 1;\n\t\tthis.blurSamples = 8;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.mapPass = null;\n\t\tthis.matrix = new Matrix4();\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis._frustum = new Frustum();\n\t\tthis._frameExtents = new Vector2( 1, 1 );\n\n\t\tthis._viewportCount = 1;\n\n\t\tthis._viewports = [\n\n\t\t\tnew Vector4( 0, 0, 1, 1 )\n\n\t\t];\n\n\t}\n\n\tgetViewportCount() {\n\n\t\treturn this._viewportCount;\n\n\t}\n\n\tgetFrustum() {\n\n\t\treturn this._frustum;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst shadowCamera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\t_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );\n\t\tshadowCamera.position.copy( _lightPositionWorld$1 );\n\n\t\t_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );\n\t\tshadowCamera.lookAt( _lookTarget$1 );\n\t\tshadowCamera.updateMatrixWorld();\n\n\t\t_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );\n\n\t\tshadowMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\n\t\tshadowMatrix.multiply( _projScreenMatrix$1 );\n\n\t}\n\n\tgetViewport( viewportIndex ) {\n\n\t\treturn this._viewports[ viewportIndex ];\n\n\t}\n\n\tgetFrameExtents() {\n\n\t\treturn this._frameExtents;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.map ) {\n\n\t\t\tthis.map.dispose();\n\n\t\t}\n\n\t\tif ( this.mapPass ) {\n\n\t\t\tthis.mapPass.dispose();\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.intensity = source.intensity;\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst object = {};\n\n\t\tif ( this.intensity !== 1 ) object.intensity = this.intensity;\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.normalBias !== 0 ) object.normalBias = this.normalBias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n}\n\nclass SpotLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t\tthis.isSpotLightShadow = true;\n\n\t\tthis.focus = 1;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst camera = this.camera;\n\n\t\tconst fov = RAD2DEG * 2 * light.angle * this.focus;\n\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\tsuper.updateMatrices( light );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.focus = source.focus;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SpotLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isSpotLight = true;\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.distance = distance;\n\t\tthis.angle = angle;\n\t\tthis.penumbra = penumbra;\n\t\tthis.decay = decay;\n\n\t\tthis.map = null;\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)\n\t\treturn this.intensity * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / Math.PI;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nclass PointLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t\tthis.isPointLightShadow = true;\n\n\t\tthis._frameExtents = new Vector2( 4, 2 );\n\n\t\tthis._viewportCount = 6;\n\n\t\tthis._viewports = [\n\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//  xzXZ\n\t\t\t//   y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\n\t\t\t// positive X\n\t\t\tnew Vector4( 2, 1, 1, 1 ),\n\t\t\t// negative X\n\t\t\tnew Vector4( 0, 1, 1, 1 ),\n\t\t\t// positive Z\n\t\t\tnew Vector4( 3, 1, 1, 1 ),\n\t\t\t// negative Z\n\t\t\tnew Vector4( 1, 1, 1, 1 ),\n\t\t\t// positive Y\n\t\t\tnew Vector4( 3, 0, 1, 1 ),\n\t\t\t// negative Y\n\t\t\tnew Vector4( 1, 0, 1, 1 )\n\t\t];\n\n\t\tthis._cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tthis._cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t}\n\n\tupdateMatrices( light, viewportIndex = 0 ) {\n\n\t\tconst camera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( far !== camera.far ) {\n\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\tcamera.position.copy( _lightPositionWorld );\n\n\t\t_lookTarget.copy( camera.position );\n\t\t_lookTarget.add( this._cubeDirections[ viewportIndex ] );\n\t\tcamera.up.copy( this._cubeUps[ viewportIndex ] );\n\t\tcamera.lookAt( _lookTarget );\n\t\tcamera.updateMatrixWorld();\n\n\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t}\n\n}\n\nclass PointLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isPointLight = true;\n\n\t\tthis.type = 'PointLight';\n\n\t\tthis.distance = distance;\n\t\tthis.decay = decay;\n\n\t\tthis.shadow = new PointLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)\n\t\treturn this.intensity * 4 * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass OrthographicCamera extends Camera {\n\n\tconstructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isOrthographicCamera = true;\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t}\n\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tconst dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tconst cx = ( this.right + this.left ) / 2;\n\t\tconst cy = ( this.top + this.bottom ) / 2;\n\n\t\tlet left = cx - dx;\n\t\tlet right = cx + dx;\n\t\tlet top = cy + dy;\n\t\tlet bottom = cy - dy;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;\n\t\t\tconst scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;\n\n\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\tright = left + scaleW * this.view.width;\n\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\tbottom = top - scaleH * this.view.height;\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass DirectionalLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t\tthis.isDirectionalLightShadow = true;\n\n\t}\n\n}\n\nclass DirectionalLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isDirectionalLight = true;\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.target = source.target.clone();\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass AmbientLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isAmbientLight = true;\n\n\t\tthis.type = 'AmbientLight';\n\n\t}\n\n}\n\nclass RectAreaLight extends Light {\n\n\tconstructor( color, intensity, width = 10, height = 10 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isRectAreaLight = true;\n\n\t\tthis.type = 'RectAreaLight';\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in nits)\n\t\treturn this.intensity * this.width * this.height * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in nits) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( this.width * this.height * Math.PI );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.width = this.width;\n\t\tdata.object.height = this.height;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n\n\tconstructor() {\n\n\t\tthis.isSphericalHarmonics3 = true;\n\n\t\tthis.coefficients = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients.push( new Vector3() );\n\n\t\t}\n\n\t}\n\n\tset( coefficients ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].copy( coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tzero() {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get the radiance in the direction of the normal\n\t// target is a Vector3\n\tgetAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 0.488603 * y );\n\t\ttarget.addScaledVector( coeff[ 2 ], 0.488603 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 0.488603 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );\n\t\ttarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\n\t\ttarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\n\n\t\treturn target;\n\n\t}\n\n\t// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t// target is a Vector3\n\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\tgetIrradianceAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603\n\t\ttarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548\n\t\ttarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3\n\t\ttarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274\n\n\t\treturn target;\n\n\t}\n\n\tadd( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\taddScaledSH( sh, s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tscale( s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].multiplyScalar( s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tlerp( sh, alpha ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcopy( sh ) {\n\n\t\treturn this.set( sh.coefficients );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].fromArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].toArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n\t// evaluate the basis functions\n\t// shBasis is an Array[ 9 ]\n\tstatic getBasisAt( normal, shBasis ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\t// band 0\n\t\tshBasis[ 0 ] = 0.282095;\n\n\t\t// band 1\n\t\tshBasis[ 1 ] = 0.488603 * y;\n\t\tshBasis[ 2 ] = 0.488603 * z;\n\t\tshBasis[ 3 ] = 0.488603 * x;\n\n\t\t// band 2\n\t\tshBasis[ 4 ] = 1.092548 * x * y;\n\t\tshBasis[ 5 ] = 1.092548 * y * z;\n\t\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\n\t\tshBasis[ 7 ] = 1.092548 * x * z;\n\t\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\n\n\t}\n\n}\n\nclass LightProbe extends Light {\n\n\tconstructor( sh = new SphericalHarmonics3(), intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tthis.isLightProbe = true;\n\n\t\tthis.sh = sh;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.sh.copy( source.sh );\n\n\t\treturn this;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\t\tthis.sh.fromArray( json.sh );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.sh = this.sh.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass MaterialLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\t\tthis.textures = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst textures = this.textures;\n\n\t\tfunction getTexture( name ) {\n\n\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t}\n\n\t\t\treturn textures[ name ];\n\n\t\t}\n\n\t\tconst material = this.createMaterialFromType( json.type );\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.sheen !== undefined ) material.sheen = json.sheen;\n\t\tif ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );\n\t\tif ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;\n\t\tif ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;\n\t\tif ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;\n\t\tif ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\tif ( json.dispersion !== undefined ) material.dispersion = json.dispersion;\n\t\tif ( json.iridescence !== undefined ) material.iridescence = json.iridescence;\n\t\tif ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;\n\t\tif ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;\n\t\tif ( json.transmission !== undefined ) material.transmission = json.transmission;\n\t\tif ( json.thickness !== undefined ) material.thickness = json.thickness;\n\t\tif ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;\n\t\tif ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );\n\t\tif ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;\n\t\tif ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;\n\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.combine !== undefined ) material.combine = json.combine;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.alphaHash !== undefined ) material.alphaHash = json.alphaHash;\n\t\tif ( json.depthFunc !== undefined ) material.depthFunc = json.depthFunc;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.blendSrc !== undefined ) material.blendSrc = json.blendSrc;\n\t\tif ( json.blendDst !== undefined ) material.blendDst = json.blendDst;\n\t\tif ( json.blendEquation !== undefined ) material.blendEquation = json.blendEquation;\n\t\tif ( json.blendSrcAlpha !== undefined ) material.blendSrcAlpha = json.blendSrcAlpha;\n\t\tif ( json.blendDstAlpha !== undefined ) material.blendDstAlpha = json.blendDstAlpha;\n\t\tif ( json.blendEquationAlpha !== undefined ) material.blendEquationAlpha = json.blendEquationAlpha;\n\t\tif ( json.blendColor !== undefined && material.blendColor !== undefined ) material.blendColor.setHex( json.blendColor );\n\t\tif ( json.blendAlpha !== undefined ) material.blendAlpha = json.blendAlpha;\n\t\tif ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;\n\t\tif ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;\n\t\tif ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;\n\t\tif ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;\n\t\tif ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;\n\t\tif ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;\n\t\tif ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;\n\t\tif ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;\n\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\tif ( json.linewidth !== undefined ) material.linewidth = json.linewidth;\n\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\n\t\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\n\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\tif ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;\n\t\tif ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;\n\t\tif ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;\n\n\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\n\t\tif ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;\n\n\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\tif ( json.vertexColors !== undefined ) {\n\n\t\t\tif ( typeof json.vertexColors === 'number' ) {\n\n\t\t\t\tmaterial.vertexColors = ( json.vertexColors > 0 ) ? true : false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Shader Material\n\n\t\tif ( json.uniforms !== undefined ) {\n\n\t\t\tfor ( const name in json.uniforms ) {\n\n\t\t\t\tconst uniform = json.uniforms[ name ];\n\n\t\t\t\tmaterial.uniforms[ name ] = {};\n\n\t\t\t\tswitch ( uniform.type ) {\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.defines !== undefined ) material.defines = json.defines;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;\n\n\t\tif ( json.extensions !== undefined ) {\n\n\t\t\tfor ( const key in json.extensions ) {\n\n\t\t\t\tmaterial.extensions[ key ] = json.extensions[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.lights !== undefined ) material.lights = json.lights;\n\t\tif ( json.clipping !== undefined ) material.clipping = json.clipping;\n\n\t\t// for PointsMaterial\n\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\tif ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );\n\n\t\tif ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tlet normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\t\tif ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );\n\t\tif ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );\n\n\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\tif ( json.envMapRotation !== undefined ) material.envMapRotation.fromArray( json.envMapRotation );\n\t\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\tif ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\tif ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );\n\t\tif ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );\n\t\tif ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );\n\t\tif ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );\n\n\t\tif ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );\n\t\tif ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );\n\n\t\tif ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );\n\t\tif ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );\n\n\t\tif ( json.anisotropyMap !== undefined ) material.anisotropyMap = getTexture( json.anisotropyMap );\n\n\t\tif ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );\n\t\tif ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );\n\n\t\treturn material;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\tcreateMaterialFromType( type ) {\n\n\t\treturn MaterialLoader.createMaterialFromType( type );\n\n\t}\n\n\tstatic createMaterialFromType( type ) {\n\n\t\tconst materialLib = {\n\t\t\tShadowMaterial,\n\t\t\tSpriteMaterial,\n\t\t\tRawShaderMaterial,\n\t\t\tShaderMaterial,\n\t\t\tPointsMaterial,\n\t\t\tMeshPhysicalMaterial,\n\t\t\tMeshStandardMaterial,\n\t\t\tMeshPhongMaterial,\n\t\t\tMeshToonMaterial,\n\t\t\tMeshNormalMaterial,\n\t\t\tMeshLambertMaterial,\n\t\t\tMeshDepthMaterial,\n\t\t\tMeshDistanceMaterial,\n\t\t\tMeshBasicMaterial,\n\t\t\tMeshMatcapMaterial,\n\t\t\tLineDashedMaterial,\n\t\t\tLineBasicMaterial,\n\t\t\tMaterial\n\t\t};\n\n\t\treturn new materialLib[ type ]();\n\n\t}\n\n}\n\nclass LoaderUtils {\n\n\tstatic decodeText( array ) { // @deprecated, r165\n\n\t\tconsole.warn( 'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.' );\n\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\treturn new TextDecoder().decode( array );\n\n\t\t}\n\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\tlet s = '';\n\n\t\tfor ( let i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t// Implicitly assumes little-endian.\n\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// merges multi-byte utf-8 characters.\n\n\t\t\treturn decodeURIComponent( escape( s ) );\n\n\t\t} catch ( e ) { // see #16358\n\n\t\t\treturn s;\n\n\t\t}\n\n\t}\n\n\tstatic extractUrlBase( url ) {\n\n\t\tconst index = url.lastIndexOf( '/' );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.slice( 0, index + 1 );\n\n\t}\n\n\tstatic resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Host Relative URL\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t}\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n}\n\nclass InstancedBufferGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isInstancedBufferGeometry = true;\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.instanceCount = Infinity;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.instanceCount = source.instanceCount;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.instanceCount = this.instanceCount;\n\n\t\tdata.isInstancedBufferGeometry = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass BufferGeometryLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst interleavedBufferMap = {};\n\t\tconst arrayBufferMap = {};\n\n\t\tfunction getInterleavedBuffer( json, uuid ) {\n\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\n\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\n\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\n\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\n\t\t\tib.uuid = interleavedBuffer.uuid;\n\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\n\n\t\t\treturn ib;\n\n\t\t}\n\n\t\tfunction getArrayBuffer( json, uuid ) {\n\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\n\n\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\n\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\n\n\t\t\tarrayBufferMap[ uuid ] = ab;\n\n\t\t\treturn ab;\n\n\t\t}\n\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tconst index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tconst attributes = json.data.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\t\t\tlet bufferAttribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t} else {\n\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\n\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( const key in morphAttributes ) {\n\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attribute = attributeArray[ i ];\n\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t}\n\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tconst center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nclass ObjectLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\\'t load ' + url ) );\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tasync loadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await loader.loadAsync( url, onProgress );\n\n\t\tconst json = JSON.parse( text );\n\n\t\tconst metadata = json.metadata;\n\n\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\tthrow new Error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\n\t\t}\n\n\t\treturn await scope.parseAsync( json );\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\t\tthis.bindLightTargets( object );\n\n\t\t//\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\tlet hasImages = false;\n\n\t\t\tfor ( const uuid in images ) {\n\n\t\t\t\tif ( images[ uuid ].data instanceof HTMLImageElement ) {\n\n\t\t\t\t\thasImages = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasImages === false ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tasync parseAsync( json ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = await this.parseImagesAsync( json.images );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\t\tthis.bindLightTargets( object );\n\n\t\treturn object;\n\n\t}\n\n\tparseShapes( json ) {\n\n\t\tconst shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n\tparseSkeletons( json, object ) {\n\n\t\tconst skeletons = {};\n\t\tconst bones = {};\n\n\t\t// generate bone lookup table\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isBone ) bones[ child.uuid ] = child;\n\n\t\t} );\n\n\t\t// create skeletons\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst skeleton = new Skeleton().fromJSON( json[ i ], bones );\n\n\t\t\t\tskeletons[ skeleton.uuid ] = skeleton;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skeletons;\n\n\t}\n\n\tparseGeometries( json, shapes ) {\n\n\t\tconst geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tlet geometry;\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\tcase 'InstancedBufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( data.type in Geometries ) {\n\n\t\t\t\t\t\t\tgeometry = Geometries[ data.type ].fromJSON( data, shapes );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( `THREE.ObjectLoader: Unsupported geometry type \"${ data.type }\"` );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst cache = {}; // MultiMaterial\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseAnimations( json ) {\n\n\t\tconst animations = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tconst clip = AnimationClip.parse( data );\n\n\t\t\t\tanimations[ clip.uuid ] = clip;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n\tparseImages( json, onLoad ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn loadImage( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tconst manager = new LoadingManager( onLoad );\n\n\t\t\tloader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tasync parseImagesAsync( json ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tasync function deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn await loader.loadAsync( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tloader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = await deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = await deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tparseTextures( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tconst textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tconst source = images[ data.image ];\n\t\t\t\tconst image = source.data;\n\n\t\t\t\tlet texture;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture();\n\n\t\t\t\t\tif ( image.length === 6 ) texture.needsUpdate = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( image && image.data ) {\n\n\t\t\t\t\t\ttexture = new DataTexture();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new Texture();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( image ) texture.needsUpdate = true; // textures can have undefined image data\n\n\t\t\t\t}\n\n\t\t\t\ttexture.source = source;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\t\t\t\tif ( data.channel !== undefined ) texture.channel = data.channel;\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.colorSpace !== undefined ) texture.colorSpace = data.colorSpace;\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\t\t\t\tif ( data.compareFunction !== undefined ) texture.compareFunction = data.compareFunction;\n\n\t\t\t\tif ( data.userData !== undefined ) texture.userData = data.userData;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t}\n\n\tparseObject( data, geometries, materials, textures, animations ) {\n\n\t\tlet object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tfunction getTexture( uuid ) {\n\n\t\t\tif ( textures[ uuid ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined texture', uuid );\n\n\t\t\t}\n\n\t\t\treturn textures[ uuid ];\n\n\t\t}\n\n\t\tlet geometry, material;\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.background = getTexture( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.environment !== undefined ) {\n\n\t\t\t\t\tobject.environment = getTexture( data.environment );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.fog.name !== '' ) {\n\n\t\t\t\t\t\tobject.fog.name = data.fog.name;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;\n\t\t\t\tif ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;\n\t\t\t\tif ( data.backgroundRotation !== undefined ) object.backgroundRotation.fromArray( data.backgroundRotation );\n\n\t\t\t\tif ( data.environmentIntensity !== undefined ) object.environmentIntensity = data.environmentIntensity;\n\t\t\t\tif ( data.environmentRotation !== undefined ) object.environmentRotation.fromArray( data.environmentRotation );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\t\t\t\tobject.target = data.target || '';\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\t\t\t\tobject.target = data.target || '';\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LightProbe':\n\n\t\t\t\tobject = new LightProbe().fromJSON( data );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t \tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\tif ( data.bindMode !== undefined ) object.bindMode = data.bindMode;\n\t\t\t\tif ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );\n\t\t\t\tif ( data.skeleton !== undefined ) object.skeleton = data.skeleton;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'InstancedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\t\t\t\tconst count = data.count;\n\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\tconst instanceColor = data.instanceColor;\n\n\t\t\t\tobject = new InstancedMesh( geometry, material, count );\n\t\t\t\tobject.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\n\t\t\t\tif ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'BatchedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new BatchedMesh( data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material );\n\t\t\t\tobject.geometry = geometry;\n\t\t\t\tobject.perObjectFrustumCulled = data.perObjectFrustumCulled;\n\t\t\t\tobject.sortObjects = data.sortObjects;\n\n\t\t\t\tobject._drawRanges = data.drawRanges;\n\t\t\t\tobject._reservedRanges = data.reservedRanges;\n\n\t\t\t\tobject._visibility = data.visibility;\n\t\t\t\tobject._active = data.active;\n\t\t\t\tobject._bounds = data.bounds.map( bound => {\n\n\t\t\t\t\tconst box = new Box3();\n\t\t\t\t\tbox.min.fromArray( bound.boxMin );\n\t\t\t\t\tbox.max.fromArray( bound.boxMax );\n\n\t\t\t\t\tconst sphere = new Sphere();\n\t\t\t\t\tsphere.radius = bound.sphereRadius;\n\t\t\t\t\tsphere.center.fromArray( bound.sphereCenter );\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tboxInitialized: bound.boxInitialized,\n\t\t\t\t\t\tbox: box,\n\n\t\t\t\t\t\tsphereInitialized: bound.sphereInitialized,\n\t\t\t\t\t\tsphere: sphere\n\t\t\t\t\t};\n\n\t\t\t\t} );\n\n\t\t\t\tobject._maxInstanceCount = data.maxInstanceCount;\n\t\t\t\tobject._maxVertexCount = data.maxVertexCount;\n\t\t\t\tobject._maxIndexCount = data.maxIndexCount;\n\n\t\t\t\tobject._geometryInitialized = data.geometryInitialized;\n\t\t\t\tobject._geometryCount = data.geometryCount;\n\n\t\t\t\tobject._matricesTexture = getTexture( data.matricesTexture.uuid );\n\t\t\t\tif ( data.colorsTexture !== undefined ) object._colorsTexture = getTexture( data.colorsTexture.uuid );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Bone':\n\n\t\t\t\tobject = new Bone();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.up !== undefined ) object.up.fromArray( data.up );\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.intensity !== undefined ) object.shadow.intensity = data.shadow.intensity;\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.animations !== undefined ) {\n\n\t\t\tconst objectAnimations = data.animations;\n\n\t\t\tfor ( let i = 0; i < objectAnimations.length; i ++ ) {\n\n\t\t\t\tconst uuid = objectAnimations[ i ];\n\n\t\t\t\tobject.animations.push( animations[ uuid ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\n\n\t\t\tconst levels = data.levels;\n\n\t\t\tfor ( let l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tconst level = levels[ l ];\n\t\t\t\tconst child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance, level.hysteresis );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tbindSkeletons( object, skeletons ) {\n\n\t\tif ( Object.keys( skeletons ).length === 0 ) return;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {\n\n\t\t\t\tconst skeleton = skeletons[ child.skeleton ];\n\n\t\t\t\tif ( skeleton === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.bind( skeleton, child.bindMatrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tbindLightTargets( object ) {\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isDirectionalLight || child.isSpotLight ) {\n\n\t\t\t\tconst uuid = child.target;\n\n\t\t\t\tconst target = object.getObjectByProperty( 'uuid', uuid );\n\n\t\t\t\tif ( target !== undefined ) {\n\n\t\t\t\t\tchild.target = target;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.target = new Object3D();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\nconst TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping\n};\n\nconst TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nconst TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\n\nclass ImageBitmapLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.isImageBitmapLoader = true;\n\n\t\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t\t}\n\n\t\tif ( typeof fetch === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t\t}\n\n\t\tthis.options = { premultiplyAlpha: 'none' };\n\n\t}\n\n\tsetOptions( options ) {\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\t// If cached is a promise, wait for it to resolve\n\t\t\tif ( cached.then ) {\n\n\t\t\t\tcached.then( imageBitmap => {\n\n\t\t\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t} ).catch( e => {\n\n\t\t\t\t\tif ( onError ) onError( e );\n\n\t\t\t\t} );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// If cached is not a promise (i.e., it's already an imageBitmap)\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst fetchOptions = {};\n\t\tfetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';\n\t\tfetchOptions.headers = this.requestHeader;\n\n\t\tconst promise = fetch( url, fetchOptions ).then( function ( res ) {\n\n\t\t\treturn res.blob();\n\n\t\t} ).then( function ( blob ) {\n\n\t\t\treturn createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );\n\n\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\tCache.add( url, imageBitmap );\n\n\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t\treturn imageBitmap;\n\n\t\t} ).catch( function ( e ) {\n\n\t\t\tif ( onError ) onError( e );\n\n\t\t\tCache.remove( url );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} );\n\n\t\tCache.add( url, promise );\n\t\tscope.manager.itemStart( url );\n\n\t}\n\n}\n\nlet _context;\n\nclass AudioContext {\n\n\tstatic getContext() {\n\n\t\tif ( _context === undefined ) {\n\n\t\t\t_context = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn _context;\n\n\t}\n\n\tstatic setContext( value ) {\n\n\t\t_context = value;\n\n\t}\n\n}\n\nclass AudioLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\tconst bufferCopy = buffer.slice( 0 );\n\n\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t} ).catch( handleError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\thandleError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\tfunction handleError( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}\n\n\t}\n\n}\n\nconst _eyeRight = /*@__PURE__*/ new Matrix4();\nconst _eyeLeft = /*@__PURE__*/ new Matrix4();\nconst _projectionMatrix = /*@__PURE__*/ new Matrix4();\n\nclass StereoCamera {\n\n\tconstructor() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t\tthis._cache = {\n\t\t\tfocus: null,\n\t\t\tfov: null,\n\t\t\taspect: null,\n\t\t\tnear: null,\n\t\t\tfar: null,\n\t\t\tzoom: null,\n\t\t\teyeSep: null\n\t\t};\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst cache = this._cache;\n\n\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\n\t\t\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\n\t\t\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tcache.focus = camera.focus;\n\t\t\tcache.fov = camera.fov;\n\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\tcache.near = camera.near;\n\t\t\tcache.far = camera.far;\n\t\t\tcache.zoom = camera.zoom;\n\t\t\tcache.eyeSep = this.eyeSep;\n\n\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t_projectionMatrix.copy( camera.projectionMatrix );\n\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\tconst ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\n\t\t\tlet xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\n\t\t\t_eyeRight.elements[ 12 ] = eyeSepHalf;\n\n\t\t\t// for left eye\n\n\t\t\txmin = - ymax * cache.aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraL.projectionMatrix.copy( _projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = - ymax * cache.aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraR.projectionMatrix.copy( _projectionMatrix );\n\n\t\t}\n\n\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\n\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\n\n\t}\n\n}\n\nclass ArrayCamera extends PerspectiveCamera {\n\n\tconstructor( array = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isArrayCamera = true;\n\n\t\tthis.cameras = array;\n\n\t}\n\n}\n\nclass Clock {\n\n\tconstructor( autoStart = true ) {\n\n\t\tthis.autoStart = autoStart;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tstart() {\n\n\t\tthis.startTime = now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.elapsedTime = 0;\n\t\tthis.running = true;\n\n\t}\n\n\tstop() {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\t\tthis.autoStart = false;\n\n\t}\n\n\tgetElapsedTime() {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t}\n\n\tgetDelta() {\n\n\t\tlet diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tconst newTime = now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n}\n\nfunction now() {\n\n\treturn performance.now();\n\n}\n\nconst _position$1 = /*@__PURE__*/ new Vector3();\nconst _quaternion$1 = /*@__PURE__*/ new Quaternion();\nconst _scale$1 = /*@__PURE__*/ new Vector3();\nconst _orientation$1 = /*@__PURE__*/ new Vector3();\n\nclass AudioListener extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = AudioContext.getContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t\tthis.timeDelta = 0;\n\n\t\t// private\n\n\t\tthis._clock = new Clock();\n\n\t}\n\n\tgetInput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tremoveFilter() {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.filter;\n\n\t}\n\n\tsetFilter( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t\treturn this;\n\n\t}\n\n\tgetMasterVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetMasterVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tconst listener = this.context.listener;\n\t\tconst up = this.up;\n\n\t\tthis.timeDelta = this._clock.getDelta();\n\n\t\tthis.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );\n\n\t\t_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );\n\n\t\tif ( listener.positionX ) {\n\n\t\t\t// code path for Chrome (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\tlistener.positionX.linearRampToValueAtTime( _position$1.x, endTime );\n\t\t\tlistener.positionY.linearRampToValueAtTime( _position$1.y, endTime );\n\t\t\tlistener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );\n\t\t\tlistener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );\n\t\t\tlistener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );\n\t\t\tlistener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );\n\t\t\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\n\t\t\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\n\t\t\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\n\n\t\t} else {\n\n\t\t\tlistener.setPosition( _position$1.x, _position$1.y, _position$1.z );\n\t\t\tlistener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass Audio extends Object3D {\n\n\tconstructor( listener ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.listener = listener;\n\t\tthis.context = listener.context;\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.buffer = null;\n\t\tthis.detune = 0;\n\t\tthis.loop = false;\n\t\tthis.loopStart = 0;\n\t\tthis.loopEnd = 0;\n\t\tthis.offset = 0;\n\t\tthis.duration = undefined;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.source = null;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis._startedAt = 0;\n\t\tthis._progress = 0;\n\t\tthis._connected = false;\n\n\t\tthis.filters = [];\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tsetNodeSource( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaElementSource( mediaElement ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaNode';\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaStreamSource( mediaStream ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaStreamNode';\n\t\tthis.source = this.context.createMediaStreamSource( mediaStream );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetBuffer( audioBuffer ) {\n\n\t\tthis.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t}\n\n\tplay( delay = 0 ) {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._startedAt = this.context.currentTime + delay;\n\n\t\tconst source = this.context.createBufferSource();\n\t\tsource.buffer = this.buffer;\n\t\tsource.loop = this.loop;\n\t\tsource.loopStart = this.loopStart;\n\t\tsource.loopEnd = this.loopEnd;\n\t\tsource.onended = this.onEnded.bind( this );\n\t\tsource.start( this._startedAt, this._progress + this.offset, this.duration );\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\tthis.setDetune( this.detune );\n\t\tthis.setPlaybackRate( this.playbackRate );\n\n\t\treturn this.connect();\n\n\t}\n\n\tpause() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\t// update current progress\n\n\t\t\tthis._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;\n\n\t\t\tif ( this.loop === true ) {\n\n\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\n\t\t\t\tthis._progress = this._progress % ( this.duration || this.buffer.duration );\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t\tthis.isPlaying = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tstop( delay = 0 ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._progress = 0;\n\n\t\tif ( this.source !== null ) {\n\n\t\t\tthis.source.stop( this.context.currentTime + delay );\n\t\t\tthis.source.onended = null;\n\n\t\t}\n\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t}\n\n\tconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = true;\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect() {\n\n\t\tif ( this._connected === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = false;\n\n\t\treturn this;\n\n\t}\n\n\tgetFilters() {\n\n\t\treturn this.filters;\n\n\t}\n\n\tsetFilters( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this._connected === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value.slice();\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetDetune( value ) {\n\n\t\tthis.detune = value;\n\n\t\tif ( this.isPlaying === true && this.source.detune !== undefined ) {\n\n\t\t\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetDetune() {\n\n\t\treturn this.detune;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t}\n\n\tsetFilter( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t}\n\n\tsetPlaybackRate( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetPlaybackRate() {\n\n\t\treturn this.playbackRate;\n\n\t}\n\n\tonEnded() {\n\n\t\tthis.isPlaying = false;\n\t\tthis._progress = 0;\n\n\t}\n\n\tgetLoop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.loop;\n\n\t}\n\n\tsetLoop( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.loop = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.loop = this.loop;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopStart( value ) {\n\n\t\tthis.loopStart = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopEnd( value ) {\n\n\t\tthis.loopEnd = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.sourceType !== 'buffer' ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio source type cannot be copied.' );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.autoplay = source.autoplay;\n\n\t\tthis.buffer = source.buffer;\n\t\tthis.detune = source.detune;\n\t\tthis.loop = source.loop;\n\t\tthis.loopStart = source.loopStart;\n\t\tthis.loopEnd = source.loopEnd;\n\t\tthis.offset = source.offset;\n\t\tthis.duration = source.duration;\n\t\tthis.playbackRate = source.playbackRate;\n\t\tthis.hasPlaybackControl = source.hasPlaybackControl;\n\t\tthis.sourceType = source.sourceType;\n\n\t\tthis.filters = source.filters.slice();\n\n\t\treturn this;\n\n\t}\n\n\tclone( recursive ) {\n\n\t\treturn new this.constructor( this.listener ).copy( this, recursive );\n\n\t}\n\n}\n\nconst _position = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\nconst _scale = /*@__PURE__*/ new Vector3();\nconst _orientation = /*@__PURE__*/ new Vector3();\n\nclass PositionalAudio extends Audio {\n\n\tconstructor( listener ) {\n\n\t\tsuper( listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.panningModel = 'HRTF';\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tconnect() {\n\n\t\tsuper.connect();\n\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tdisconnect() {\n\n\t\tsuper.disconnect();\n\n\t\tthis.panner.disconnect( this.gain );\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.panner;\n\n\t}\n\n\tgetRefDistance() {\n\n\t\treturn this.panner.refDistance;\n\n\t}\n\n\tsetRefDistance( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetRolloffFactor() {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t}\n\n\tsetRolloffFactor( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetDistanceModel() {\n\n\t\treturn this.panner.distanceModel;\n\n\t}\n\n\tsetDistanceModel( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxDistance() {\n\n\t\treturn this.panner.maxDistance;\n\n\t}\n\n\tsetMaxDistance( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\n\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\tthis.panner.coneOuterGain = coneOuterGain;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.hasPlaybackControl === true && this.isPlaying === false ) return;\n\n\t\tthis.matrixWorld.decompose( _position, _quaternion, _scale );\n\n\t\t_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );\n\n\t\tconst panner = this.panner;\n\n\t\tif ( panner.positionX ) {\n\n\t\t\t// code path for Chrome and Firefox (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\n\t\t\tpanner.positionX.linearRampToValueAtTime( _position.x, endTime );\n\t\t\tpanner.positionY.linearRampToValueAtTime( _position.y, endTime );\n\t\t\tpanner.positionZ.linearRampToValueAtTime( _position.z, endTime );\n\t\t\tpanner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );\n\t\t\tpanner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );\n\t\t\tpanner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );\n\n\t\t} else {\n\n\t\t\tpanner.setPosition( _position.x, _position.y, _position.z );\n\t\t\tpanner.setOrientation( _orientation.x, _orientation.y, _orientation.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass AudioAnalyser {\n\n\tconstructor( audio, fftSize = 2048 ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\n\tgetFrequencyData() {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t}\n\n\tgetAverageFrequency() {\n\n\t\tlet value = 0;\n\t\tconst data = this.getFrequencyData();\n\n\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n}\n\nclass PropertyMixer {\n\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*/ /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*/ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*/ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];\n\nclass Composite {\n\n\tconstructor( targetGroup, path, optionalParsedPath ) {\n\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tgetValue( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t}\n\n\tsetValue( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t}\n\n\tbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t}\n\n\tunbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n\n\tconstructor( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );\n\n\t\tthis.rootNode = rootNode;\n\n\t\t// initial state of these methods that calls 'bind'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n\n\tstatic create( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tstatic sanitizeNodeName( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t}\n\n\tstatic parseTrackName( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( matches === null ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n\tstatic findNode( root, nodeName ) {\n\n\t\tif ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable() {}\n\t_setValue_unavailable() {}\n\n\t// Getters\n\n\t_getValue_direct( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.targetObject[ this.propertyName ];\n\n\t}\n\n\t_getValue_array( buffer, offset ) {\n\n\t\tconst source = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t}\n\n\t}\n\n\t_getValue_arrayElement( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t}\n\n\t_getValue_toArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t}\n\n\t// Direct\n\n\t_setValue_direct( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// EntireArray\n\n\t_setValue_array( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t}\n\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// ArrayElement\n\n\t_setValue_arrayElement( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// HasToFromArray\n\n\t_setValue_fromArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t}\n\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t_getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t}\n\n\t_setValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t}\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind() {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.warn( 'THREE.PropertyBinding: No target node found for track: ' + this.path + '.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map':\n\n\t\t\t\t\tif ( 'map' in targetObject ) {\n\n\t\t\t\t\t\ttargetObject = targetObject.map;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.map ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.map;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t}\n\n\tunbind() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n\tDirect: 0,\n\tEntireArray: 1,\n\tArrayElement: 2,\n\tHasFromToArray: 3\n};\n\nPropertyBinding.prototype.Versioning = {\n\tNone: 0,\n\tNeedsUpdate: 1,\n\tMatrixWorldNeedsUpdate: 2\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n\n\tPropertyBinding.prototype._getValue_direct,\n\tPropertyBinding.prototype._getValue_array,\n\tPropertyBinding.prototype._getValue_arrayElement,\n\tPropertyBinding.prototype._getValue_toArray,\n\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n\n\t[\n\t\t// Direct\n\t\tPropertyBinding.prototype._setValue_direct,\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// EntireArray\n\n\t\tPropertyBinding.prototype._setValue_array,\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// ArrayElement\n\t\tPropertyBinding.prototype._setValue_arrayElement,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// HasToFromArray\n\t\tPropertyBinding.prototype._setValue_fromArray,\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n\n\t]\n\n];\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n\n\tconstructor() {\n\n\t\tthis.isAnimationObjectGroup = true;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tconst indices = {};\n\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = []; // inside: string\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tadd() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\tremove() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// remove & forget\n\tuncache() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t}\n\n\tunsubscribe_( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n}\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot;\n\t\tthis.blendMode = blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\tdeltaTime = 0;\n\n\t\t\t} else {\n\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _controlInterpolantsResultBuffer = new Float32Array( 1 );\n\n\nclass AnimationMixer extends EventDispatcher {\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\tthis.time = 0;\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, _controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t// get an existing action\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// advance the time and update apply the animation\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t// return this mixer's root target object\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t// free all resources specific to a particular clip\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remove a targeted clip from the cache\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nclass Uniform {\n\n\tconstructor( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n\t}\n\n}\n\nlet _id = 0;\n\nclass UniformsGroup extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isUniformsGroup = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\tthis.name = '';\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.uniforms = [];\n\n\t}\n\n\tadd( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\tremove( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) this.uniforms.splice( index, 1 );\n\n\t\treturn this;\n\n\t}\n\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.usage = source.usage;\n\n\t\tconst uniformsSource = source.uniforms;\n\n\t\tthis.uniforms.length = 0;\n\n\t\tfor ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {\n\n\t\t\tconst uniforms = Array.isArray( uniformsSource[ i ] ) ? uniformsSource[ i ] : [ uniformsSource[ i ] ];\n\n\t\t\tfor ( let j = 0; j < uniforms.length; j ++ ) {\n\n\t\t\t\tthis.uniforms.push( uniforms[ j ].clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n\n\tconstructor( array, stride, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, stride );\n\n\t\tthis.isInstancedInterleavedBuffer = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tconst ib = super.clone( data );\n\n\t\tib.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn ib;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tconst json = super.toJSON( data );\n\n\t\tjson.isInstancedInterleavedBuffer = true;\n\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn json;\n\n\t}\n\n}\n\nclass GLBufferAttribute {\n\n\tconstructor( buffer, type, itemSize, elementSize, count ) {\n\n\t\tthis.isGLBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.buffer = buffer;\n\t\tthis.type = type;\n\t\tthis.itemSize = itemSize;\n\t\tthis.elementSize = elementSize;\n\t\tthis.count = count;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetBuffer( buffer ) {\n\n\t\tthis.buffer = buffer;\n\n\t\treturn this;\n\n\t}\n\n\tsetType( type, elementSize ) {\n\n\t\tthis.type = type;\n\t\tthis.elementSize = elementSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetItemSize( itemSize ) {\n\n\t\tthis.itemSize = itemSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetCount( count ) {\n\n\t\tthis.count = count;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\n\nclass Raycaster {\n\n\tconstructor( origin, direction, near = 0, far = Infinity ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.camera = null;\n\t\tthis.layers = new Layers();\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: { threshold: 1 },\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t}\n\n\tsetFromCamera( coords, camera ) {\n\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( camera.isOrthographicCamera ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\n\n\t\t}\n\n\t}\n\n\tsetFromXRController( controller ) {\n\n\t\t_matrix.identity().extractRotation( controller.matrixWorld );\n\n\t\tthis.ray.origin.setFromMatrixPosition( controller.matrixWorld );\n\t\tthis.ray.direction.set( 0, 0, - 1 ).applyMatrix4( _matrix );\n\n\t\treturn this;\n\n\t}\n\n\tintersectObject( object, recursive = true, intersects = [] ) {\n\n\t\tintersect( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n\tintersectObjects( objects, recursive = true, intersects = [] ) {\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersect( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersect( object, raycaster, intersects, recursive ) {\n\n\tlet propagate = true;\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tconst result = object.raycast( raycaster, intersects );\n\n\t\tif ( result === false ) propagate = false;\n\n\t}\n\n\tif ( propagate === true && recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersect( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.\n * theta (the azimuthal angle) is measured from the positive z-axis.\n */\nclass Spherical {\n\n\tconstructor( radius = 1, phi = 0, theta = 0 ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi; // polar angle\n\t\tthis.theta = theta; // azimuthal angle\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.phi = other.phi;\n\t\tthis.theta = other.theta;\n\n\t\treturn this;\n\n\t}\n\n\t// restrict phi to be between EPS and PI-EPS\n\tmakeSafe() {\n\n\t\tconst EPS = 0.000001;\n\t\tthis.phi = clamp( this.phi, EPS, Math.PI - EPS );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\tthis.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n */\n\nclass Cylindrical {\n\n\tconstructor( radius = 1, theta = 0, y = 0 ) {\n\n\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\t\tthis.y = y; // height above the x-z plane\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, theta, y ) {\n\n\t\tthis.radius = radius;\n\t\tthis.theta = theta;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.theta = other.theta;\n\t\tthis.y = other.y;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + z * z );\n\t\tthis.theta = Math.atan2( x, z );\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix2 {\n\n\tconstructor( n11, n12, n21, n22 ) {\n\n\t\tMatrix2.prototype.isMatrix2 = true;\n\n\t\tthis.elements = [\n\t\t\t1, 0,\n\t\t\t0, 1,\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n21, n22 );\n\n\t\t}\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\t\t\t1, 0,\n\t\t\t0, 1,\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( n11, n12, n21, n22 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 2 ] = n12;\n\t\tte[ 1 ] = n21; te[ 3 ] = n22;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _vector$4 = /*@__PURE__*/ new Vector2();\n\nclass Box2 {\n\n\tconstructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox2 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x >= this.min.x && point.x <= this.max.x &&\n\t\t\tpoint.y >= this.min.y && point.y <= this.max.y;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 4 splitting planes to rule out intersections\n\n\t\treturn box.max.x >= this.min.x && box.min.x <= this.max.x &&\n\t\t\tbox.max.y >= this.min.y && box.min.y <= this.max.y;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$4 ).distanceTo( point );\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _startP = /*@__PURE__*/ new Vector3();\nconst _startEnd = /*@__PURE__*/ new Vector3();\n\nclass Line3 {\n\n\tconstructor( start = new Vector3(), end = new Vector3() ) {\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\n\t}\n\n\tset( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t}\n\n\tdelta( target ) {\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t}\n\n\tdistanceSq() {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t}\n\n\tdistance() {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tclosestPointToPointParameter( point, clampToLine ) {\n\n\t\t_startP.subVectors( point, this.start );\n\t\t_startEnd.subVectors( this.end, this.start );\n\n\t\tconst startEnd2 = _startEnd.dot( _startEnd );\n\t\tconst startEnd_startP = _startEnd.dot( _startP );\n\n\t\tlet t = startEnd_startP / startEnd2;\n\n\t\tif ( clampToLine ) {\n\n\t\t\tt = clamp( t, 0, 1 );\n\n\t\t}\n\n\t\treturn t;\n\n\t}\n\n\tclosestPointToPoint( point, clampToLine, target ) {\n\n\t\tconst t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t}\n\n\tequals( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$3 = /*@__PURE__*/ new Vector3();\n\nclass SpotLightHelper extends Object3D {\n\n\tconstructor( light, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'SpotLightHelper';\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions = [\n\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t];\n\n\t\tfor ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tconst p1 = ( i / l ) * Math.PI * 2;\n\t\t\tconst p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t// update the local matrix based on the parent and light target transforms\n\t\tif ( this.parent ) {\n\n\t\t\tthis.parent.updateWorldMatrix( true );\n\n\t\t\tthis.matrix\n\t\t\t\t.copy( this.parent.matrixWorld )\n\t\t\t\t.invert()\n\t\t\t\t.multiply( this.light.matrixWorld );\n\n\t\t} else {\n\n\t\t\tthis.matrix.copy( this.light.matrixWorld );\n\n\t\t}\n\n\t\tthis.matrixWorld.copy( this.light.matrixWorld );\n\n\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tconst coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( _vector$3 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t}\n\n}\n\nconst _vector$2 = /*@__PURE__*/ new Vector3();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\nconst _matrixWorldInv = /*@__PURE__*/ new Matrix4();\n\n\nclass SkeletonHelper extends LineSegments {\n\n\tconstructor( object ) {\n\n\t\tconst bones = getBoneList( object );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst color1 = new Color( 0, 0, 1 );\n\t\tconst color2 = new Color( 0, 1, 0 );\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkeletonHelper = true;\n\n\t\tthis.type = 'SkeletonHelper';\n\n\t\tthis.root = object;\n\t\tthis.bones = bones;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst bones = this.bones;\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t_matrixWorldInv.copy( this.root.matrixWorld ).invert();\n\n\t\tfor ( let i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction getBoneList( object ) {\n\n\tconst boneList = [];\n\n\tif ( object.isBone === true ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( let i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n}\n\nclass PointLightHelper extends Mesh {\n\n\tconstructor( light, sphereSize, color ) {\n\n\t\tconst geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tconst material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.light = light;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'PointLightHelper';\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\n\t\t/*\n\t// TODO: delete this comment?\n\tconst distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tconst d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\t/*\n\t\tconst d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t}\n\n}\n\nconst _vector$1 = /*@__PURE__*/ new Vector3();\nconst _color1 = /*@__PURE__*/ new Color();\nconst _color2 = /*@__PURE__*/ new Color();\n\nclass HemisphereLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'HemisphereLightHelper';\n\n\t\tconst geometry = new OctahedronGeometry( size );\n\t\tgeometry.rotateY( Math.PI * 0.5 );\n\n\t\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\t\tif ( this.color === undefined ) this.material.vertexColors = true;\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tconst colors = new Float32Array( position.count * 3 );\n\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tthis.add( new Mesh( geometry, this.material ) );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.children[ 0 ];\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tconst colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\t_color1.copy( this.light.color );\n\t\t\t_color2.copy( this.light.groundColor );\n\n\t\t\tfor ( let i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\tconst color = ( i < ( l / 2 ) ) ? _color1 : _color2;\n\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tcolors.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tmesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t}\n\n}\n\nclass GridHelper extends LineSegments {\n\n\tconstructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst center = divisions / 2;\n\t\tconst step = size / divisions;\n\t\tconst halfSize = size / 2;\n\n\t\tconst vertices = [], colors = [];\n\n\t\tfor ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\t\tconst color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'GridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PolarGridHelper extends LineSegments {\n\n\tconstructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\t// create the sectors\n\n\t\tif ( sectors > 1 ) {\n\n\t\t\tfor ( let i = 0; i < sectors; i ++ ) {\n\n\t\t\t\tconst v = ( i / sectors ) * ( Math.PI * 2 );\n\n\t\t\t\tconst x = Math.sin( v ) * radius;\n\t\t\t\tconst z = Math.cos( v ) * radius;\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( x, 0, z );\n\n\t\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create the rings\n\n\t\tfor ( let i = 0; i < rings; i ++ ) {\n\n\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\tconst r = radius - ( radius / rings * i );\n\n\t\t\tfor ( let j = 0; j < divisions; j ++ ) {\n\n\t\t\t\t// first vertex\n\n\t\t\t\tlet v = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tlet x = Math.sin( v ) * r;\n\t\t\t\tlet z = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t// second vertex\n\n\t\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\tz = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'PolarGridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\nconst _v3 = /*@__PURE__*/ new Vector3();\n\nclass DirectionalLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'DirectionalLightHelper';\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tlet geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t- size, size, 0,\n\t\t\tsize, size, 0,\n\t\t\tsize, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size, size, 0\n\t\t], 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.lightPlane = new Line( geometry, material );\n\t\tthis.add( this.lightPlane );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.targetLine = new Line( geometry, material );\n\t\tthis.add( this.targetLine );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lightPlane.geometry.dispose();\n\t\tthis.lightPlane.material.dispose();\n\t\tthis.targetLine.geometry.dispose();\n\t\tthis.targetLine.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t_v1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t_v2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t_v3.subVectors( _v2, _v1 );\n\n\t\tthis.lightPlane.lookAt( _v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( _v2 );\n\t\tthis.targetLine.scale.z = _v3.length();\n\n\t}\n\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _camera = /*@__PURE__*/ new Camera();\n\n/**\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttps://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html\n */\n\nclass CameraHelper extends LineSegments {\n\n\tconstructor( camera ) {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst pointMap = {};\n\n\t\t// near\n\n\t\taddLine( 'n1', 'n2' );\n\t\taddLine( 'n2', 'n4' );\n\t\taddLine( 'n4', 'n3' );\n\t\taddLine( 'n3', 'n1' );\n\n\t\t// far\n\n\t\taddLine( 'f1', 'f2' );\n\t\taddLine( 'f2', 'f4' );\n\t\taddLine( 'f4', 'f3' );\n\t\taddLine( 'f3', 'f1' );\n\n\t\t// sides\n\n\t\taddLine( 'n1', 'f1' );\n\t\taddLine( 'n2', 'f2' );\n\t\taddLine( 'n3', 'f3' );\n\t\taddLine( 'n4', 'f4' );\n\n\t\t// cone\n\n\t\taddLine( 'p', 'n1' );\n\t\taddLine( 'p', 'n2' );\n\t\taddLine( 'p', 'n3' );\n\t\taddLine( 'p', 'n4' );\n\n\t\t// up\n\n\t\taddLine( 'u1', 'u2' );\n\t\taddLine( 'u2', 'u3' );\n\t\taddLine( 'u3', 'u1' );\n\n\t\t// target\n\n\t\taddLine( 'c', 't' );\n\t\taddLine( 'p', 'c' );\n\n\t\t// cross\n\n\t\taddLine( 'cn1', 'cn2' );\n\t\taddLine( 'cn3', 'cn4' );\n\n\t\taddLine( 'cf1', 'cf2' );\n\t\taddLine( 'cf3', 'cf4' );\n\n\t\tfunction addLine( a, b ) {\n\n\t\t\taddPoint( a );\n\t\t\taddPoint( b );\n\n\t\t}\n\n\t\tfunction addPoint( id ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( 0, 0, 0 );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'CameraHelper';\n\n\t\tthis.camera = camera;\n\t\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t\t// colors\n\n\t\tconst colorFrustum = new Color( 0xffaa00 );\n\t\tconst colorCone = new Color( 0xff0000 );\n\t\tconst colorUp = new Color( 0x00aaff );\n\t\tconst colorTarget = new Color( 0xffffff );\n\t\tconst colorCross = new Color( 0x333333 );\n\n\t\tthis.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );\n\n\t}\n\n\tsetColors( frustum, cone, up, target, cross ) {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst colorAttribute = geometry.getAttribute( 'color' );\n\n\t\t// near\n\n\t\tcolorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2\n\t\tcolorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4\n\t\tcolorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3\n\t\tcolorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1\n\n\t\t// far\n\n\t\tcolorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2\n\t\tcolorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4\n\t\tcolorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3\n\t\tcolorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1\n\n\t\t// sides\n\n\t\tcolorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1\n\t\tcolorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2\n\t\tcolorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3\n\t\tcolorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4\n\n\t\t// cone\n\n\t\tcolorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1\n\t\tcolorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2\n\t\tcolorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3\n\t\tcolorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4\n\n\t\t// up\n\n\t\tcolorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2\n\t\tcolorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3\n\t\tcolorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1\n\n\t\t// target\n\n\t\tcolorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t\n\t\tcolorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c\n\n\t\t// cross\n\n\t\tcolorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2\n\t\tcolorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4\n\n\t\tcolorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2\n\t\tcolorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4\n\n\t\tcolorAttribute.needsUpdate = true;\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst pointMap = this.pointMap;\n\n\t\tconst w = 1, h = 1;\n\n\t\t// we need just camera projection matrix inverse\n\t\t// world matrix must be identity\n\n\t\t_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );\n\n\t\t// center / target\n\n\t\tsetPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );\n\t\tsetPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );\n\n\t\t// near\n\n\t\tsetPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );\n\t\tsetPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );\n\t\tsetPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );\n\t\tsetPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );\n\t\tsetPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );\n\t\tsetPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );\n\t\tsetPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );\n\t\tsetPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );\n\t\tsetPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );\n\t\tsetPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );\n\n\t\tsetPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );\n\t\tsetPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );\n\t\tsetPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );\n\t\tsetPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {\n\n\t_vector.set( x, y, z ).unproject( camera );\n\n\tconst points = pointMap[ point ];\n\n\tif ( points !== undefined ) {\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tposition.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n}\n\nconst _box = /*@__PURE__*/ new Box3();\n\nclass BoxHelper extends LineSegments {\n\n\tconstructor( object, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tconst positions = new Float32Array( 8 * 3 );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.object = object;\n\t\tthis.type = 'BoxHelper';\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate( object ) {\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t}\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\t_box.setFromObject( this.object );\n\n\t\t}\n\n\t\tif ( _box.isEmpty() ) return;\n\n\t\tconst min = _box.min;\n\t\tconst max = _box.max;\n\n\t\t/*\n\t\t\t5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tconst position = this.geometry.attributes.position;\n\t\tconst array = position.array;\n\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tthis.object = object;\n\t\tthis.update();\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.object = source.object;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass Box3Helper extends LineSegments {\n\n\tconstructor( box, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\t\tconst positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.box = box;\n\n\t\tthis.type = 'Box3Helper';\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst box = this.box;\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tbox.getCenter( this.position );\n\n\t\tbox.getSize( this.scale );\n\n\t\tthis.scale.multiplyScalar( 0.5 );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PlaneHelper extends Line {\n\n\tconstructor( plane, size = 1, hex = 0xffff00 ) {\n\n\t\tconst color = hex;\n\n\t\tconst positions = [ 1, - 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.type = 'PlaneHelper';\n\n\t\tthis.plane = plane;\n\n\t\tthis.size = size;\n\n\t\tconst positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\n\t\tconst geometry2 = new BufferGeometry();\n\t\tgeometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\t\tgeometry2.computeBoundingSphere();\n\n\t\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tthis.position.set( 0, 0, 0 );\n\n\t\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );\n\n\t\tthis.lookAt( this.plane.normal );\n\n\t\tthis.translateZ( - this.plane.constant );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n}\n\nconst _axis = /*@__PURE__*/ new Vector3();\nlet _lineGeometry, _coneGeometry;\n\nclass ArrowHelper extends Object3D {\n\n\t// dir is assumed to be normalized\n\n\tconstructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ArrowHelper';\n\n\t\tif ( _lineGeometry === undefined ) {\n\n\t\t\t_lineGeometry = new BufferGeometry();\n\t\t\t_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\t\t_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );\n\t\t\t_coneGeometry.translate( 0, - 0.5, 0 );\n\n\t\t}\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tsetDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\t_axis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tconst radians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( _axis, radians );\n\n\t\t}\n\n\t}\n\n\tsetLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tthis.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t}\n\n\tsetColor( color ) {\n\n\t\tthis.line.material.color.set( color );\n\t\tthis.cone.material.color.set( color );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tthis.line.copy( source.line );\n\t\tthis.cone.copy( source.cone );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.line.geometry.dispose();\n\t\tthis.line.material.dispose();\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n}\n\nclass AxesHelper extends LineSegments {\n\n\tconstructor( size = 1 ) {\n\n\t\tconst vertices = [\n\t\t\t0, 0, 0,\tsize, 0, 0,\n\t\t\t0, 0, 0,\t0, size, 0,\n\t\t\t0, 0, 0,\t0, 0, size\n\t\t];\n\n\t\tconst colors = [\n\t\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t\t0, 0, 1,\t0, 0.6, 1\n\t\t];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'AxesHelper';\n\n\t}\n\n\tsetColors( xAxisColor, yAxisColor, zAxisColor ) {\n\n\t\tconst color = new Color();\n\t\tconst array = this.geometry.attributes.color.array;\n\n\t\tcolor.set( xAxisColor );\n\t\tcolor.toArray( array, 0 );\n\t\tcolor.toArray( array, 3 );\n\n\t\tcolor.set( yAxisColor );\n\t\tcolor.toArray( array, 6 );\n\t\tcolor.toArray( array, 9 );\n\n\t\tcolor.set( zAxisColor );\n\t\tcolor.toArray( array, 12 );\n\t\tcolor.toArray( array, 15 );\n\n\t\tthis.geometry.attributes.color.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass ShapePath {\n\n\tconstructor() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\tthis.color = new Color();\n\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t}\n\n\ttoShapes( isCCW ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tconst shapes = [];\n\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\n\n\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tconst polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tlet inside = false;\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tconst isClockWise = ShapeUtils.isClockWise;\n\n\t\tconst subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tlet solid, tmpPath, tmpShape;\n\t\tconst shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tconst betterShapeHoles = [];\n\t\tconst newShapes = [];\n\t\tlet newShapeHoles = [];\n\t\tlet mainIdx = 0;\n\t\tlet tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tlet ambiguous = false;\n\t\t\tlet toChange = 0;\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tconst ho = sho[ hIdx ];\n\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange ++;\n\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( toChange > 0 && ambiguous === false ) {\n\n\t\t\t\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet tmpHoles;\n\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nclass Controls extends EventDispatcher {\n\n\tconstructor( object, domElement = null ) {\n\n\t\tsuper();\n\n\t\tthis.object = object;\n\t\tthis.domElement = domElement;\n\n\t\tthis.enabled = true;\n\n\t\tthis.state = - 1;\n\n\t\tthis.keys = {};\n\t\tthis.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };\n\t\tthis.touches = { ONE: null, TWO: null };\n\n\t}\n\n\tconnect() {}\n\n\tdisconnect() {}\n\n\tdispose() {}\n\n\tupdate( /* delta */ ) {}\n\n}\n\nfunction contain( texture, aspect ) {\n\n\tconst imageAspect = ( texture.image && texture.image.width ) ? texture.image.width / texture.image.height : 1;\n\n\tif ( imageAspect > aspect ) {\n\n\t\ttexture.repeat.x = 1;\n\t\ttexture.repeat.y = imageAspect / aspect;\n\n\t\ttexture.offset.x = 0;\n\t\ttexture.offset.y = ( 1 - texture.repeat.y ) / 2;\n\n\t} else {\n\n\t\ttexture.repeat.x = aspect / imageAspect;\n\t\ttexture.repeat.y = 1;\n\n\t\ttexture.offset.x = ( 1 - texture.repeat.x ) / 2;\n\t\ttexture.offset.y = 0;\n\n\t}\n\n\treturn texture;\n\n}\n\nfunction cover( texture, aspect ) {\n\n\tconst imageAspect = ( texture.image && texture.image.width ) ? texture.image.width / texture.image.height : 1;\n\n\tif ( imageAspect > aspect ) {\n\n\t\ttexture.repeat.x = aspect / imageAspect;\n\t\ttexture.repeat.y = 1;\n\n\t\ttexture.offset.x = ( 1 - texture.repeat.x ) / 2;\n\t\ttexture.offset.y = 0;\n\n\t} else {\n\n\t\ttexture.repeat.x = 1;\n\t\ttexture.repeat.y = imageAspect / aspect;\n\n\t\ttexture.offset.x = 0;\n\t\ttexture.offset.y = ( 1 - texture.repeat.y ) / 2;\n\n\t}\n\n\treturn texture;\n\n}\n\nfunction fill( texture ) {\n\n\ttexture.repeat.x = 1;\n\ttexture.repeat.y = 1;\n\n\ttexture.offset.x = 0;\n\ttexture.offset.y = 0;\n\n\treturn texture;\n\n}\n\n\n\n/**\n * Given the width, height, format, and type of a texture. Determines how many\n * bytes must be used to represent the texture.\n */\nfunction getByteLength( width, height, format, type ) {\n\n\tconst typeByteLength = getTextureTypeByteLength( type );\n\n\tswitch ( format ) {\n\n\t\t// https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml\n\t\tcase AlphaFormat:\n\t\t\treturn width * height;\n\t\tcase LuminanceFormat:\n\t\t\treturn width * height;\n\t\tcase LuminanceAlphaFormat:\n\t\t\treturn width * height * 2;\n\t\tcase RedFormat:\n\t\t\treturn ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RedIntegerFormat:\n\t\t\treturn ( ( width * height ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGFormat:\n\t\t\treturn ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGIntegerFormat:\n\t\t\treturn ( ( width * height * 2 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGBFormat:\n\t\t\treturn ( ( width * height * 3 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGBAFormat:\n\t\t\treturn ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\t\tcase RGBAIntegerFormat:\n\t\t\treturn ( ( width * height * 4 ) / typeByteLength.components ) * typeByteLength.byteLength;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/\n\t\tcase RGB_S3TC_DXT1_Format:\n\t\tcase RGBA_S3TC_DXT1_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;\n\t\tcase RGBA_S3TC_DXT3_Format:\n\t\tcase RGBA_S3TC_DXT5_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/\n\t\tcase RGB_PVRTC_2BPPV1_Format:\n\t\tcase RGBA_PVRTC_2BPPV1_Format:\n\t\t\treturn ( Math.max( width, 16 ) * Math.max( height, 8 ) ) / 4;\n\t\tcase RGB_PVRTC_4BPPV1_Format:\n\t\tcase RGBA_PVRTC_4BPPV1_Format:\n\t\t\treturn ( Math.max( width, 8 ) * Math.max( height, 8 ) ) / 2;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/\n\t\tcase RGB_ETC1_Format:\n\t\tcase RGB_ETC2_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 8;\n\t\tcase RGBA_ETC2_EAC_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/\n\t\tcase RGBA_ASTC_4x4_Format:\n\t\t\treturn Math.floor( ( width + 3 ) / 4 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\t\tcase RGBA_ASTC_5x4_Format:\n\t\t\treturn Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 3 ) / 4 ) * 16;\n\t\tcase RGBA_ASTC_5x5_Format:\n\t\t\treturn Math.floor( ( width + 4 ) / 5 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_6x5_Format:\n\t\t\treturn Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_6x6_Format:\n\t\t\treturn Math.floor( ( width + 5 ) / 6 ) * Math.floor( ( height + 5 ) / 6 ) * 16;\n\t\tcase RGBA_ASTC_8x5_Format:\n\t\t\treturn Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_8x6_Format:\n\t\t\treturn Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 5 ) / 6 ) * 16;\n\t\tcase RGBA_ASTC_8x8_Format:\n\t\t\treturn Math.floor( ( width + 7 ) / 8 ) * Math.floor( ( height + 7 ) / 8 ) * 16;\n\t\tcase RGBA_ASTC_10x5_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 4 ) / 5 ) * 16;\n\t\tcase RGBA_ASTC_10x6_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 5 ) / 6 ) * 16;\n\t\tcase RGBA_ASTC_10x8_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 7 ) / 8 ) * 16;\n\t\tcase RGBA_ASTC_10x10_Format:\n\t\t\treturn Math.floor( ( width + 9 ) / 10 ) * Math.floor( ( height + 9 ) / 10 ) * 16;\n\t\tcase RGBA_ASTC_12x10_Format:\n\t\t\treturn Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 9 ) / 10 ) * 16;\n\t\tcase RGBA_ASTC_12x12_Format:\n\t\t\treturn Math.floor( ( width + 11 ) / 12 ) * Math.floor( ( height + 11 ) / 12 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/\n\t\tcase RGBA_BPTC_Format:\n\t\tcase RGB_BPTC_SIGNED_Format:\n\t\tcase RGB_BPTC_UNSIGNED_Format:\n\t\t\treturn Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;\n\n\t\t// https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/\n\t\tcase RED_RGTC1_Format:\n\t\tcase SIGNED_RED_RGTC1_Format:\n\t\t\treturn Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 8;\n\t\tcase RED_GREEN_RGTC2_Format:\n\t\tcase SIGNED_RED_GREEN_RGTC2_Format:\n\t\t\treturn Math.ceil( width / 4 ) * Math.ceil( height / 4 ) * 16;\n\n\t}\n\n\tthrow new Error(\n\t\t`Unable to determine texture byte length for ${format} format.`,\n\t);\n\n}\n\nfunction getTextureTypeByteLength( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase UnsignedByteType:\n\t\tcase ByteType:\n\t\t\treturn { byteLength: 1, components: 1 };\n\t\tcase UnsignedShortType:\n\t\tcase ShortType:\n\t\tcase HalfFloatType:\n\t\t\treturn { byteLength: 2, components: 1 };\n\t\tcase UnsignedShort4444Type:\n\t\tcase UnsignedShort5551Type:\n\t\t\treturn { byteLength: 2, components: 4 };\n\t\tcase UnsignedIntType:\n\t\tcase IntType:\n\t\tcase FloatType:\n\t\t\treturn { byteLength: 4, components: 1 };\n\t\tcase UnsignedInt5999Type:\n\t\t\treturn { byteLength: 4, components: 3 };\n\n\t}\n\n\tthrow new Error( `Unknown texture type ${type}.` );\n\n}\n\nconst TextureUtils = {\n\tcontain,\n\tcover,\n\tfill,\n\tgetByteLength\n};\n\nclass WebGLMultipleRenderTargets extends WebGLRenderTarget { // @deprecated, r162\n\n\tconstructor( width = 1, height = 1, count = 1, options = {} ) {\n\n\t\tconsole.warn( 'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the \"count\" parameter to enable MRT.' );\n\n\t\tsuper( width, height, { ...options, count } );\n\n\t\tthis.isWebGLMultipleRenderTargets = true;\n\n\t}\n\n\tget texture() {\n\n\t\treturn this.textures;\n\n\t}\n\n}\n\nif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {\n\t\trevision: REVISION,\n\t} } ) );\n\n}\n\nif ( typeof window !== 'undefined' ) {\n\n\tif ( window.__THREE__ ) {\n\n\t\tconsole.warn( 'WARNING: Multiple instances of Three.js being imported.' );\n\n\t} else {\n\n\t\twindow.__THREE__ = REVISION;\n\n\t}\n\n}\n\nexport { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AgXToneMapping, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BackSide, BasicDepthPacking, BasicShadowMap, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, ConstantAlphaFactor, ConstantColorFactor, Controls, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DetachedBindMode, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheGeometry, Layers, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, LinearTransfer, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils, Matrix2, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeutralToneMapping, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronGeometry, OneFactor, OneMinusConstantAlphaFactor, OneMinusConstantColorFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, Path, PerspectiveCamera, Plane, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RAD2DEG, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDepthPacking, RGBFormat, RGBIntegerFormat, RGB_BPTC_SIGNED_Format, RGB_BPTC_UNSIGNED_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGDepthPacking, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RenderTarget, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, SRGBTransfer, Scene, ShaderMaterial, ShadowMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronGeometry, Texture, TextureLoader, TextureUtils, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedInt5999Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WebGPUCoordinateSystem, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, arrayNeedsUint32, cloneUniforms, createCanvasElement, createElementNS, getByteLength, getUnlitUniformColorSpace, mergeUniforms, probeAsync, toNormalizedProjectionMatrix, toReversedProjectionMatrix, warnOnce };\n","import { Vector2 } from \"three\";\nexport class PhysicsBody {\n    constructor(engine, v, collision, m, g) {\n        engine.bodies.push(this);\n        this.view = v;\n        this.collision = collision;\n        this.mass = m;\n        this.force = new Vector2();\n        this.speed = new Vector2();\n        this.gravity = g !== null && g !== void 0 ? g : 9.8;\n        this.onGround = false;\n        this.registerCollisionBody();\n    }\n    registerCollisionBody() {\n        this.collision.onCollision((o, s) => {\n            if (o.trigger)\n                return;\n            const pcTopBottom = ((this.collision.maxX() > o.maxX() ? o.maxX() : this.collision.maxX()) - (this.collision.minX() < o.minX() ? o.minX() : this.collision.minX())) / (this.collision.maxX() - this.collision.minX());\n            const pcLeftRight = ((this.collision.maxY() > o.maxY() ? o.maxY() : this.collision.maxY()) - (this.collision.minY() < o.minY() ? o.minY() : this.collision.minY())) / (this.collision.maxY() - this.collision.minY());\n            if (s.includes(\"top\")) {\n                this.force.setY(Math.min(this.force.y, 0));\n                this.speed.setY(Math.min(this.speed.y, 0));\n                this.onGround = true;\n                if (this.collision.maxY() > o.minY() && pcTopBottom > 0.8) {\n                    this.view.y -= pcLeftRight * this.collision.view.height;\n                }\n            }\n            if (s.includes(\"bottom\")) {\n                this.force.setY(Math.max(this.force.y, 0));\n                this.speed.setY(Math.max(this.speed.y, 0));\n                if (this.collision.minY() < o.maxY() && pcTopBottom > 0.8) {\n                    this.view.y += pcLeftRight * this.collision.view.height;\n                }\n            }\n            if (s.includes(\"right\")) {\n                if (this.collision.minX() < o.maxX() && pcLeftRight > 0.2) {\n                    this.view.x += pcTopBottom * this.collision.view.width;\n                }\n            }\n            if (s.includes(\"left\")) {\n                this.force.setX(Math.min(this.force.x, 0));\n                this.speed.setX(Math.min(this.speed.x, 0));\n                if (this.collision.maxX() > o.minX() && pcLeftRight > 0.3) {\n                    this.view.x -= pcTopBottom * this.collision.view.width;\n                }\n            }\n        });\n    }\n    update(deltaTime) {\n        this.onGround = false;\n        this.speed.add(this.force.multiplyScalar(deltaTime / this.mass));\n        this.view.x += Math.max(-7, Math.min(7, this.speed.x * deltaTime));\n        this.view.y += Math.max(-7, Math.min(7, this.speed.y * deltaTime));\n        this.force.set(0, 0);\n        // Gravity\n        this.force.y += this.gravity * this.mass;\n        // Air\n        this.force.y -= 0.2 * this.speed.y * this.speed.y * (this.speed.y < 0 ? -1 : 1);\n    }\n}\nexport class PhysicsEngine {\n    constructor() {\n        this.bodies = [];\n        this.colliders = [];\n    }\n    update(deltaTime) {\n        this.bodies.forEach((body) => {\n            body.update(deltaTime);\n        });\n        this.colliders.forEach((a, i) => {\n            for (let t = i + 1; t < this.colliders.length; t++) {\n                const b = this.colliders[t];\n                const sidesA = a.isColliding(b);\n                const sidesB = b.isColliding(a);\n                if (sidesA.length > 0)\n                    a.collisionCallback(b, sidesA);\n                if (sidesB.length > 0)\n                    b.collisionCallback(a, sidesB);\n            }\n        });\n    }\n}\n","export default __webpack_public_path__ + \"aa7174b873f558a67782fd6213779f17.mp3\";","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { AnimationController } from \"@components/animations/AnimationController\";\nimport { controller } from \"@components/controller/Controller\";\nimport { Rectangle } from \"@components/debug/Rectangle\";\nimport { CollisionBody } from \"@components/physics/collisionbody\";\nimport { PhysicsBody } from \"@components/physics/physics\";\nimport { AnimatedSprite, Container, Spritesheet, Texture } from \"pixi.js\";\nimport { atlasData } from \"../../../assets/atlas\";\nimport jump from '../../../assets/audio/jump_01.mp3';\nexport class Player {\n    constructor(c, animations, engine) {\n        this.view = new Container();\n        this.playerView = new Container();\n        this.swordView = new Container();\n        this.view.addChild(this.playerView);\n        this.view.addChild(this.swordView);\n        this.controller = c;\n        // Setup Player View\n        this.playerAnimations = new AnimationController(animations);\n        this.playerAnimations.setAnimation(\"walk\");\n        this.playerView.addChild(this.playerAnimations.view);\n        this.collisionBody = new CollisionBody(engine, 0, 0, this.playerView.width / 4, this.playerView.height / 2, 'player');\n        this.playerView.addChild(this.collisionBody.view);\n        this.physicsBody = new PhysicsBody(engine, this.view, this.collisionBody, 7, 0.2);\n        this.collisionBody.view.x = this.playerView.width / 2 - this.collisionBody.view.width / 2;\n        this.collisionBody.view.y = this.playerView.height - this.collisionBody.view.height;\n        this.playerView.pivot.set(this.playerView.width / 2, this.playerView.height / 2);\n        this.playerView.addChild(new Rectangle(0, 0, this.playerView.width, this.playerView.height, \"#FFFFFF\"));\n        this.view.pivot.set(this.playerView.width / 2, this.playerView.height / 2);\n        // Setup Sword View\n        this.swordAnimations = new AnimationController(animations);\n        this.swordAnimations.setAnimation(\"sword\").setFrame(0);\n        this.swordView.addChild(this.swordAnimations.view);\n        this.swordView.x = this.playerView.width / 2;\n        this.swordView.rotation = Math.PI / 2;\n        this.swordView.y += 8;\n        this.swordCollider = new CollisionBody(engine, 0, 0, this.swordView.width, this.swordView.height, 'sword', true);\n        this.swordView.addChild(this.swordCollider.view);\n        this.swordCooldownMax = 30;\n        this.swordCooldown = 0;\n        this.slash = false;\n        this.collisionBody.onCollision((o, sides) => {\n            if (sides.includes(\"bottom\")) {\n                this.jumpEnd = true;\n            }\n        });\n        this.swordCollider.onCollision((o, sides) => {\n            if (o.type === 'spike' && this.slash) {\n                this.physicsBody.speed.y -= 8;\n                this.slash = false;\n            }\n        });\n        this.jumping = false;\n        this.jumpHeight = this.view.height / 2;\n        this.jumpLanded = false;\n    }\n    update(deltaTime) {\n        this.swordCooldown = Math.max(this.swordCooldown - deltaTime, 0);\n        this.slash = false;\n        if (this.lastDeath > 0) {\n            this.lastDeath -= deltaTime;\n            this.playerAnimations.setAnimation('walk').setFrame(0);\n            this.physicsBody.speed.setX(0);\n            return;\n        }\n        this.lastDeath = 0;\n        if (this.controller.keys['right'].pressed) {\n            this.playerAnimations.setAnimation(\"walk\").play();\n            this.playerView.scale.x = Math.abs(this.view.scale.x);\n            this.physicsBody.speed.setX(2);\n        }\n        else if (this.controller.keys['left'].pressed) {\n            this.playerView.scale.x = -Math.abs(this.view.scale.x);\n            this.physicsBody.speed.setX(-2);\n            this.playerAnimations.setAnimation(\"walk\").play();\n        }\n        else {\n            this.physicsBody.speed.setX(0);\n            this.playerAnimations.setAnimation(\"walk\").setFrame(0);\n        }\n        if (this.controller.keys.space.pressed && (this.physicsBody.onGround || this.jumping)) {\n            if (!this.jumping) {\n                console.log(\"here\");\n                this.jumping = true;\n                if (!this.jumpEnd) {\n                    this.playerAnimations.setAnimation(\"jump\");\n                }\n                this.jumpStart = this.view.y;\n                let audio = new Audio(jump);\n                audio.play();\n            }\n            if (!this.jumpEnd) {\n                this.playerAnimations.setAnimation(\"jump\").setFrame(1);\n                this.physicsBody.speed.y -= 1 * deltaTime;\n                this.jumpLanded = false;\n            }\n            if (this.jumpStart - this.view.y >= this.jumpHeight) {\n                this.jumpEnd = true;\n            }\n        }\n        if (!this.controller.keys.space.pressed && this.physicsBody.onGround) {\n            this.jumping = false;\n            this.jumpEnd = false;\n        }\n        if (!this.jumpLanded && this.jumpEnd) {\n            this.playerAnimations.setAnimation(\"jump\").setFrame(2);\n        }\n        if (!this.jumping && this.physicsBody.onGround) {\n            this.jumpLanded = true;\n        }\n        console.log(this.jumping || !this.jumpLanded);\n        if (this.controller.keys.down.pressed && this.swordCooldown === 0 && (Math.abs(this.physicsBody.speed.y) > 0.1)) {\n            console.log(\"hello\");\n            this.slash = true;\n            this.swordCooldown = this.swordCooldownMax;\n            this.swordAnimations.setAnimation('sword').setFrame(0).play();\n        }\n        if (this.controller.keys.down.pressed) {\n            console.log(this.jumping);\n        }\n    }\n    static Create(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const characterSpriteSheet = new Spritesheet(Texture.from(atlasData.characters.meta.image), atlasData.characters);\n            yield characterSpriteSheet.parse();\n            const playerWalk = new AnimatedSprite(characterSpriteSheet.animations.playerWalk);\n            playerWalk.animationSpeed = 0.2;\n            playerWalk.scale = 1;\n            const playerJump = new AnimatedSprite(characterSpriteSheet.animations.playerJump);\n            const playerSlash = new AnimatedSprite(characterSpriteSheet.animations.playerSlash);\n            playerSlash.loop = false;\n            playerSlash.onComplete = () => { playerSlash.gotoAndStop(0); };\n            const animations = {\n                walk: playerWalk,\n                jump: playerJump,\n                sword: playerSlash,\n            };\n            return new Player(controller, animations, e);\n        });\n    }\n}\n","const settings = {\n  /** The default number of textures per tilemap in a tilemap composite. */\n  TEXTURES_PER_TILEMAP: 16,\n  /** The scaling mode of the combined texture tiling. */\n  TEXTILE_SCALE_MODE: \"linear\",\n  /** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */\n  use32bitIndex: false\n};\nconst Constant = settings;\n\nexport { Constant, settings };\n//# sourceMappingURL=settings.mjs.map\n","import { Geometry, Buffer, BufferUsage } from 'pixi.js';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _TilemapGeometry = class _TilemapGeometry extends Geometry {\n  constructor(indexBuffer) {\n    const buf = new Buffer({\n      data: new Float32Array(2),\n      label: \"tilemap-buffer\",\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n      shrinkToFit: false\n    });\n    const stride = _TilemapGeometry.stride;\n    super({\n      indexBuffer,\n      attributes: {\n        aVertexPosition: {\n          buffer: buf,\n          format: \"float32x2\",\n          stride,\n          offset: 0\n          // location: 6,\n        },\n        aTextureCoord: {\n          buffer: buf,\n          format: \"float32x2\",\n          stride,\n          offset: 2 * 4\n          // location: 4,\n        },\n        aFrame: {\n          buffer: buf,\n          format: \"float32x4\",\n          stride,\n          offset: 4 * 4\n          // location: 3,\n        },\n        aAnim: {\n          buffer: buf,\n          format: \"float32x2\",\n          stride,\n          offset: 8 * 4\n          // location: 1,\n        },\n        aTextureId: {\n          buffer: buf,\n          format: \"sint32\",\n          stride,\n          offset: 10 * 4\n          // location: 5\n        },\n        aAnimDivisor: {\n          buffer: buf,\n          format: \"float32\",\n          stride,\n          offset: 11 * 4\n          // location: 2\n        },\n        aAlpha: {\n          buffer: buf,\n          format: \"float32\",\n          stride,\n          offset: 12 * 4\n          // location: 0\n        }\n      }\n    });\n    __publicField(this, \"lastTimeAccess\", 0);\n    __publicField(this, \"vertSize\", _TilemapGeometry.vertSize);\n    __publicField(this, \"vertPerQuad\", _TilemapGeometry.vertPerQuad);\n    __publicField(this, \"stride\", _TilemapGeometry.stride);\n    __publicField(this, \"buf\");\n    this.buf = buf;\n  }\n};\n__publicField(_TilemapGeometry, \"vertSize\", 13);\n__publicField(_TilemapGeometry, \"vertPerQuad\", 4);\n__publicField(_TilemapGeometry, \"stride\", _TilemapGeometry.vertSize * 4);\nlet TilemapGeometry = _TilemapGeometry;\n\nexport { TilemapGeometry };\n//# sourceMappingURL=TilemapGeometry.mjs.map\n","import { ExtensionType, UniformGroup, Matrix, Buffer, BufferUsage } from 'pixi.js';\nimport { settings } from './settings.mjs';\nimport { TilemapGeometry } from './TilemapGeometry.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass TilemapAdaptor {\n  constructor() {\n    __publicField(this, \"pipe_uniforms\", new UniformGroup({\n      u_proj_trans: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      u_anim_frame: { value: new Float32Array(2), type: \"vec2<f32>\" }\n    }));\n  }\n}\nclass TilemapPipe {\n  constructor(renderer, adaptor) {\n    /** The managing renderer */\n    __publicField(this, \"renderer\");\n    /** The tile animation frame */\n    __publicField(this, \"tileAnim\", [0, 0]);\n    __publicField(this, \"ibLen\", 0);\n    // index buffer length\n    /** The index buffer for the tilemaps to share. */\n    __publicField(this, \"indexBuffer\", null);\n    /** The shader used to render tilemaps. */\n    __publicField(this, \"shader\");\n    __publicField(this, \"adaptor\");\n    this.renderer = renderer;\n    this.adaptor = adaptor;\n    this.adaptor.init();\n    this.indexBuffer = new Buffer({\n      data: new Uint16Array([0, 1, 2, 0, 2, 3]),\n      label: \"index-tilemap-buffer\",\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST\n    });\n    this.checkIndexBuffer(2e3);\n  }\n  start() {\n  }\n  /**\n  * @internal\n  * @ignore\n  */\n  createVb() {\n    const geom = new TilemapGeometry(this.indexBuffer);\n    geom.lastTimeAccess = Date.now();\n    return geom;\n  }\n  /** @return The {@link TilemapGeometry} shader that this rendering pipeline is using. */\n  getShader() {\n    return this.shader;\n  }\n  destroy() {\n    this.shader = null;\n  }\n  // eslint-disable-next-line no-unused-vars\n  checkIndexBuffer(size) {\n    const totalIndices = size * 6;\n    if (totalIndices <= this.ibLen) {\n      return;\n    }\n    this.ibLen = totalIndices;\n    this.indexBuffer.data = createIndicesForQuads(\n      size,\n      settings.use32bitIndex ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices)\n    );\n  }\n  destroyRenderable(_renderable) {\n    _renderable.vb.destroy(true);\n    _renderable.vb = null;\n  }\n  addRenderable(tilemap, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    tilemap.updateBuffer(this);\n    tilemap.checkValid();\n    tilemap.getTileset().update();\n    if (tilemap.is_valid) {\n      batcher.break(instructionSet);\n      instructionSet.add(tilemap._instruction);\n    }\n  }\n  updateRenderable(tilemap, _instructionSet) {\n    tilemap.updateBuffer(this);\n    tilemap.getTileset().update();\n  }\n  validateRenderable(renderable) {\n    return renderable.checkValid();\n  }\n  execute({ tilemap }) {\n    if (!tilemap.isRenderable)\n      return;\n    tilemap.state.blendMode = tilemap.groupBlendMode;\n    const { pipe_uniforms } = this.adaptor;\n    const u_proj_trans = pipe_uniforms.uniforms.u_proj_trans;\n    const u_global = this.renderer.globalUniforms._activeUniforms.at(-1).uniforms;\n    let anim_frame = this.tileAnim;\n    const { u_anim_frame } = pipe_uniforms.uniforms;\n    u_global.uProjectionMatrix.copyTo(u_proj_trans).append(u_global.uWorldTransformMatrix).append(tilemap.worldTransform);\n    if (tilemap.compositeParent) {\n      anim_frame = tilemap.parent.tileAnim || anim_frame;\n    }\n    u_anim_frame[0] = anim_frame[0];\n    u_anim_frame[1] = anim_frame[1];\n    pipe_uniforms.update();\n    this.adaptor.execute(this, tilemap);\n  }\n}\n__publicField(TilemapPipe, \"extension\", {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"tilemap\"\n});\nfunction createIndicesForQuads(size, outBuffer) {\n  const totalIndices = size * 6;\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  }\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {\n    outBuffer[i + 0] = j + 0;\n    outBuffer[i + 1] = j + 1;\n    outBuffer[i + 2] = j + 2;\n    outBuffer[i + 3] = j + 0;\n    outBuffer[i + 4] = j + 2;\n    outBuffer[i + 5] = j + 3;\n  }\n  return outBuffer;\n}\n\nexport { TilemapAdaptor, TilemapPipe };\n//# sourceMappingURL=TilemapPipe.mjs.map\n","import { Buffer, BufferUsage, UniformGroup, Texture, BindGroup } from 'pixi.js';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass TileTextureArray {\n  constructor(max_textures) {\n    __publicField(this, \"max_textures\");\n    __publicField(this, \"arr\", []);\n    __publicField(this, \"count\", 0);\n    __publicField(this, \"dirty\", false);\n    __publicField(this, \"dirty_gpu\", false);\n    __publicField(this, \"bind_group\", null);\n    __publicField(this, \"bind_group_resources\", {});\n    __publicField(this, \"tex_sizes\", null);\n    __publicField(this, \"null_color\", new Float32Array([0, 0, 0, 0.5]));\n    __publicField(this, \"tex_buf\", null);\n    this.max_textures = max_textures;\n    this.tex_sizes = new Float32Array(this.max_textures * 4 + 4);\n    this.tex_buf = new Buffer({\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    });\n  }\n  get length() {\n    return this.count;\n  }\n  push(tex) {\n    this.arr[this.count++] = tex;\n    this.dirty = true;\n  }\n  at(ind) {\n    return this.arr[ind];\n  }\n  update() {\n    if (!this.dirty) {\n      return;\n    }\n    this.dirty = false;\n    this.dirty_gpu = true;\n    const { tex_sizes, arr, count, max_textures, null_color } = this;\n    for (let i = 0; i < count; i++) {\n      const tex = arr[i];\n      if (tex) {\n        tex_sizes[i * 4] = tex.pixelWidth;\n        tex_sizes[i * 4 + 1] = tex.pixelHeight;\n        tex_sizes[i * 4 + 2] = 1 / tex.pixelWidth;\n        tex_sizes[i * 4 + 3] = 1 / tex.pixelHeight;\n      }\n    }\n    tex_sizes[max_textures * 4] = null_color[0];\n    tex_sizes[max_textures * 4 + 1] = null_color[1];\n    tex_sizes[max_textures * 4 + 2] = null_color[2];\n    tex_sizes[max_textures * 4 + 3] = null_color[3];\n  }\n  markDirty() {\n    this.dirty = true;\n  }\n  getBindGroup() {\n    this.update();\n    if (!this.dirty_gpu) {\n      return this.bind_group;\n    }\n    const { bind_group_resources, max_textures, arr, count } = this;\n    let bindIndex = 0;\n    bind_group_resources[bindIndex++] = new UniformGroup({\n      u_texture_size: {\n        value: this.tex_sizes,\n        type: \"vec4<f32>\",\n        size: max_textures\n      },\n      u_null_color: {\n        value: this.null_color,\n        type: \"vec4<f32>\"\n      }\n    });\n    for (let i = 0; i < max_textures; i++) {\n      const texture = (i < count ? arr[i] : null) || Texture.EMPTY.source;\n      bind_group_resources[bindIndex++] = texture.source;\n      bind_group_resources[bindIndex++] = texture.style;\n    }\n    if (!this.bind_group) {\n      this.bind_group = new BindGroup(bind_group_resources);\n    }\n    return this.bind_group;\n  }\n  static generate_gpu_textures(max_textures) {\n    const src = [];\n    src.push(`struct TextureArrayFields {`);\n    src.push(`    u_texture_size: array<vec4f, ${max_textures}>,`);\n    src.push(`    u_null_color: vec4f`);\n    src.push(`}`);\n    src.push(`@group(1) @binding(0) var<uniform> taf: TextureArrayFields;`);\n    for (let i = 0; i < max_textures; i++) {\n      src.push(`@group(1) @binding(${i * 2 + 1}) var u_texture_${i}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${i * 2 + 2}) var u_sampler_${i}: sampler;`);\n    }\n    src.push(\"fn sampleMultiTexture(texture_id: i32, uv: vec2f, dx: vec2f, dy: vec2f) -> vec4f {\");\n    src.push(`switch texture_id {`);\n    for (let i = 0; i < max_textures; i++) {\n      src.push(`  case ${i}: { return textureSampleGrad(u_texture_${i}, u_sampler_${i}, uv, dx, dy); }`);\n    }\n    src.push(`  default: { return taf.u_null_color; }`);\n    src.push(\"} }\");\n    return src.join(\"\\n\");\n  }\n  static generate_gl_textures(max_textures) {\n    const src = [];\n    src.push(`uniform vec4 u_texture_size[${max_textures + 1}];`);\n    src.push(`uniform sampler2D u_textures[${max_textures}];`);\n    src.push(`uniform vec4 u_null_color;`);\n    src.push(\"vec4 sampleMultiTexture(float texture_id, vec2 uv) {\");\n    src.push(`if(texture_id < -0.5) return u_texture_size[${max_textures}];`);\n    for (let i = 0; i < max_textures; i++) {\n      src.push(`if(texture_id < ${i}.5) return texture(u_textures[${i}], uv * u_texture_size[${i}].zw);`);\n    }\n    src.push(`return u_texture_size[${max_textures}];`);\n    src.push(\"}\");\n    return src.join(\"\\n\");\n  }\n  static gl_gen_resources(max_textures) {\n    const sampleValues = [];\n    for (let i = 0; i < max_textures; i++) {\n      sampleValues[i] = i;\n    }\n    const samplerSize = [];\n    for (let i = 0; i < max_textures; i++) {\n      samplerSize.push(2048);\n      samplerSize.push(2048);\n      samplerSize.push(1 / 2048);\n      samplerSize.push(1 / 2048);\n    }\n    return {\n      u_textures: {\n        value: sampleValues,\n        type: \"i32\",\n        size: max_textures\n      },\n      u_texture_size: {\n        value: samplerSize,\n        type: \"vec4<f32>\",\n        size: max_textures\n      }\n    };\n  }\n}\n\nexport { TileTextureArray };\n//# sourceMappingURL=TileTextureArray.mjs.map\n","import { ExtensionType, Shader, GlProgram, UniformGroup } from 'pixi.js';\nimport { settings } from './settings.mjs';\nimport { TilemapAdaptor } from './TilemapPipe.mjs';\nimport { TileTextureArray } from './TileTextureArray.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst gl_tilemap_vertex = `\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\nin vec4 aFrame;\nin vec2 aAnim;\nin float aAnimDivisor;\nin float aTextureId;\nin float aAlpha;\n\nuniform mat3 u_proj_trans;\nuniform vec2 u_anim_frame;\n\nout vec2 vTextureCoord;\nout float vTextureId;\nout vec4 vFrame;\nout float vAlpha;\n\nvoid main(void)\n{\n  gl_Position = vec4((u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n  vec2 animCount = floor((aAnim + 0.5) / 2048.0);\n  vec2 animFrameOffset = aAnim - animCount * 2048.0;\n  vec2 currentFrame = floor(u_anim_frame / aAnimDivisor);\n  vec2 loop_num = floor((currentFrame + 0.5) / animCount);\n  vec2 animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\n\n  vTextureCoord = aTextureCoord + animOffset;\n  vFrame = aFrame + vec4(animOffset, animOffset);\n  vTextureId = aTextureId;\n  vAlpha = aAlpha;\n}\n`;\nconst gl_tilemap_fragment = `\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nin vec2 vTextureCoord;\nin vec4 vFrame;\nin float vTextureId;\nin float vAlpha;\n\n//include_textures\n\nvoid main(void)\n{\n  float textureId = floor(vTextureId + 0.5);\n  vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n  vec4 color = sampleMultiTexture(textureId, textureCoord);\n  finalColor = color * vAlpha;\n}\n`;\nclass GlTilemapAdaptor extends TilemapAdaptor {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"_shader\", null);\n    __publicField(this, \"max_textures\", settings.TEXTURES_PER_TILEMAP);\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n  execute(pipe, tilemap) {\n    const renderer = pipe.renderer;\n    const shader = this._shader;\n    const tileset = tilemap.getTileset();\n    const tu = shader.resources.texture_uniforms;\n    if (tu.uniforms.u_texture_size !== tileset.tex_sizes) {\n      tu.uniforms.u_texture_size = tileset.tex_sizes;\n      tu.update();\n    }\n    for (let i = 0; i < tileset.length; i++) {\n      renderer.texture.bind(tileset.arr[i], i);\n    }\n    renderer.encoder.draw({\n      geometry: tilemap.vb,\n      shader,\n      state: tilemap.state,\n      size: tilemap.rects_count * 6\n    });\n  }\n  init() {\n    this._shader = new Shader({\n      glProgram: GlProgram.from({\n        vertex: gl_tilemap_vertex,\n        fragment: gl_tilemap_fragment.replace(\n          \"//include_textures\",\n          TileTextureArray.generate_gl_textures(this.max_textures)\n        )\n      }),\n      resources: {\n        texture_uniforms: new UniformGroup(TileTextureArray.gl_gen_resources(this.max_textures), { isStatic: true }),\n        pipe_uniforms: this.pipe_uniforms.uniformStructures\n      }\n    });\n  }\n}\n__publicField(GlTilemapAdaptor, \"extension\", {\n  type: [\n    ExtensionType.WebGLPipesAdaptor\n  ],\n  name: \"tilemap\"\n});\n\nexport { GlTilemapAdaptor };\n//# sourceMappingURL=gl_tilemap.mjs.map\n","import { ExtensionType, Shader, GpuProgram, BindGroup } from 'pixi.js';\nimport { settings } from './settings.mjs';\nimport { TilemapAdaptor } from './TilemapPipe.mjs';\nimport { TileTextureArray } from './TileTextureArray.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst gpu_tilemap_vertex = `\nstruct GlobalUniforms {\n  uProjectionMatrix:mat3x3f,\n  uWorldTransformMatrix:mat3x3f,\n  uWorldColorAlpha: vec4f,\n  uResolution: vec2f,\n}\n\nstruct TilemapUniforms {\n  u_proj_trans:mat3x3f,\n  u_anim_frame:vec2f\n}\n\n@group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n@group(2) @binding(0) var<uniform> loc: TilemapUniforms;\n\nstruct VSOutput {\n  @builtin(position) vPosition: vec4f,\n  @location(0) @interpolate(flat) vTextureId : i32,\n  @location(1) vTextureCoord : vec2f,\n  @location(2) @interpolate(flat) vFrame : vec4f,\n  @location(3) vAlpha : f32\n};\n\n@vertex\nfn mainVert(\n   @location(6) aVertexPosition: vec2f,\n   @location(4) aTextureCoord: vec2f,\n   @location(3) aFrame: vec4f,\n   @location(1) aAnim: vec2f,\n   @location(2) aAnimDivisor: f32,\n   @location(5) aTextureId: i32,\n   @location(0) aAlpha: f32,\n ) -> VSOutput {\n\n  var vPosition = vec4((loc.u_proj_trans * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n  var animCount = floor((aAnim + 0.5) / 2048.0);\n  var animFrameOffset = aAnim - animCount * 2048.0;\n  var currentFrame = floor(loc.u_anim_frame / aAnimDivisor);\n  var loop_num = floor((currentFrame + 0.5) / animCount);\n  var animOffset = animFrameOffset * floor(currentFrame - loop_num * animCount);\n  var vTextureCoord = aTextureCoord + animOffset;\n  var vFrame = aFrame + vec4(animOffset, animOffset);\n\n  return VSOutput(vPosition, aTextureId, vTextureCoord, vFrame, aAlpha);\n};\n`;\nconst gpu_tilemap_fragment = `\n//include_textures\n\n@fragment\nfn mainFrag(\n  @location(0) @interpolate(flat) vTextureId : i32,\n  @location(1) vTextureCoord : vec2f,\n  @location(2) @interpolate(flat) vFrame : vec4f,\n  @location(3) vAlpha : f32,\n  ) -> @location(0) vec4f {\n  var textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n  var uv = textureCoord * taf.u_texture_size[vTextureId].zw;\n  var dx = dpdx(uv);\n  var dy = dpdy(uv);\n  var color = sampleMultiTexture(vTextureId, uv, dx, dy);\n  return color * vAlpha;\n};\n`;\nclass GpuTilemapAdaptor extends TilemapAdaptor {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"_shader\", null);\n    __publicField(this, \"max_textures\", settings.TEXTURES_PER_TILEMAP);\n    __publicField(this, \"bind_group\", null);\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n  execute(pipe, tilemap) {\n    const renderer = pipe.renderer;\n    const shader = this._shader;\n    shader.groups[0] = renderer.globalUniforms.bindGroup;\n    shader.groups[1] = tilemap.getTileset().getBindGroup();\n    shader.groups[2] = this.bind_group;\n    renderer.encoder.draw({\n      geometry: tilemap.vb,\n      shader,\n      state: tilemap.state,\n      size: tilemap.rects_count * 6\n    });\n  }\n  init() {\n    this._shader = new Shader({\n      gpuProgram: GpuProgram.from({\n        vertex: { source: gpu_tilemap_vertex, entryPoint: \"mainVert\" },\n        fragment: {\n          source: gpu_tilemap_fragment.replace(\"//include_textures\", TileTextureArray.generate_gpu_textures(this.max_textures))\n        }\n      })\n    });\n    this.bind_group = new BindGroup({\n      ut: this.pipe_uniforms\n    });\n  }\n}\n__publicField(GpuTilemapAdaptor, \"extension\", {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"tilemap\"\n});\n\nexport { GpuTilemapAdaptor };\n//# sourceMappingURL=gpu_tilemap.mjs.map\n","import { Container, State, Bounds, TextureSource, Texture, groupD8 } from 'pixi.js';\nimport { settings } from './settings.mjs';\nimport { TileTextureArray } from './TileTextureArray.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar POINT_STRUCT = /* @__PURE__ */ ((POINT_STRUCT2) => {\n  POINT_STRUCT2[POINT_STRUCT2[\"U\"] = 0] = \"U\";\n  POINT_STRUCT2[POINT_STRUCT2[\"V\"] = 1] = \"V\";\n  POINT_STRUCT2[POINT_STRUCT2[\"X\"] = 2] = \"X\";\n  POINT_STRUCT2[POINT_STRUCT2[\"Y\"] = 3] = \"Y\";\n  POINT_STRUCT2[POINT_STRUCT2[\"TILE_WIDTH\"] = 4] = \"TILE_WIDTH\";\n  POINT_STRUCT2[POINT_STRUCT2[\"TILE_HEIGHT\"] = 5] = \"TILE_HEIGHT\";\n  POINT_STRUCT2[POINT_STRUCT2[\"ROTATE\"] = 6] = \"ROTATE\";\n  POINT_STRUCT2[POINT_STRUCT2[\"ANIM_X\"] = 7] = \"ANIM_X\";\n  POINT_STRUCT2[POINT_STRUCT2[\"ANIM_Y\"] = 8] = \"ANIM_Y\";\n  POINT_STRUCT2[POINT_STRUCT2[\"TEXTURE_INDEX\"] = 9] = \"TEXTURE_INDEX\";\n  POINT_STRUCT2[POINT_STRUCT2[\"ANIM_COUNT_X\"] = 10] = \"ANIM_COUNT_X\";\n  POINT_STRUCT2[POINT_STRUCT2[\"ANIM_COUNT_Y\"] = 11] = \"ANIM_COUNT_Y\";\n  POINT_STRUCT2[POINT_STRUCT2[\"ANIM_DIVISOR\"] = 12] = \"ANIM_DIVISOR\";\n  POINT_STRUCT2[POINT_STRUCT2[\"ALPHA\"] = 13] = \"ALPHA\";\n  return POINT_STRUCT2;\n})(POINT_STRUCT || {});\nconst POINT_STRUCT_SIZE = Object.keys(POINT_STRUCT).length / 2;\nclass Tilemap extends Container {\n  /**\n   * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The\n   *      base-textures in this array must not be duplicated.\n   */\n  constructor(tileset) {\n    super();\n    // TODO: make default color work\n    /**\n     * Currently doesnt work.\n     */\n    __publicField(this, \"shadowColor\", new Float32Array([0, 0, 0, 0.5]));\n    __publicField(this, \"state\", State.for2d());\n    __publicField(this, \"is_valid\", false);\n    __publicField(this, \"renderPipeId\", \"tilemap\");\n    __publicField(this, \"canBundle\", true);\n    __publicField(this, \"_instruction\", {\n      renderPipeId: \"tilemap\",\n      tilemap: this\n    });\n    /**\n     * The tile animation frame.\n     *\n     * @see CompositeTilemap.tileAnim\n     */\n    __publicField(this, \"tileAnim\", null);\n    /**\n     * This is the last uploaded size of the tilemap geometry.\n     * @ignore\n     */\n    __publicField(this, \"rects_count\", 0);\n    /** @ignore */\n    __publicField(this, \"compositeParent\", false);\n    /**\n     * The list of base-textures being used in the tilemap.\n     *\n     * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\n     * should be added after tiles have been added into the map.\n     */\n    __publicField(this, \"tileset\", new TileTextureArray(settings.TEXTURES_PER_TILEMAP));\n    /**\n     * The local bounds of the tilemap itself. This does not include DisplayObject children.\n     */\n    __publicField(this, \"tilemapBounds\", new Bounds());\n    /** Flags whether any animated tile was added. */\n    __publicField(this, \"hasAnimatedTile\", false);\n    /** The interleaved geometry of the tilemap. */\n    __publicField(this, \"pointsBuf\", []);\n    __publicField(this, \"vbId\", 0);\n    __publicField(this, \"vb\", null);\n    __publicField(this, \"vbBuffer\", null);\n    __publicField(this, \"vbArray\", null);\n    __publicField(this, \"vbInts\", null);\n    this.setTileset(tileset);\n  }\n  /**\n   * @internal\n   * @ignore\n   */\n  checkValid() {\n    const v = this.tileset.count > 0 && this.pointsBuf.length > 0;\n    const res = this.is_valid !== v;\n    this.is_valid = v;\n    return res !== v;\n  }\n  /**\n   * @returns The tileset of this tilemap.\n   */\n  getTileset() {\n    return this.tileset;\n  }\n  /**\n   * Define the tileset used by the tilemap.\n   *\n   * @param textureOrArray - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will\n   *  be wrapped into an array. This should not contain any duplicates.\n   */\n  setTileset(textureOrArray = []) {\n    let ts = this.tileset;\n    if (textureOrArray instanceof TileTextureArray) {\n      this.tileset = textureOrArray;\n      this.didViewUpdate = true;\n    } else if (textureOrArray instanceof TextureSource) {\n      if (ts.count === 1 && ts.arr[0] === textureOrArray) {\n        return this;\n      }\n      ts = this.tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n      ts.push(textureOrArray);\n      this.didViewUpdate = true;\n    } else {\n      if (textureOrArray.length === ts.count) {\n        let flag = true;\n        for (let i = 0; i < textureOrArray.length; i++) {\n          if (textureOrArray[i]?.source !== ts.arr[i]) {\n            flag = false;\n            break;\n          }\n        }\n        if (flag) {\n          return this;\n        }\n      }\n      ts = this.tileset = new TileTextureArray(settings.TEXTURES_PER_TILEMAP);\n      for (let i = 0; i < textureOrArray.length; i++) {\n        ts.push(textureOrArray[i]?.source);\n      }\n      this.didViewUpdate = true;\n    }\n    return this;\n  }\n  /**  Clears all the tiles added into this tilemap. */\n  clear() {\n    this.pointsBuf.length = 0;\n    this.rects_count = 0;\n    this.tilemapBounds.clear();\n    this.hasAnimatedTile = false;\n    return this;\n  }\n  /**\n   * Adds a tile that paints the given texture at (x, y).\n   *\n   * @param tileTexture - The tiling texture to render.\n   * @param x - The local x-coordinate of the tile's position.\n   * @param y - The local y-coordinate of the tile's position.\n   * @param options - Additional tile options.\n   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\n   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\n   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\n   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\n   * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\n   *      animation frame textures in the base-texture.\n   * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\n   *      animation frames textures in the base-texture.\n   * @param [options.rotate=0]\n   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\n   *      per row.\n   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\n   *      per column.\n   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame\n   * @param [options.alpha=1] - Tile alpha\n   * @return This tilemap, good for chaining.\n   */\n  tile(tileTexture, x, y, options = {}) {\n    this.didViewUpdate = true;\n    let baseTexture;\n    let textureIndex = -1;\n    let was_num = false;\n    if (typeof tileTexture === \"number\") {\n      textureIndex = tileTexture;\n      was_num = true;\n      baseTexture = this.tileset.arr[textureIndex];\n    } else {\n      let texture;\n      if (typeof tileTexture === \"string\") {\n        texture = Texture.from(tileTexture);\n      } else {\n        texture = tileTexture;\n      }\n      const textureList = this.tileset;\n      for (let i = 0; i < textureList.count; i++) {\n        if (textureList.arr[i] === texture.source) {\n          textureIndex = i;\n          break;\n        }\n      }\n      if (\"frame\" in texture) {\n        options.u = options.u ?? texture.frame.x;\n        options.v = options.v ?? texture.frame.y;\n        options.tileWidth = options.tileWidth ?? texture.orig.width;\n        options.tileHeight = options.tileHeight ?? texture.orig.height;\n      }\n      baseTexture = texture.source;\n    }\n    if (!was_num && !baseTexture) {\n      console.error(\"The tile texture was not found in the tilemap tileset.\");\n      return this;\n    }\n    const {\n      u = 0,\n      v = 0,\n      tileWidth = baseTexture.width,\n      tileHeight = baseTexture.height,\n      animX = 0,\n      animY = 0,\n      rotate = 0,\n      animCountX = 1024,\n      animCountY = 1024,\n      animDivisor = 1,\n      alpha = 1\n    } = options;\n    const pb = this.pointsBuf;\n    this.hasAnimatedTile = this.hasAnimatedTile || animX > 0 || animY > 0;\n    pb.push(u);\n    pb.push(v);\n    pb.push(x);\n    pb.push(y);\n    pb.push(tileWidth);\n    pb.push(tileHeight);\n    pb.push(rotate);\n    pb.push(animX | 0);\n    pb.push(animY | 0);\n    pb.push(textureIndex);\n    pb.push(animCountX);\n    pb.push(animCountY);\n    pb.push(animDivisor);\n    pb.push(alpha);\n    this.tilemapBounds.addFrame(x, y, x + tileWidth, y + tileHeight);\n    return this;\n  }\n  /** Changes the rotation of the last tile. */\n  tileRotate(rotate) {\n    const pb = this.pointsBuf;\n    pb[pb.length - (POINT_STRUCT_SIZE - 9 /* TEXTURE_INDEX */)] = rotate;\n  }\n  /** Changes the `animX`, `animCountX` of the last tile. */\n  tileAnimX(offset, count) {\n    const pb = this.pointsBuf;\n    pb[pb.length - (POINT_STRUCT_SIZE - 7 /* ANIM_X */)] = offset;\n    pb[pb.length - (POINT_STRUCT_SIZE - 10 /* ANIM_COUNT_X */)] = count;\n  }\n  /** Changes the `animY`, `animCountY` of the last tile. */\n  tileAnimY(offset, count) {\n    const pb = this.pointsBuf;\n    pb[pb.length - (POINT_STRUCT_SIZE - 8 /* ANIM_Y */)] = offset;\n    pb[pb.length - (POINT_STRUCT_SIZE - 11 /* ANIM_COUNT_Y */)] = count;\n  }\n  /** Changes the `animDivisor` value of the last tile. */\n  tileAnimDivisor(divisor) {\n    const pb = this.pointsBuf;\n    pb[pb.length - (POINT_STRUCT_SIZE - 12 /* ANIM_DIVISOR */)] = divisor;\n  }\n  tileAlpha(alpha) {\n    const pb = this.pointsBuf;\n    pb[pb.length - (POINT_STRUCT_SIZE - 13 /* ALPHA */)] = alpha;\n  }\n  destroyVb() {\n    if (this.vb) {\n      this.vb.destroy();\n      this.vb = null;\n    }\n  }\n  updateBuffer(plugin) {\n    const points = this.pointsBuf;\n    const rects_count = points.length / POINT_STRUCT_SIZE;\n    let vb = this.vb;\n    if (this.tileset.count === 0 || rects_count === 0 || this.rects_count === rects_count && vb) {\n      return;\n    }\n    this.rects_count = rects_count;\n    if (!vb) {\n      vb = plugin.createVb();\n      this.vb = vb;\n      this.vbId = vb.id;\n      this.vbBuffer = null;\n    }\n    const vertices = rects_count * vb.vertPerQuad;\n    plugin.checkIndexBuffer(rects_count);\n    const vertexBuf = vb.getBuffer(\"aVertexPosition\");\n    const vs = vb.stride * vertices;\n    if (!this.vbBuffer || this.vbBuffer.byteLength < vs) {\n      let bk = vb.stride;\n      while (bk < vs) {\n        bk *= 2;\n      }\n      this.vbBuffer = new ArrayBuffer(bk);\n      this.vbArray = new Float32Array(this.vbBuffer);\n      this.vbInts = new Uint32Array(this.vbBuffer);\n    }\n    const arr = this.vbArray;\n    const ints = this.vbInts;\n    let sz = 0;\n    let textureId = 0;\n    for (let i = 0; i < points.length; i += POINT_STRUCT_SIZE) {\n      const eps = 0.5;\n      if (this.compositeParent) {\n        textureId = points[i + 9 /* TEXTURE_INDEX */];\n      }\n      const x = points[i + 2 /* X */];\n      const y = points[i + 3 /* Y */];\n      const w = points[i + 4 /* TILE_WIDTH */];\n      const h = points[i + 5 /* TILE_HEIGHT */];\n      const u = points[i + 0 /* U */];\n      const v = points[i + 1 /* V */];\n      let rotate = points[i + 6 /* ROTATE */];\n      const animX = points[i + 7 /* ANIM_X */];\n      const animY = points[i + 8 /* ANIM_Y */];\n      const animWidth = points[i + 10 /* ANIM_COUNT_X */] || 1024;\n      const animHeight = points[i + 11 /* ANIM_COUNT_Y */] || 1024;\n      const animXEncoded = animX + animWidth * 2048;\n      const animYEncoded = animY + animHeight * 2048;\n      const animDivisor = points[i + 12 /* ANIM_DIVISOR */];\n      const alpha = points[i + 13 /* ALPHA */];\n      let u0;\n      let v0;\n      let u1;\n      let v1;\n      let u2;\n      let v2;\n      let u3;\n      let v3;\n      if (rotate === 0) {\n        u0 = u;\n        v0 = v;\n        u1 = u + w;\n        v1 = v;\n        u2 = u + w;\n        v2 = v + h;\n        u3 = u;\n        v3 = v + h;\n      } else {\n        let w2 = w / 2;\n        let h2 = h / 2;\n        if (rotate % 4 !== 0) {\n          w2 = h / 2;\n          h2 = w / 2;\n        }\n        const cX = u + w2;\n        const cY = v + h2;\n        rotate = groupD8.add(rotate, groupD8.NW);\n        u0 = cX + w2 * groupD8.uX(rotate);\n        v0 = cY + h2 * groupD8.uY(rotate);\n        rotate = groupD8.add(rotate, 2);\n        u1 = cX + w2 * groupD8.uX(rotate);\n        v1 = cY + h2 * groupD8.uY(rotate);\n        rotate = groupD8.add(rotate, 2);\n        u2 = cX + w2 * groupD8.uX(rotate);\n        v2 = cY + h2 * groupD8.uY(rotate);\n        rotate = groupD8.add(rotate, 2);\n        u3 = cX + w2 * groupD8.uX(rotate);\n        v3 = cY + h2 * groupD8.uY(rotate);\n      }\n      arr[sz++] = x;\n      arr[sz++] = y;\n      arr[sz++] = u0;\n      arr[sz++] = v0;\n      arr[sz++] = u + eps;\n      arr[sz++] = v + eps;\n      arr[sz++] = u + w - eps;\n      arr[sz++] = v + h - eps;\n      arr[sz++] = animXEncoded;\n      arr[sz++] = animYEncoded;\n      ints[sz++] = textureId;\n      arr[sz++] = animDivisor;\n      arr[sz++] = alpha;\n      arr[sz++] = x + w;\n      arr[sz++] = y;\n      arr[sz++] = u1;\n      arr[sz++] = v1;\n      arr[sz++] = u + eps;\n      arr[sz++] = v + eps;\n      arr[sz++] = u + w - eps;\n      arr[sz++] = v + h - eps;\n      arr[sz++] = animXEncoded;\n      arr[sz++] = animYEncoded;\n      ints[sz++] = textureId;\n      arr[sz++] = animDivisor;\n      arr[sz++] = alpha;\n      arr[sz++] = x + w;\n      arr[sz++] = y + h;\n      arr[sz++] = u2;\n      arr[sz++] = v2;\n      arr[sz++] = u + eps;\n      arr[sz++] = v + eps;\n      arr[sz++] = u + w - eps;\n      arr[sz++] = v + h - eps;\n      arr[sz++] = animXEncoded;\n      arr[sz++] = animYEncoded;\n      ints[sz++] = textureId;\n      arr[sz++] = animDivisor;\n      arr[sz++] = alpha;\n      arr[sz++] = x;\n      arr[sz++] = y + h;\n      arr[sz++] = u3;\n      arr[sz++] = v3;\n      arr[sz++] = u + eps;\n      arr[sz++] = v + eps;\n      arr[sz++] = u + w - eps;\n      arr[sz++] = v + h - eps;\n      arr[sz++] = animXEncoded;\n      arr[sz++] = animYEncoded;\n      ints[sz++] = textureId;\n      arr[sz++] = animDivisor;\n      arr[sz++] = alpha;\n    }\n    vertexBuf.data = arr;\n  }\n  /**\n   * @internal\n   * @ignore\n   */\n  isModified(anim) {\n    if (this.rects_count * POINT_STRUCT_SIZE !== this.pointsBuf.length || anim && this.hasAnimatedTile) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * This will pull forward the modification marker.\n   *\n   * @internal\n   * @ignore\n   */\n  clearModify() {\n    this.rects_count = this.pointsBuf.length / POINT_STRUCT_SIZE;\n  }\n  addBounds(bounds) {\n    const _bounds = this.tilemapBounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  get bounds() {\n    return this.tilemapBounds;\n  }\n  /** @override */\n  destroy(options) {\n    super.destroy(options);\n    this.destroyVb();\n  }\n  /**\n   * Deprecated signature for {@link Tilemap.tile tile}.\n   *\n   * @deprecated Since @pixi/tilemap 3.\n   */\n  addFrame(texture, x, y, animX, animY) {\n    this.tile(\n      texture,\n      x,\n      y,\n      {\n        animX,\n        animY\n      }\n    );\n    return true;\n  }\n  /**\n   * Deprecated signature for {@link Tilemap.tile tile}.\n   *\n   * @deprecated Since @pixi/tilemap 3.\n   */\n  // eslint-disable-next-line max-params\n  addRect(textureIndex, u, v, x, y, tileWidth, tileHeight, animX = 0, animY = 0, rotate = 0, animCountX = 1024, animCountY = 1024, animDivisor = 1, alpha = 1) {\n    return this.tile(\n      textureIndex,\n      x,\n      y,\n      {\n        u,\n        v,\n        tileWidth,\n        tileHeight,\n        animX,\n        animY,\n        rotate,\n        animCountX,\n        animCountY,\n        animDivisor,\n        alpha\n      }\n    );\n  }\n}\n\nexport { POINT_STRUCT_SIZE, Tilemap };\n//# sourceMappingURL=Tilemap.mjs.map\n","import { Container, Texture } from 'pixi.js';\nimport { settings } from './settings.mjs';\nimport { Tilemap } from './Tilemap.mjs';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass CompositeTilemap extends Container {\n  // private shadowColor = new Float32Array([0.0, 0.0, 0.0, 0.5]);\n  /**\n   * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered\n   *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\n   *  will work equivalently.\n   */\n  constructor(tileset) {\n    super();\n    /** The hard limit on the number of tile textures used in each tilemap. */\n    __publicField(this, \"texturesPerTilemap\");\n    /**\n     * The animation frame vector.\n     *\n     * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures\n     * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per\n     * row and `animCountY` per column.\n     *\n     * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is\n     * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.\n     */\n    __publicField(this, \"tileAnim\", null);\n    /** The last modified tilemap. */\n    __publicField(this, \"lastModifiedTilemap\", null);\n    __publicField(this, \"modificationMarker\", 0);\n    /**\n     * Alias for {@link CompositeTilemap.tileset tileset}.\n     *\n     * @deprecated Since @pixi/tilemap 3.\n     */\n    __publicField(this, \"setBitmaps\", this.tileset);\n    this.texturesPerTilemap = settings.TEXTURES_PER_TILEMAP;\n    this.tileset(tileset);\n  }\n  /**\n   * This will preinitialize the tilesets of the layered tilemaps.\n   *\n   * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\n   * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\n   *\n   * @param tileTextures - The list of tile textures that make up the tileset.\n   */\n  tileset(tileTextures) {\n    if (!tileTextures) {\n      tileTextures = [];\n    }\n    const texPerChild = this.texturesPerTilemap;\n    const len1 = this.children.length;\n    const len2 = Math.ceil(tileTextures.length / texPerChild);\n    for (let i = 0; i < Math.min(len1, len2); i++) {\n      this.children[i].setTileset(\n        tileTextures.slice(i * texPerChild, (i + 1) * texPerChild)\n      );\n    }\n    for (let i = len1; i < len2; i++) {\n      const tilemap = new Tilemap(tileTextures.slice(i * texPerChild, (i + 1) * texPerChild));\n      tilemap.compositeParent = true;\n      this.addChild(tilemap);\n    }\n    return this;\n  }\n  /** Clears the tilemap composite. */\n  clear() {\n    for (let i = 0; i < this.children.length; i++) {\n      this.children[i].clear();\n    }\n    this.modificationMarker = 0;\n    return this;\n  }\n  /** Changes the rotation of the last added tile. */\n  tileRotate(rotate) {\n    if (this.lastModifiedTilemap) {\n      this.lastModifiedTilemap.tileRotate(rotate);\n    }\n    return this;\n  }\n  /** Changes `animX`, `animCountX` of the last added tile. */\n  tileAnimX(offset, count) {\n    if (this.lastModifiedTilemap) {\n      this.lastModifiedTilemap.tileAnimX(offset, count);\n    }\n    return this;\n  }\n  /** Changes `animY`, `animCountY` of the last added tile. */\n  tileAnimY(offset, count) {\n    if (this.lastModifiedTilemap) {\n      this.lastModifiedTilemap.tileAnimY(offset, count);\n    }\n    return this;\n  }\n  /** Changes `tileAnimDivisor` value of the last added tile. */\n  tileAnimDivisor(divisor) {\n    if (this.lastModifiedTilemap) {\n      this.lastModifiedTilemap.tileAnimDivisor(divisor);\n    }\n    return this;\n  }\n  /**\n   * Adds a tile that paints the given tile texture at (x, y).\n   *\n   * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\n   * @param x - The local x-coordinate of the tile's location.\n   * @param y - The local y-coordinate of the tile's location.\n   * @param options - Additional options to pass to {@link Tilemap.tile}.\n   * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\n   * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\n   * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\n   * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\n   * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\n   *      animation frame textures in the base-texture.\n   * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\n   *      animation frames textures in the base-texture.\n   * @param [options.rotate=0]\n   * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\n   *      per row.\n   * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\n   *      per column.\n   * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame\n   * @param [options.alpha=1] - Tile alpha\n   * @return This tilemap, good for chaining.\n   */\n  tile(tileTexture, x, y, options = {}) {\n    let tilemap = null;\n    const children = this.children;\n    this.lastModifiedTilemap = null;\n    if (typeof tileTexture === \"number\") {\n      const childIndex = tileTexture / this.texturesPerTilemap >> 0;\n      let tileIndex = 0;\n      tilemap = children[childIndex];\n      if (!tilemap) {\n        tilemap = children[0];\n        if (!tilemap)\n          return this;\n        tileIndex = 0;\n      } else {\n        tileIndex = tileTexture % this.texturesPerTilemap;\n      }\n      tilemap.tile(\n        tileIndex,\n        x,\n        y,\n        options\n      );\n    } else {\n      if (typeof tileTexture === \"string\") {\n        tileTexture = Texture.from(tileTexture);\n      }\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        const tex = child.getTileset().arr;\n        for (let j = 0; j < tex.length; j++) {\n          if (tex[j] === tileTexture.source) {\n            tilemap = child;\n            break;\n          }\n        }\n        if (tilemap) {\n          break;\n        }\n      }\n      if (!tilemap) {\n        for (let i = children.length - 1; i >= 0; i--) {\n          const child = children[i];\n          if (child.getTileset().count < this.texturesPerTilemap) {\n            tilemap = child;\n            child.getTileset().push(tileTexture.source);\n            break;\n          }\n        }\n        if (!tilemap) {\n          tilemap = new Tilemap(tileTexture.source);\n          tilemap.compositeParent = true;\n          this.addChild(tilemap);\n        }\n      }\n      tilemap.tile(\n        tileTexture,\n        x,\n        y,\n        options\n      );\n    }\n    this.lastModifiedTilemap = tilemap;\n    return this;\n  }\n  /**\n   * @internal\n   * @ignore\n   */\n  isModified(anim) {\n    const layers = this.children;\n    if (this.modificationMarker !== layers.length) {\n      return true;\n    }\n    for (let i = 0; i < layers.length; i++) {\n      if (layers[i].isModified(anim)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * @internal\n   * @ignore\n   */\n  clearModify() {\n    const layers = this.children;\n    this.modificationMarker = layers.length;\n    for (let i = 0; i < layers.length; i++) {\n      layers[i].clearModify();\n    }\n  }\n  /**\n   * @deprecated Since @pixi/tilemap 3.\n   * @see CompositeTilemap.tile\n   */\n  addFrame(texture, x, y, animX, animY, animWidth, animHeight, animDivisor, alpha) {\n    return this.tile(\n      texture,\n      x,\n      y,\n      {\n        animX,\n        animY,\n        animCountX: animWidth,\n        animCountY: animHeight,\n        animDivisor,\n        alpha\n      }\n    );\n  }\n  /**\n   * @deprecated @pixi/tilemap 3\n   * @see CompositeTilemap.tile\n   */\n  // eslint-disable-next-line max-params\n  addRect(textureIndex, u, v, x, y, tileWidth, tileHeight, animX, animY, rotate, animWidth, animHeight) {\n    const childIndex = textureIndex / this.texturesPerTilemap >> 0;\n    const textureId = textureIndex % this.texturesPerTilemap;\n    if (this.children[childIndex] && this.children[childIndex].getTileset().count > 0) {\n      this.lastModifiedTilemap = this.children[childIndex];\n      this.lastModifiedTilemap.addRect(\n        textureId,\n        u,\n        v,\n        x,\n        y,\n        tileWidth,\n        tileHeight,\n        animX,\n        animY,\n        rotate,\n        animWidth,\n        animHeight\n      );\n    } else {\n      this.lastModifiedTilemap = null;\n    }\n    return this;\n  }\n  /**\n   * @deprecated Since @pixi/tilemap 3.\n   * @readonly\n   * @see CompositeTilemap.texturesPerTilemap\n   */\n  get texPerChild() {\n    return this.texturesPerTilemap;\n  }\n}\n\nexport { CompositeTilemap };\n//# sourceMappingURL=CompositeTilemap.mjs.map\n","import { extensions } from 'pixi.js';\nimport { GlTilemapAdaptor } from './gl_tilemap.mjs';\nimport { GpuTilemapAdaptor } from './gpu_tilemap.mjs';\nimport { TilemapPipe } from './TilemapPipe.mjs';\nexport { TilemapAdaptor } from './TilemapPipe.mjs';\nexport { CompositeTilemap } from './CompositeTilemap.mjs';\nexport { Constant, settings } from './settings.mjs';\nexport { POINT_STRUCT_SIZE, Tilemap } from './Tilemap.mjs';\nexport { TilemapGeometry } from './TilemapGeometry.mjs';\n\nextensions.add(TilemapPipe);\nextensions.add(GlTilemapAdaptor);\nextensions.add(GpuTilemapAdaptor);\n\nexport { TilemapPipe };\n//# sourceMappingURL=index.mjs.map\n","export default __webpack_public_path__ + \"2fbc7eea66124eea4de8713cdccbd232.mp3\";","import { CollisionBody } from \"@components/physics/collisionbody\";\nexport class Exit extends CollisionBody {\n    constructor(e, x, y, w, h) {\n        super(e, x, y, w, h, 'exit', true);\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Platform } from \"@components/objects/Platform/Platform\";\nimport { Player } from \"@components/objects/Player/player\";\nimport { PhysicsEngine } from \"@components/physics/physics\";\nimport { Tilemap } from \"@pixi/tilemap\";\nimport { Container } from \"pixi.js\";\nimport spike from '../../assets/audio/spike.mp3';\nimport { Exit } from \"@components/objects/Exit/Exit\";\nimport { CollisionBody } from \"@components/physics/collisionbody\";\nexport class Scene {\n    constructor(data, spritesheet) {\n        this.view = new Container();\n        this.tilemap = new Tilemap(spritesheet.textureSource);\n        this.cols = data.cols;\n        this.rows = data.rows;\n        this.physicsEngine = new PhysicsEngine();\n        this.render(data, spritesheet);\n        this.view.addChild(this.tilemap);\n        this.buildPlatforms(data);\n        this.init(data);\n    }\n    init(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.player = yield Player.Create(this.physicsEngine);\n            this.player.view.x = data.player.x * 16;\n            this.player.view.y = data.player.y * 16;\n            this.player.collisionBody.onCollision((o, sides) => {\n                if (o.type === 'spike') {\n                    const spikeaudio = new Audio(spike);\n                    spikeaudio.play();\n                    this.player.lastDeath = 20;\n                    this.player.view.x = data.player.x * 16;\n                    this.player.view.y = data.player.y * 16;\n                    return;\n                }\n                console.log(o instanceof Exit);\n            });\n            this.view.addChild(this.player.view);\n        });\n    }\n    render(data, spritesheet) {\n        var _a;\n        const ids = [\"blank\", \"grass_top\", \"solid\", \"spike\", \"fence_left\",\n            \"fence_mid\", \"fence_right\", \"flower1\", \"flower2\", \"exit\",\n            \"left_wall\", \"top_wall\", \"right_wall\", \"rock\", \"blank_dot\"];\n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.cols; j++) {\n                let id = data.tiles[i * this.cols + j];\n                this.tilemap.tile(spritesheet.textures[(_a = ids[id]) !== null && _a !== void 0 ? _a : \"flower1\"], j * 16, i * 16);\n            }\n        }\n    }\n    buildPlatforms(data) {\n        if (!data.platforms)\n            return;\n        for (const { x, y, w, h } of data.platforms) {\n            this.buildPlatform(x * 16, y * 16, w * 16, h * 16);\n        }\n        for (const { x, y, w, h } of data.spikes) {\n            this.view.addChild(new CollisionBody(this.physicsEngine, x * 16, y * 16, w * 16, h * 16, 'spike').view);\n        }\n        if (!data.collisions)\n            return;\n        for (const { create, boxes } of data.collisions) {\n            for (const { x, y, w, h } of boxes) {\n                this.view.addChild(create(this.physicsEngine, { x: x * 16, y: y * 16, w: w * 16, h: h * 16 }).view);\n                console.log(\"Hello\");\n            }\n        }\n    }\n    buildPlatform(x, y, w, h) {\n        const platform = new Platform(this.physicsEngine, x, y, w, h);\n        this.view.addChild(platform.view);\n    }\n    update(deltaTime) {\n        this.physicsEngine.update(deltaTime);\n        this.player.update(deltaTime);\n    }\n}\n","import { CollisionBody } from \"@components/physics/collisionbody\";\nexport const sceneData0 = {\n    rows: 16,\n    cols: 32,\n    player: {\n        x: 3.5,\n        y: 12.8,\n    },\n    tiles: [\n        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        10, 0, 4, 5, 6, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 9,\n        2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1,\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    ],\n    platforms: [\n        { x: 0, y: 0, w: 32, h: 1 },\n        { x: 0, y: 1, w: 1, h: 13 },\n        { x: 31, y: 1, w: 1, h: 11 },\n        { x: 0, y: 14, w: 12, h: 1 },\n        { x: 14, y: 14, w: 4, h: 1 },\n        { x: 20, y: 14, w: 4, h: 1 },\n        { x: 26, y: 14, w: 6, h: 1 },\n    ],\n    spikes: [\n        { x: 12, y: 14, w: 2, h: 1 },\n        { x: 18, y: 14, w: 2, h: 1 },\n        { x: 24, y: 14, w: 2, h: 1 },\n    ],\n    collisions: [\n        {\n            create: (e, { x, y, w, h }) => new CollisionBody(e, x, y, w, h, 'exit', true),\n            boxes: [\n                { x: 31.5, y: 12, w: 1, h: 2 }\n            ]\n        }\n    ]\n};\n","import { CollisionBody } from \"@components/physics/collisionbody\";\nexport const sceneData1 = {\n    rows: 16,\n    cols: 32,\n    player: {\n        x: 3.5,\n        y: 12.8,\n    },\n    tiles: [\n        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 1, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 13, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 1, 1, 1, 0, 0, 2, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 2, 2, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 1, 1, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 1, 2, 2, 1, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        10, 0, 4, 5, 6, 0, 1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,\n        2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1,\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    ],\n    platforms: [\n        { x: 0, y: 0, w: 32, h: 1 },\n        { x: 0, y: 1, w: 1, h: 14 },\n        { x: 31, y: 1, w: 1, h: 11 },\n        { x: 1, y: 14, w: 5, h: 1 },\n        { x: 6, y: 13, w: 6, h: 2 },\n        { x: 7, y: 11, w: 4, h: 2 },\n        { x: 8, y: 4, w: 2, h: 7 },\n        { x: 9, y: 2, w: 1, h: 2 },\n        { x: 3, y: 9, w: 3, h: 1 },\n        { x: 4, y: 7, w: 1, h: 1 },\n        { x: 5, y: 5, w: 1, h: 1 },\n        { x: 12, y: 9, w: 1, h: 1 },\n        { x: 14, y: 8, w: 2, h: 1 },\n        { x: 18, y: 8, w: 1, h: 1 },\n        { x: 22, y: 8, w: 1, h: 1 },\n        { x: 20, y: 7, w: 1, h: 1 },\n        { x: 20, y: 7, w: 1, h: 1 },\n        { x: 16, y: 6, w: 1, h: 1 },\n        { x: 21, y: 6, w: 1, h: 1 },\n        { x: 23, y: 11, w: 3, h: 1 },\n        { x: 26, y: 10, w: 2, h: 1 },\n        { x: 16, y: 12, w: 1, h: 1 },\n        { x: 30, y: 14, w: 2, h: 1 },\n    ],\n    spikes: [\n        { x: 12, y: 14, w: 18, h: 1 }\n    ],\n    collisions: [\n        {\n            create: (e, { x, y, w, h }) => new CollisionBody(e, x, y, w, h, 'exit', true),\n            boxes: [\n                { x: 31.5, y: 12, w: 1, h: 2 }\n            ]\n        }\n    ]\n};\n","import { CollisionBody } from \"@components/physics/collisionbody\";\nexport const sceneData2 = {\n    rows: 16,\n    cols: 32,\n    player: {\n        x: 3.5,\n        y: 12.8,\n    },\n    tiles: [\n        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        10, 0, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,\n        2, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1,\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    ],\n    platforms: [\n        { x: 0, y: 0, w: 32, h: 1 },\n        { x: 0, y: 1, w: 1, h: 13 },\n        { x: 31, y: 1, w: 1, h: 11 },\n        { x: 0, y: 14, w: 6, h: 1 },\n        { x: 13, y: 13, w: 1, h: 1 },\n        { x: 19, y: 13, w: 1, h: 1 },\n        { x: 30, y: 14, w: 2, h: 1 },\n    ],\n    spikes: [\n        { x: 0, y: 14, w: 30, h: 1 }\n    ],\n    collisions: [\n        {\n            create: (e, { x, y, w, h }) => new CollisionBody(e, x, y, w, h, 'exit', true),\n            boxes: [\n                { x: 31.5, y: 12, w: 1, h: 2 }\n            ]\n        }\n    ]\n};\n","import { CollisionBody } from \"@components/physics/collisionbody\";\nexport const sceneData3 = {\n    rows: 16,\n    cols: 32,\n    player: {\n        x: 3.5,\n        y: 12.8,\n    },\n    tiles: [\n        11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 14, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 14, 2, 0, 0, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 3, 0, 2, 0, 2, 2, 0, 3, 0, 0, 0, 0, 0, 12,\n        10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 14, 0, 2, 0, 0, 0, 0, 0, 0,\n        10, 0, 4, 5, 6, 0, 0, 1, 0, 1, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 0, 0, 0, 0, 0, 9,\n        2, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 2, 3, 2, 3, 3, 3, 3, 1, 1,\n        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    ],\n    platforms: [\n        { x: 0, y: 0, w: 32, h: 1 },\n        { x: 0, y: 1, w: 1, h: 13 },\n        { x: 31, y: 1, w: 1, h: 11 },\n        { x: 0, y: 14, w: 6, h: 1 },\n        { x: 7, y: 13, w: 1, h: 1 },\n        { x: 9, y: 13, w: 1, h: 1 },\n        { x: 11, y: 11, w: 1, h: 1 },\n        { x: 8, y: 10, w: 2, h: 1 },\n        { x: 9, y: 9, w: 1, h: 1 },\n        { x: 7, y: 8, w: 1, h: 1 },\n        { x: 6, y: 7, w: 1, h: 1 },\n        { x: 4, y: 5, w: 1, h: 1 },\n        { x: 7, y: 3, w: 11, h: 1 },\n        { x: 14, y: 13, w: 1, h: 2 },\n        { x: 16, y: 12, w: 1, h: 3 },\n        { x: 18, y: 12, w: 1, h: 3 },\n        { x: 20, y: 11, w: 1, h: 4 },\n        { x: 22, y: 10, w: 1, h: 5 },\n        { x: 23, y: 9, w: 1, h: 6 },\n        { x: 25, y: 12, w: 1, h: 3 },\n        { x: 21, y: 6, w: 1, h: 1 },\n        { x: 19, y: 5, w: 1, h: 1 },\n        { x: 30, y: 14, w: 2, h: 1 },\n    ],\n    spikes: [\n        { x: 6, y: 14, w: 8, h: 1 },\n        { x: 6, y: 6, w: 1, h: 1 },\n        { x: 7, y: 7, w: 1, h: 1 },\n        { x: 15, y: 14, w: 1, h: 1 },\n        { x: 17, y: 14, w: 1, h: 1 },\n        { x: 19, y: 14, w: 1, h: 1 },\n        { x: 21, y: 14, w: 1, h: 1 },\n        { x: 24, y: 14, w: 1, h: 1 },\n        { x: 26, y: 14, w: 4, h: 1 },\n        { x: 14, y: 12, w: 1, h: 1 },\n        { x: 16, y: 11, w: 1, h: 1 },\n        { x: 18, y: 11, w: 1, h: 1 },\n        { x: 20, y: 10, w: 1, h: 1 },\n        { x: 22, y: 9, w: 1, h: 1 },\n        { x: 23, y: 8, w: 1, h: 1 },\n        { x: 21, y: 5, w: 1, h: 1 },\n        { x: 19, y: 4, w: 1, h: 1 },\n        { x: 25, y: 11, w: 1, h: 1 },\n    ],\n    collisions: [\n        {\n            create: (e, { x, y, w, h }) => new CollisionBody(e, x, y, w, h, 'exit', true),\n            boxes: [\n                { x: 31.5, y: 12, w: 1, h: 2 }\n            ]\n        }\n    ]\n};\n","import { Container, Text } from \"pixi.js\";\nexport class SceneManager {\n    constructor() {\n        this.view = new Container();\n        this.currentScene = -1;\n        this.scenes = [];\n        this.ids = {};\n    }\n    appendScene(id, scene) {\n        var _a;\n        if (((_a = this.ids) === null || _a === void 0 ? void 0 : _a[id]) !== undefined)\n            return false;\n        this.ids[id] = this.scenes.length;\n        this.scenes.push(scene);\n        if (this.currentScene === -1) {\n            this.currentScene = 0;\n            this.view.addChild(this.scenes[this.currentScene].view);\n        }\n        if (id === \"level_0\") {\n            const Title = new Text({\n                text: 'Pogo Parkour!',\n                style: {\n                    fontSize: 350,\n                    align: 'center',\n                },\n            });\n            const controls = new Text({\n                text: 'Use Left and Right to Move\\nSpace to jump\\nDown Arrow Key to Pogo on Spikes!',\n                style: {\n                    fontSize: 150,\n                    align: 'left',\n                },\n            });\n            Title.scale.set(0.1);\n            Title.x = scene.view.width / 6;\n            Title.y = scene.view.height / 8;\n            controls.x = scene.view.width / 6;\n            controls.y = scene.view.height / 3;\n            controls.scale.set(0.1);\n            scene.view.addChild(Title, controls);\n        }\n        return true;\n    }\n    attach() {\n        this.view.addChild(this.scenes[this.currentScene].view);\n    }\n    detatch() {\n        this.view.removeChild(this.scenes[this.currentScene].view);\n    }\n    setScene(id) {\n        const index = this.ids[id];\n        if (index === undefined)\n            return;\n        this.detatch();\n        this.currentScene = index;\n        this.attach();\n    }\n    nextScene() {\n        if (this.scenes.length === 0)\n            return;\n        this.detatch();\n        this.currentScene++;\n        this.currentScene %= this.scenes.length;\n        this.attach();\n    }\n    prevScene() {\n        if (this.scenes.length === 0)\n            return;\n        this.detatch();\n        this.currentScene += this.scenes.length - 1;\n        this.currentScene %= this.scenes.length;\n        this.attach();\n    }\n    getScene() {\n        if (this.currentScene < 0)\n            return undefined;\n        return this.scenes[this.currentScene];\n    }\n    update(deltaTime) {\n        var _a;\n        (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.update(deltaTime);\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { controller } from \"@components/controller/Controller\";\nimport { Application, Assets, Spritesheet, Texture } from \"pixi.js\";\nimport { atlasData } from \"./assets/atlas\";\nimport { Scenes } from \"@components/scenes/Scenes\";\nimport { SceneManager } from \"@components/scenes/SceneManager\";\ndocument.body.style.margin = '0'; // Removes margin around page\ndocument.body.style.overflow = 'hidden'; // Fix scrolling\n(() => __awaiter(void 0, void 0, void 0, function* () {\n    // Create a PixiJS application.\n    const app = new Application();\n    // Intialize the application.\n    yield app.init({ background: \"#1099bb\", resizeTo: window });\n    // Then adding the application's canvas to the DOM body.\n    document.body.appendChild(app.canvas);\n    Assets.add({ alias: 'characters', src: atlasData.characters.meta.image });\n    Assets.add({ alias: 'tiles', src: atlasData.tiles.meta.image });\n    const textures = yield Assets.load([{ alias: 'characters' }, { alias: 'tiles' }]);\n    textures.characters.source.scaleMode = 'nearest';\n    textures.tiles.source.scaleMode = 'nearest';\n    const tileSpriteSheet = new Spritesheet(Texture.from(atlasData.tiles.meta.image), atlasData.tiles);\n    yield tileSpriteSheet.parse();\n    const scenes = Scenes(tileSpriteSheet);\n    const sceneManager = new SceneManager();\n    for (const { id, scene } of scenes) {\n        sceneManager.appendScene(id, scene);\n    }\n    app.stage.addChild(sceneManager.view);\n    controller.attachKeyDownCallback(k => {\n        if (k === \"next\") {\n            sceneManager.nextScene();\n        }\n    });\n    app.ticker.add((ticker) => {\n        // Resize the scene\n        const scene = sceneManager.getScene();\n        const scaleX = app.renderer.width / (scene.cols * 16);\n        const scaleY = app.renderer.height / (scene.rows * 16);\n        const scale = Math.min(scaleX, scaleY);\n        scene.view.scale = scale;\n        // Apply updates\n        const deltaTime = ticker.deltaTime;\n        sceneManager.update(deltaTime);\n    });\n}))();\n","import { Scene } from \"./Scene\";\nimport { sceneData0 } from \"../../assets/scenes/scene0\";\nimport { sceneData1 } from \"../../assets/scenes/scene1\";\nimport { sceneData2 } from \"../../assets/scenes/scene2\";\nimport { sceneData3 } from \"../../assets/scenes/scene3\";\nexport const Scenes = (spritesheet) => [\n    { id: \"level_0\", scene: new Scene(sceneData0, spritesheet) },\n    { id: \"level_1\", scene: new Scene(sceneData1, spritesheet) },\n    { id: \"level_2\", scene: new Scene(sceneData2, spritesheet) },\n    { id: \"level_3\", scene: new Scene(sceneData3, spritesheet) },\n];\n"],"names":["inProgress","dataWebpackPrefix","earcut","data","holeIndices","dim","minX","minY","maxX","maxY","x","y","invSize","hasHoles","length","outerLen","outerNode","linkedList","triangles","next","prev","i","len","list","queue","steiner","push","getLeftmost","sort","compareX","eliminateHole","eliminateHoles","Math","max","earcutLinked","start","end","clockwise","last","signedArea","insertNode","equals","removeNode","filterPoints","again","p","area","ear","pass","z","zOrder","prevZ","nextZ","q","e","tail","numMerges","pSize","qSize","inSize","sortLinked","indexCurve","stop","isEarHashed","isEar","cureLocalIntersections","splitEarcut","a","b","c","ax","bx","cx","ay","by","cy","x0","y0","x1","y1","pointInTriangle","minZ","maxZ","n","intersects","locallyInside","isValidDiagonal","splitPolygon","hole","bridge","m","hx","hy","qx","tan","mx","my","tanMin","Infinity","abs","sectorContainsSector","findHoleBridge","bridgeReverse","leftmost","px","py","intersectsPolygon","inside","middleInside","r","p1","p2","q1","q2","o1","sign","o2","o3","o4","onSegment","min","num","a2","Node","b2","an","bp","this","sum","j","module","exports","deviation","polygonArea","trianglesArea","flatten","result","vertices","holes","dimensions","holeIndex","d","path","replace","segment","_","command","args","type","toLowerCase","numbers","match","number","map","Number","parseValues","concat","splice","unshift","Error","h","l","s","t","v","has","Object","prototype","hasOwnProperty","prefix","Events","EE","fn","context","once","addListener","emitter","event","TypeError","listener","evt","_events","_eventsCount","clearEvent","EventEmitter","create","__proto__","eventNames","events","name","names","call","slice","getOwnPropertySymbols","listeners","handlers","ee","Array","listenerCount","emit","a1","a3","a4","a5","arguments","removeListener","undefined","apply","on","removeAllListeners","off","prefixed","Cache","constructor","_parsers","_cache","Map","_cacheMap","reset","clear","key","get","set","value","keys","cacheableAssets","parsers","parser","test","getCacheableAssets","cacheableMap","entries","forEach","key2","cacheKeys","cachedAssets","val","remove","cacheMap","delete","LoaderParserPriority","LoaderParserPriority2","processX","base","ids","depth","tags","id","createStringVariations","string","vars","split","substring","Resolver","_defaultBundleIdentifierOptions","connector","createBundleAssetId","bundleId","assetId","_bundleIdConnector","extractAssetIdFromBundle","assetBundleId","_createBundleAssetId","_extractAssetIdFromBundle","_assetMap","_preferredOrder","_resolverHash","_bundles","setBundleIdentifier","bundleIdentifier","prefer","preferOrders","priority","params","basePath","_basePath","rootPath","_rootPath","_manifest","_defaultSearchParams","setDefaultSearchParams","searchParams","queryValues","encodeURIComponent","join","getAlias","asset","alias","src","convertToList","isArray","addManifest","manifest","warn","bundles","bundle","addBundle","assets","assetNames","convertedAssets","srcs","aliases","bundleAssetId","bundleIds","add","keyCheck","hasKey","format","loadParser","srcsToUse","src2","aliasesToUse","resolvedAssets","formattedAsset","parse","_buildResolvedAsset","resolveBundle","singleAsset","isSingleItem","out","results","resolve","resolveUrl","preferredOrder","_getPreferredOrder","priorityKey","filteredAssets","filter","hasBundle","preferred","find","preference","includes","_appendDefaultSearchParams","url","assetData","toAbsolute","pop","shift","RETINA_PREFIX","input","transform","forceTransform","item","copySearchParams","targetUrl","sourceUrl","grad","turn","rad","PI","pow","round","u","isFinite","g","o","toString","floor","f","exec","parseInt","substr","object","N","M","H","$","parsed","trim","rgba","isValid","brightness","isDark","isLight","toHex","toRgb","toRgbString","toHsl","toHslString","toHsv","invert","w","saturate","desaturate","grayscale","lighten","darken","rotate","hue","alpha","isEqual","S","indexOf","white","bisque","blue","cadetblue","chartreuse","chocolate","coral","antiquewhite","aqua","azure","whitesmoke","papayawhip","plum","blanchedalmond","black","gold","goldenrod","gainsboro","cornsilk","cornflowerblue","burlywood","aquamarine","beige","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkkhaki","darkgray","darkgreen","darkgrey","peachpuff","darkmagenta","darkred","darkorchid","darkorange","darkslateblue","gray","darkslategray","darkslategrey","deeppink","deepskyblue","wheat","firebrick","floralwhite","ghostwhite","darkviolet","magenta","green","dodgerblue","grey","honeydew","hotpink","blueviolet","forestgreen","lawngreen","indianred","indigo","fuchsia","brown","maroon","mediumblue","lightcoral","darkturquoise","lightcyan","ivory","lightyellow","lightsalmon","lightseagreen","linen","mediumaquamarine","lemonchiffon","lime","khaki","mediumseagreen","limegreen","mediumspringgreen","lightskyblue","lightblue","midnightblue","lightpink","mistyrose","moccasin","mintcream","lightslategray","lightslategrey","navajowhite","navy","mediumvioletred","powderblue","palegoldenrod","oldlace","paleturquoise","mediumturquoise","mediumorchid","rebeccapurple","lightsteelblue","mediumslateblue","thistle","orchid","mediumpurple","purple","pink","skyblue","springgreen","palegreen","red","yellow","slateblue","lavenderblush","peru","palevioletred","violet","teal","slategray","slategrey","aliceblue","darkseagreen","darkolivegreen","greenyellow","seagreen","seashell","tomato","silver","sienna","lavender","lightgreen","orange","orangered","steelblue","royalblue","turquoise","yellowgreen","salmon","saddlebrown","sandybrown","rosybrown","darksalmon","lightgoldenrodyellow","snow","lightgrey","lightgray","dimgray","dimgrey","olivedrab","olive","toName","closest","_Color","_value","_components","Float32Array","fill","_int","setValue","_cloneSource","_isSourceEqual","_normalize","ArrayBuffer","isView","value1","value2","type1","every","keys1","keys2","toRgba","toRgbaString","toUint8RgbArray","_arrayRgb","toArray","_arrayRgba","toRgbArray","toNumber","toBgrNumber","toLittleEndianNumber","multiply","_temp","_refreshInt","premultiply","applyToRGB","toPremultiplied","hexString","toHexa","alphaString","setAlpha","_clamp","Uint8Array","Uint8ClampedArray","HEX_PATTERN","color","isColorLike","shared","Color","currentAdapter","createCanvas","width","height","canvas","document","createElement","getCanvasRenderingContext2D","CanvasRenderingContext2D","getWebGLRenderingContext","WebGLRenderingContext","getNavigator","navigator","getBaseUrl","baseURI","window","location","href","getFontFaceSet","fonts","fetch","options","parseXML","xml","DOMParser","parseFromString","DOMAdapter","adapter","ExtensionType","ExtensionType2","normalizeExtension","ext","extension","ref","normalizeExtensionPriority","defaultPriority","extensions","_addHandlers","_removeHandlers","_queue","extensions2","handle","onAdd","onRemove","addHandlers","removeHandlers","handleByMap","handleByNamedList","findIndex","index","handleByList","FilterEffect","pipe","destroy","filters","filterArea","Matrix","tx","ty","array","fromArray","transpose","pos","newPos","applyInverse","translate","scale","angle","cos","sin","c1","tx1","append","matrix","b1","d1","appendFrom","c2","d2","setTransform","pivotX","pivotY","scaleX","scaleY","rotation","skewX","skewY","prepend","decompose","pivot","atan2","delta","skew","sqrt","position","isIdentity","identity","clone","copyTo","copyFrom","IDENTITY","identityMatrix","tempMatrix","ux","uy","vx","vy","rotationCayley","rotationMatrices","signum","row","_ux","_uy","_vx","_vy","k","mat","init","groupD8","E","SE","SW","W","NW","NE","MIRROR_VERTICAL","MAIN_DIAGONAL","MIRROR_HORIZONTAL","REVERSE_DIAGONAL","uX","ind","uY","vX","vY","inv","rotationSecond","rotationFirst","sub","rotate180","isVertical","byDirection","dx","dy","matrixAppendRotationInv","PI_2","RAD_TO_DEG","DEG_TO_RAD","nextPow2","isPow2","ObservablePoint","observer","_x","_y","_observer","_onUpdate","Point","tempPoint","tempPoints","Rectangle","left","right","top","bottom","isEmpty","EMPTY","copyFromBounds","bounds","rectangle","contains","strokeContains","strokeWidth","other","x02","y02","lt","lb","rt","rb","nx","ny","n00","n10","n01","n11","m00","m10","m01","m11","pad","paddingX","paddingY","fit","x2","y2","ceil","resolution","eps","enlarge","getBounds","fragTemplate","generateIfTestSrc","maxIfs","maxTexturesPerBatchCache","getMaxTexturesPerBatch","gl","getTestContext","getParameter","MAX_TEXTURE_IMAGE_UNITS","shader","createShader","FRAGMENT_SHADER","fragmentSrc","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","checkMaxIfStatementsInShader","getExtension","loseContext","cachedGroups","getTextureBatchBindGroup","textures","size","uid","imul","bindGroupResources","bindIndex","maxTextures","texture","source","style","bindGroup","generateTextureBatchBindGroup","BatchTextureArray","count","Batch","renderPipeId","action","blendMode","topology","canBundle","gpuBindGroup","batcher","batchPool","batchPoolIndex","getBatchFromPool","returnBatchToPool","batch","BATCH_TICK","_Batcher","dirty","batchIndex","batches","_elements","defaultOptions","attributesInitialSize","indicesInitialSize","attributeBuffer","ViewableBuffer","indexBuffer","Uint16Array","begin","elementSize","elementStart","indexSize","attributeSize","_batchIndexStart","_batchIndexSize","batchableObject","_indexStart","_attributeStart","_batcher","vertexSize","checkAndUpdateTexture","textureId","_batch","_source","_textureId","updateElement","packAsQuad","packQuadAttributes","float32View","uint32View","packAttributes","instructionSet","elements","textureBatch","firstElement","getAdjustedBlendModeBlend","_resizeAttributeBuffer","_resizeIndexBuffer","f32","u32","element","adjustedBlendMode","breakRequired","_batchTick","_finishBatch","_textureBindLocation","packQuadIndex","packIndex","indexStart","finish","break","ensureAttributeBuffer","ensureIndexBuffer","newSize","newArrayBuffer","fastCopy","rawBinaryData","newIndexBuffer","Uint32Array","BYTES_PER_ELEMENT","buffer","indicesOffset","indices","indexOffset","attributeOffset","Batcher","placeHolderBufferData","placeHolderIndexData","BatchGeometry","Geometry","Buffer","label","usage","VERTEX","COPY_DST","shrinkToFit","super","attributes","aPosition","stride","offset","aUV","aColor","aTextureIdAndRound","INDEX","DefaultShader","Shader","glProgram","bits","colorBit","generateTextureBatchBit","roundPixelsBit","gpuProgram","resources","batchSamplers","getBatchSamplersUniformGroup","defaultShader","_DefaultBatcher","geometry","textureIdAndRound","roundPixels","wt","positions","uvs","argb","i2","w0","w1","h0","h1","x3","y3","DefaultBatcher","addBits","srcParts","parts","part","toLocaleLowerCase","sanitisedPart","findHooksRx","compileHooks","programSrc","hook","extractInputs","fragmentSource","regex","compileInputs","fragments","template","fragment","header","mainInput","finalString","inValue","cleanedString","extractOutputs","injectBits","templateSrc","fragmentParts","bitCacheMap","CACHE_UID","compileHighShaderGl","cacheId","generateCacheId","compileBits","vertex","highFragment","vertexParts","shaderBit","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","vertexFragments","fragmentFragments","compiledVertex","mainStruct","mainStart","mainEnd","extractVariableName","compiledCode","compileOutputs","compileInputsAndOutputs","compileHighShader","GpuProgram","from","entryPoint","compileHighShaderGlProgram","GlProgram","main","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","bindingIndex","generateSampleSrc","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","roundPixelsBitGl","tempBounds","Bounds","addMaskBounds","mask","skipUpdateTransform","boundsToMask","measurable","getGlobalBounds","addBoundsMask","addMaskLocalBounds","localRoot","relativeMask","getMatrixRelativeToParent","getLocalBounds","return","target","root","parent","updateLocalTransform","localTransform","AlphaMask","inverse","renderMaskToTexture","Sprite","renderable","includeInBuild","addBounds","addLocalBounds","containsPoint","point","hitTestFn","MaskEffect","ColorMask","StencilMask","Container","VideoSource","ImageSource","CanvasSource","BufferImageSource","CLEAR","CLEAR2","maxFragmentPrecision","getMaxFragmentPrecision","getShaderPrecisionFormat","shaderFragment","HIGH_FLOAT","precision","fragmentNameCache","VertexNameCache","processes","stripVersion","isES300","ensurePrecision","isFragment","maxSupportedPrecision","maxSupportedFragmentPrecision","maxSupportedVertexPrecision","requestedFragmentPrecision","requestedVertexPrecision","addProgramDefines","setProgramName","nameCache","insertVersion","programCache","_GlProgram","preprocessorOptions","preferredFragmentPrecision","preferredVertexPrecision","processKey","processOptions","transformFeedbackVaryings","_key","createIdFromString","_attributeData","_uniformData","_uniformBlockData","batchSamplersUniformGroupHash","batchSamplersUniformGroup","sampleValues","Int32Array","uTextures","isStatic","isContextLost","getContext","BindGroup","_dirty","resource","setResource","_updateKey","keyParts","_resourceId","currentResource","onResourceChange","getResource","_touch","tick","_touched","destroyed","WGSL_TO_VERTEX_TYPES","vec2f","vec3f","vec4f","i32","bool","extractStructAndGroups","wgsl","groupPattern","bindingPattern","namePattern","typePattern","structMemberPattern","structName","groups","group","binding","isUniform","structs","struct","members","reduce","acc","member","name2","some","ShaderStage","ShaderStage2","_layoutKey","_attributeLocationsKey","layout","gpuLayout","structsAndGroups","vertexStructsAndGroups","fragmentStructsAndGroups","structNameSet","Set","dupeGroupKeySet","removeStructAndGroupDuplicates","generateLayoutHash","visibility","FRAGMENT","sampler","sampleType","viewDimension","multisampled","generateGpuLayoutGroups","autoAssignGlobalUniforms","globalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","bigKey","attributeData","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","getAttributeInfoFromFormat","instance","extractAttributesFromGpuProgram","_resourceType","_updateID","_dataInt32","_data","byteLength","mappedAtCreation","descriptor","setDataWithSize","dataInt32","static","STATIC","syncGPU","_updateSize","oldData","update","sizeInBytes","BufferUsage","BufferUsage2","sourceBuffer","destinationBuffer","lengthDouble","sourceFloat64View","Float64Array","remainingBytes","sourceUint8View","ensureIsBuffer","instanceCount","_bounds","_boundsDirty","buffers","addAttribute","addIndex","onBufferUpdate","getAttribute","getIndex","getBuffer","getSize","attribute","attributeOption","ensureIsAttribute","attributeId","byteSize","getGeometryBounds","destroyBuffers","attributeFormatData","uint8x2","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","_tick","InstructionSet","instructions","instructionSize","renderables","instruction","log","console","table","_uniformBindMap","_ownedBindGroups","compatibleRenderers","groupMap","WEBGPU","WEBGL","nameHash","uniformName","groupData","bindTick","_buildResourceAccessor","addResource","groupIndex","_a","_b","uniformsOut","defineProperty","destroyPrograms","gpu","rest","UNIFORM_TYPES_VALUES","UNIFORM_TYPES_MAP","getDefaultUniformValue","_UniformGroup","uniformStructures","isUniformGroup","_dirtyId","uniforms","uniformData","ubo","_signature","UniformGroup","blendModeIds","normal","screen","overlay","erase","_State","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","for2d","state","default2d","State","BLEND_TO_NPM","STENCIL_MODES","STENCIL_MODES2","textureSource","alphaMode","environments","Environment","defaultRunners","_AbstractRenderer","config","runners","renderPipes","_initOptions","_systemsHash","combinedRunners","_addRunners","_unsafeEvalCheck","skip","skipExtensionImports","manageImports","async","env","load","loadEnvironmentExtensions","_addSystems","systems","_addPipes","renderPipeAdaptors","systemName","_roundPixels","items","render","deprecated","container","deprecation","renderTexture","view","renderTarget","_lastObjectRendered","clearColor","background","colorRgba","isRGBAArray","enableRenderGroup","prerender","renderStart","renderEnd","postrender","resize","desiredScreenWidth","desiredScreenHeight","previousResolution","resolutionChange","ALL","frame","lastObjectRendered","renderingToScreen","runnerIds","runnerId","SystemRunner","_addSystem","ClassRef","system","pipes","pipeAdaptors","adaptors","adaptor","PipeClass","Adaptor","reverse","values","runner","generateTexture","textureGenerator","unsafeEvalSupported","failIfMajorPerformanceCaveat","AbstractRenderer","_name","a0","a6","a7","removeAll","empty","CanvasPool","canvasOptions","_canvasPool","enableFullScreen","_createCanvasAndContext","pixelWidth","pixelHeight","getOptimalCanvasAndContext","minWidth","minHeight","canvasAndContext","returnCanvasAndContext","clearRect","NOOP","Texture","orig","defaultAnchor","defaultBorders","dynamic","noFrame","isTexture","TextureSource","updateUvs","textureMatrix","_textureMatrix","TextureMatrix","nX","nY","nW","nH","w2","h2","cX","cY","destroySource","baseTexture","WHITE","tempMat","clampMargin","mapCoord","uClampFrame","uClampOffset","_textureID","clampOffset","isSimple","_texture","multiplyUvs","tex","texBase","margin","_resolution","TexturePool","textureOptions","_poolKeyHash","_texturePool","createTexture","antialias","autoGarbageCollect","getOptimalTexture","frameWidth","frameHeight","po2Width","po2Height","getSameSizeTexture","returnTexture","destroyTextures","idHash","_TextureStyle","_maxAnisotropy","addressMode","addressModeU","addressModeV","addressModeW","scaleMode","magFilter","minFilter","mipmapFilter","lodMinClamp","lodMaxClamp","compare","maxAnisotropy","wrapMode","_sharedResourceId","_generateResourceId","createResourceIdFromString","TextureStyle","Int16Array","Int8Array","uploadMethodId","autoDensity","resizeCanvas","transparent","didResize","globalThis","HTMLCanvasElement","OffscreenCanvas","context2D","_context2D","HTMLImageElement","drawImage","ImageBitmap","VideoFrame","_TextureSource","sampleCount","mipLevelCount","autoGenerateMipmaps","dimension","resourceWidth","resourceHeight","obj","definedProps","_refreshPOT","_style","_onStyleChange","repeatMode","unload","naturalWidth","videoWidth","displayWidth","naturalHeight","videoHeight","displayHeight","newPixelWidth","newPixelHeight","updateMipmaps","isPowerOfTwo","_resource","_VideoSource","isReady","_autoUpdate","_isConnectedToTicker","_updateFPS","updateFPS","_msToNextUpdate","autoPlay","_videoFrameRequestCallback","bind","_videoFrameRequestCallbackHandle","_load","_resolve","_reject","_onCanPlay","_onCanPlayThrough","_onError","_onPlayStart","_onPlayStop","_onSeeked","autoLoad","updateFrame","elapsedMS","playbackRate","requestVideoFrameCallback","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","complete","addEventListener","_isSourceReady","_mediaReady","preload","Promise","reject","preloadTimeoutMs","_preloadTimeout","setTimeout","ErrorEvent","removeEventListener","_isSourcePlaying","paused","ended","_configureAutoUpdate","clearTimeout","play","pause","autoUpdate","cancelVideoFrameCallback","HTMLVideoElement","crossorigin","loop","muted","playsinline","MIME_TYPES","ogv","mov","m4v","sources","textureSourceFrom","hasResource","res","opts","Source","skipCache","resourceToTexture","idCounts","groupId","RendererType","RendererType2","cacheAsTextureMixin","isCachedAsTexture","renderGroup","cacheAsTexture","disableRenderGroup","enableCacheAsTexture","updateCacheTexture","cacheAsBitmap","childrenHelperMixin","allowChildren","removeChildren","beginIndex","endIndex","children","range","removed","child","removeItems","parentRenderGroup","RangeError","removeChildAt","getChildAt","removeChild","setChildIndex","getChildIndex","addChildAt","currentIndex","didChange","_updateFlags","addChild","sortableChildren","sortDirty","swapChildren","child2","index1","index2","structureDidChange","_didContainerChangeTick","removeFromParent","reparentChild","reparentChildAt","childMat","worldTransform","newMatrix","setFromMatrix","MaskEffectManager","_effectClasses","_tests","_initialized","maskClass","getMaskEffect","returnMaskEffect","effect","effectsMixin","_maskEffect","_maskOptions","_filterEffect","effects","_markStructureAsChanged","addEffect","_updateIsSimple","removeEffect","setMask","hasFilters","freeze","findMixin","getChildByName","deep","getChildByLabel","RegExp","found","getChildrenByLabel","bgr2rgb","getGlobalMixin","getGlobalAlpha","skipUpdate","worldAlpha","current","getGlobalTransform","parentTransform","getGlobalTint","worldColor","multiplyColors","localColor","tint","checkChildrenDidChange","previousData","_didViewChangeTick","measureMixin","_localBoundsCacheId","_localBoundsCacheData","_setWidth","localWidth","_setHeight","localHeight","localBounds","localBoundsCacheData","onRenderMixin","_onRender","onRender","func","removeOnRender","addOnRender","sortMixin","_zIndex","zIndex","depthOfChildModified","sortChildren","toLocalGlobalMixin","getGlobalPosition","toGlobal","_position","globalMatrix","toLocal","RenderGroup","renderGroupParent","renderGroupChildren","worldColorAlpha","childrenToUpdate","updateTick","childrenRenderablesToUpdate","_onRenderContainers","textureNeedsUpdate","_matrixDirty","disableCacheAsTexture","childrenAtDepth","addRenderGroupChild","renderGroupChild","_removeRenderGroupChild","relativeRenderGroupDepth","onChildUpdate","updateRenderable","globalDisplayStatus","didViewUpdate","onChildViewUpdate","isRenderable","localDisplayStatus","runOnRender","getChildren","_getChildren","invalidateMatrices","inverseWorldTransform","_inverseWorldTransform","textureOffsetInverseTransform","_textureOffsetInverseTransform","_textureBounds","inverseParentTextureTransform","_inverseParentTextureTransform","parentCacheAsTexture","_parentCacheAsTextureRenderGroup","cacheToLocalTransform","defaultSkew","defaultPivot","defaultScale","UPDATE_COLOR","UPDATE_BLEND","UPDATE_VISIBLE","parentRenderGroupIndex","relativeGroupTransform","groupTransform","_scale","_pivot","_skew","_cx","_sx","_cy","_sy","_rotation","localAlpha","groupAlpha","groupColor","groupColorAlpha","localBlendMode","groupBlendMode","_didLocalTransformChangeId","ignore","assignWithIgnore","mixin","defineProperties","getOwnPropertyDescriptors","_didChangeId","_updateSkew","isRenderGroup","_worldTransform","setSize","updateTransform","localTransformChangeId","sx","sy","bgr","visible","valueNumber","culled","oldChildren","cullArea","cullable","cullableChildren","defaultMatrix","_rectangle","addFrame","addRect","rect","applyMatrix","fitBounds","isPositive","addVertexData","vertexData","beginOffset","endOffset","localX","localY","pooledMatrix","updateTransformBackwards","_getGlobalBounds","parentBounds","preserveBounds","boundsArea","relativeMatrix","_getLocalBounds","rootContainer","isRoot","relativeTransform","matrixPool","boundsPool","WHITE_BGR","localBGRColor","parentBGRColor","multiplyHexColors","color1","color2","BatchableGraphics","batcherName","applyTransform","geometryData","rgb","baseColor","gpuBuffer","Graphics","_context","_ownedContext","onViewUpdate","updateBounds","_callContextMethod","method","setFillStyle","setStrokeStyle","stroke","beginPath","cut","arc","arcTo","arcToSvg","bezierCurveTo","closePath","ellipse","circle","lineTo","moveTo","quadraticCurveTo","roundRect","poly","regularPoly","roundPoly","roundShape","filletRect","chamferRect","star","svg","restore","save","getTransform","resetTransform","rotateTransform","scaleTransform","translateTransform","fillStyle","strokeStyle","lineStyle","beginFill","endFill","defaultStrokeStyle","drawCircle","drawEllipse","drawPolygon","drawRect","drawRoundedRect","drawStar","Circle","radius","r2","distance","Ellipse","halfWidth","halfHeight","normx","normy","halfStrokeWidth","innerA","innerB","outerA","outerB","normalizedX","normalizedY","squaredDistanceToLineSegment","lenSq","xx","yy","param","Polygon","points","flat","il","polygon","xi","yi","xj","yj","halfStrokeWidthSqrd","iterationLength","pointsDesc","currentPoint","lastX","lastY","isCornerWithinStroke","pX","pY","cornerX","cornerY","RoundedRectangle","radius2","innerX","innerY","rightBound","bottomBound","FLT_EPSILON","buildAdaptiveBezier","sX","sY","cp1x","cp1y","cp2x","cp2y","eX","eY","smoothness","distanceTolerance","GraphicsContextSystem","bezierSmoothness","recursive","x4","y4","level","x12","y12","x23","y23","x34","y34","x123","y123","x234","y234","x1234","y1234","d3","buildAdaptiveQuadratic","buildArc","steps","dist","TAU","centerX","centerY","ang1","ang2","mapToEllipse","rx","ry","cosPhi","sinPhi","out2","xp","yp","approxUnitArc","vectorAngle","dot","acos","tempRectangle","ShapePath","graphicsPath2D","shapePrimitives","_currentPoly","_graphicsPath2D","startPoly","_ensurePoly","fromX","fromY","startAngle","endAngle","counterclockwise","mm","dd","cc","tt","k1","k2","j1","j2","qy","buildArcTo","xAxisRotation","largeArcFlag","sweepFlag","pxp","pyp","lambda","rxSq","rySq","pxpSq","pypSq","radicant","centerXp","centerYp","vx1","vy1","vx2","vy2","getArcCenter","ratio","segments","outCurvePoint","curve","buildArcToSvg","currentPoly","smoothing","endPoly","addPath","drawShape","close","sides","corner","sideLength","internalAngle","useQuadratic","pointLerp","numPoints","thisPoint","pRadius","lastPoint","nextPoint","lastEdgeLength","nextEdgeLength","roundedShapeQuadraticCurve","vecFrom","pp","sharpCorner","p3","v1","v2","asin","radDirection","drawDirection","halfAngle","cRadius","lenOut","roundedShapeArc","fillet","maxFillet","inset","dir","chamfer","radiusX","radiusY","shape","lastShape","lx","ly","tempX","buildPath","shapePrimitive","boundsRect","GraphicsPath","svgPath","commands","subpaths","currentSubPath","bezierCurveToShort","quadraticCurveToShort","startX","startY","SVGToGraphicsPath","shapePath","_shapePath","getLastPoint","currentX","currentY","cpx1","cpy1","innerRadius","newGraphicsPath2D","cpx2","cpy2","adjustTransform","lastInstruction","currentMatrix","SVGParser","graphicsContext","div","innerHTML","querySelector","renderChildren","session","f1","s1","useFill","useStroke","styleParts","stylePart","parseFloatAttribute","parseStyle","pointsString","graphicsPath","nodeName","info","defaultValue","tmpPoint","_GraphicsContext","batchMode","_activePath","_transform","_fillStyle","defaultFillStyle","_strokeStyle","_stateStack","dw","dh","image","onUpdate","_initNextPathLocation","holePath","transformedX","transformedY","cpx","cpy","alignment","padding","hasHit","shapes","transformedPoint","holeShapes","destroyTextureSource","customShader","miterLimit","cap","pixelLine","GraphicsContext","transformVertices","buildCircle","ShapeBuilder","build","roundedRect","j3","j4","y22","x22","triangulate","verticesStride","verticesOffset","centerIndex","buildEllipse","buildRoundedRectangle","closePointEps","square","innerWeight","outerWeight","verts","exx","eyy","eix","eiy","eox","eoy","ex","ey","cx2p0x","cy2p0y","angle0","angle1","angleDiff","absAngleDiff","segCount","angleInc","triangulateWithHoles","emptyArray","buildPolygon","buildRectangle","rectData","verticesIndex","buildTriangle","shapeBuilders","tempRect","addTextureToGeometryData","vertOffset","textureUvs","graphicsBatch","addShapePathToGeometryData","isStroke","lastIndex","closed","fx","fy","buildPixelLine","flipAlignment","orientation","getOrientationOfPoints","firstPoint","closedShape","closedPath","midPointX","midPointY","indexCount","widthSquared","miterLimitSquared","perpX","perpY","perp1x","perp1y","dx0","dy0","dx1","dy1","cross","pDist","imx","imy","omx","omy","insideWeight","curveEps","buildLine","otherPoints","holeArrays","holePrimitives","holePrimitive","holePoints","getHoleArrays","uvsOffset","uvsStride","buildUvs","buildSimpleUvs","GpuGraphicsContext","GraphicsContextRenderData","_GraphicsContextSystem","renderer","_gpuContextHash","_graphicsDataContextHash","renderableGC","addManagedHash","getContextRenderData","_initContextRenderData","updateGpuContext","gpuContext","_initContext","_cleanGraphicsContextData","buildContextBatches","isBatchable","getGpuContext","graphicsData","drawBatches","onGraphicsContextDestroy","WebGLSystem","WebGPUSystem","CanvasSystem","_FillGradient","gradientStops","_styleKey","addColorStop","buildLinearGradient","defaultSize","defaultTextureSize","ctx","gradient","createLinearGradient","fillRect","styleKey","stops","FillGradient","repetitionMap","repeat","FillPattern","repetition","isFillPattern","isFillGradient","handleFillPattern","defaultStyle","handleFillGradient","toFillStyle","objectStyle","temp","handleColorLike","sourceStyle","handleFillObject","toStrokeStyle","anchor","batched","_visualBounds","_anchor","currentTexture","_width","_height","visualBounds","sourceBounds","AbstractBitmapFont","chars","lineHeight","fontFamily","fontMetrics","fontSize","ascent","descent","baseLineOffset","distanceField","pages","applyFillAsTint","baseMeasurementFontSize","baseRenderedFontSize","font","pageTextures","distanceFieldRange","distanceFieldType","page","resolveCharacters","startCode","charCodeAt","endCode","String","fromCharCode","_DynamicBitmapFont","_padding","_measureCache","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","_textureSize","textureSize","_mipmap","mipmap","overrideFill","_fill","requestedFontSize","fontStringFromTextStyle","overrideSize","_stroke","skipKerning","CanvasTextMetrics","measureFont","ensureCharacters","charList","char","self","pageData","_nextPage","fontScale","maxCharHeight","skipTexture","maxTextureWidth","maxTextureHeight","metrics","measureText","paddedWidth","fontStyle","paddedHeight","pageData2","xAdvance","dropShadow","codePointAt","xOffset","yOffset","kerning","_drawGlyph","_applyKerning","newChars","measureCache","first","second","total","amount","textureResolution","_setupContext","textBaseline","strokeThickness","lineWidth","lineJoin","getCanvasFillStyle","shadowOptions","dropShadowBlur","blur","dropShadowDistance","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","text","fontProperties","strokeText","fillText","TextStyle","DynamicBitmapFont","fontCount","BitmapFontManager","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","getFont","fontFamilyKey","lastIndexOf","fnt","dynamicFont","getLayout","trimEnd","bitmapFont","getBitmapTextLayout","install","textStyle","flatChars","uninstall","cacheKey","layoutData","offsetY","lines","charPositions","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","nextLine","lastChar","adjustedLetterSpacing","letterSpacing","adjustedWordWrapWidth","wordWrapWidth","isEnd","charData","wordWrap","nextCharWidth","align","measurementData","line","alignCenter","alignRight","indy","spaceIndex","totalSpaces","alignJustify","_TextStyle","oldStyle","defaults","defaultDropShadow","dropShadowAlpha","dropShadowAngle","dropShadowColor","fillGradientStops","defaultTextStyle","gradientFill","fills","convertV7Tov8Style","fullStyle","_align","breakWords","_breakWords","_dropShadow","_createProxy","_fontFamily","_fontSize","_fontStyle","fontVariant","_fontVariant","fontWeight","_fontWeight","leading","_leading","_letterSpacing","_lineHeight","_trim","_textBaseline","whiteSpace","_whiteSpace","_wordWrap","_wordWrapWidth","_originalFill","_isFillStyle","_originalStroke","_generateKey","cb","Proxy","property","newValue","contextSettings","willReadFrequently","_CanvasTextMetrics","experimentalLetterSpacingSupported","_experimentalLetterSpacingSupported","proto","lineWidths","maxLineWidth","_canvas","textKey","_measurementCache","__context","_measureText","useExperimentalLetterSpacing","experimentalLetterSpacing","textLetterSpacing","metricWidth","actualBoundingBoxLeft","boundsWidth","actualBoundingBoxRight","graphemeSegmenter","cache","collapseSpaces","_collapseSpaces","collapseNewlines","_collapseNewlines","canPrependSpaces","tokens","_tokenize","token","_isNewline","_addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","_getFromCache","canBreakWords","characters","wordWrapSplit","nextChar","canBreakChars","characterWidth","isLastToken","newLine","_trimRight","_newlines","_nextChar","_breakingSpaces","_token","_char","_index","_fonts","METRICS_STRING","BASELINE_SYMBOL","properties","actualBoundingBoxAscent","actualBoundingBoxDescent","clearMetrics","__canvas","BASELINE_MULTIPLIER","HEIGHT_MULTIPLIER","Intl","Segmenter","segmenter","genericFontFamilies","fontSizeString","fontFamilies","pattern","createPattern","fillPattern","fillGradient","valuesToIterateForKeys","generateTextStyleKey","prop","addFillStyleKey","addStokeStyleKey","addDropShadowKey","ViewContainer","_lastUsed","_lastInstructionTick","_Spritesheet","linkedSheets","animations","metaResolution","parseFloat","meta","_frames","frames","_frameKeys","_batchIndex","_callback","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","sourceSize","trimmed","rotated","spriteSourceSize","borders","animName","frameName","callback","destroyBase","Spritesheet","validImages","ignoreMultiPack","dirname","related_multi_packs","assign","spritesheetAsset","Asset","resolver","ResolveParser","loader","LoadParser","LoaderParser","Normal","extname","imageTexture","imageFilename","imagePath","spritesheet","multiPacks","promises","itemUrl","all","sp","_resolvedAsset","_sourceOrigin","TickerListener","previous","_destroyed","_fn","_once","ticker","redirect","connect","hard","_Ticker","autoStart","deltaTime","lastTime","speed","started","_requestId","_maxElapsedMS","_minElapsedMS","_protected","_lastFrame","_head","deltaMS","targetFPMS","time","requestAnimationFrame","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","NORMAL","_addListener","addOnce","currentTime","head","FPS","minFPS","fps","maxFPS","minFPMS","_shared","_system","Ticker","UPDATE_PRIORITY","UPDATE_PRIORITY2","promise","detectVideoAlphaMode","video","video2","onloadeddata","onerror","autoplay","crossOrigin","bindTexture","TEXTURE_2D","framebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","texImage2D","RGBA","UNSIGNED_BYTE","pixel","readPixels","deleteFramebuffer","deleteTexture","unsafeEval","Function","_e","VERSION","sizeOrBuffer","int8View","_int8View","uint8View","_uint8View","int16View","_int16View","int32View","_int32View","float64View","_float64Array","bigUint64View","_bigUint64Array","BigUint64Array","uint16View","sizeOf","arr","startIdx","removeCount","uidCache","default","updateQuadBounds","sourceWidth","sourceHeight","ApplicationInitHook","__PIXI_APP_INIT__","Application","RendererInitHook","_renderer","__PIXI_RENDERER_INIT__","warnings","v8_0_0","v8_3_4","version","message","ignoreDepth","stack","groupCollapsed","groupEnd","warnCount","maxWarnings","assertPath","path2","JSON","stringify","removeUrlParams","toPosix","isUrl","isDataUrl","isBlobUrl","startsWith","hasProtocol","getProtocol","matchFile","matchProtocol","customBaseUrl","customRootUrl","baseUrl","rootUrl","rootname","isAbsolute","normalize","protocol","trailingSeparator","endsWith","lastSegmentLength","lastSlash","dots","code","lastSlashIndex","normalizeStringPosix","joined","arg","prevArg","joinExtensions","hasRoot","matchedSlash","origpath","basename","extIdx","firstNonSlashEnd","startDot","startPart","preDotState","ret","sep","delimiter","Pool","ClassType","initialSize","_pool","_count","_classType","prepopulate","totalSize","totalFree","totalUsed","BigPool","_poolsByClass","Class","getPool","stats","pool","ID","free","used","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","definition","enumerable","chunkId","done","script","needAttach","scripts","getElementsByTagName","charset","timeout","nc","setAttribute","onScriptComplete","onload","doneFns","parentNode","appendChild","Symbol","toStringTag","installedChunks","installedChunkData","error","errorType","realSrc","request","webpackJsonpCallback","parentChunkLoadingFunction","chunkIds","moreModules","runtime","chunkLoadingGlobal","Space","KeyW","ArrowUp","KeyA","ArrowLeft","KeyS","ArrowDown","KeyD","ArrowRight","KeyN","dblTapDelayMs","delay","space","pressed","doubleTap","timestamp","up","down","keyUpCallbacks","keyDownCallbacks","ev","keydownHandler","keyupHandler","attachKeyUpCallback","attachKeyDownCallback","Date","WorkerGlobalScope","requestAdapter","requestDevice","_Application","stage","RendererClass","finalOptions","rendererType","WebGPURenderer","webgpu","contextOptions","stencil","success","getContextAttributes","WebGLRenderer","webgl","_plugins","plugin","rendererDestroyOptions","plugins","textureFrame","frameReal","txt","rawData","common","kernings","attributeList","itemData","strValue","floatValue","isNaN","distanceRange","fieldType","face","file","charNode","letter","xoffset","yoffset","xadvance","CacheParser","bitmapFontData","textureUrls","pageFile","loadedTextures","_options","response","verbose","_loader","_assetList","_isLoading","_maxConcurrent","assetUrls","_isActive","_next","toLoad","toLoadAmount","active","imageData","Image","blob","createImageBitmap","DetectionParser","formats","mimeType","canPlayType","_parsersValidated","promiseCache","_getLoadPromiseAndParser","_parserHash","parserX","parser2","testParse","assetsToLoadIn","onProgress","_validateParsers","assetsToLoad","assetsToUnloadIn","loadPromise","loadedAsset","hash","mimes","mime","tempURL","Low","json","fontFaces","family","nameTokens","charAt","toUpperCase","valid","fontFamilyName","weights","weight","FontFace","uri","encodeURI","parseAsGraphicsContext","svgSource","blobUrl","URL","createObjectURL","decode","revokeObjectURL","_p","Blob","worker","Worker","_createdWorkers","_workerPool","_resolveHash","isImageBitmapSupported","_isImageBitmapSupported","terminate","loadImageBitmap","_run","_initWorkers","_getWorker","hardwareConcurrency","_complete","_returnWorker","uuid","toDo","postMessage","High","preferWorkers","preferCreateImageBitmap","ok","status","statusText","imageBlob","premultiplyAlpha","isValidDataUrl","isValidExtension","videoElement","attributeMap","loc","parsedUrl","hostname","port","sourceElement","onCanPlay","loaded","cleanup","err","_detections","_backgroundLoader","defaultSearchParams","resolutionPref","texturePreference","_detectFormats","preferredFormats","skipDetections","detections","preferences","setPreferences","urls","urlArray","resolveResults","_mapLoadToResolve","loadBundle","_onProgress","resolveResult","then","resolveResult2","backgroundLoad","backgroundLoadBundle","resolveArray","loadedAssets","_unloadFromResolved","unloadBundle","detection","firstFrame","_textures","_durations","animationSpeed","updateAnchor","onComplete","onFrameChange","onLoop","_currentTime","_playing","_previousFrame","HIGH","gotoAndStop","frameNumber","currentFrame","gotoAndPlay","elapsed","previousFrame","lag","_updateTexture","fromFrames","fromImages","images","totalFrames","playing","styleClass","_autoResolution","_didTextUpdate","_styleClass","_text","_getKey","owner","canvasMeasurement","player_walk_0","player_walk_1","player_walk_2","player_walk_3","player_jump_0","player_jump_1","player_jump_2","player_slash_0","player_slash_1","player_slash_2","player_slash_3","player_slash_4","playerWalk","playerJump","playerSlash","tiles","blank","grass_top","solid","spike","fence_left","fence_mid","fence_right","flower1","flower2","exit","left_wall","top_wall","right_wall","rock","blank_dot","engine","trigger","callbacks","colliders","isColliding","pcTopBottom","collisionCallback","onCollision","setAnimation","selected","setFrame","_listeners","hasEventListener","listenerArray","dispatchEvent","d0","random","isVector2","setScalar","scalar","setX","setY","setComponent","getComponent","copy","addScalar","addVectors","addScaledVector","subScalar","subVectors","multiplyScalar","divide","divideScalar","applyMatrix3","clamp","clampScalar","minVal","maxVal","clampLength","roundToZero","trunc","negate","lengthSq","manhattanLength","angleTo","denominator","theta","distanceTo","distanceToSquared","manhattanDistanceTo","setLength","lerp","lerpVectors","fromBufferAttribute","getX","getY","rotateAround","center","iterator","n12","n13","n21","n22","n23","n31","n32","n33","isMatrix3","te","me","extractBasis","xAxis","yAxis","zAxis","setFromMatrix3Column","setFromMatrix4","multiplyMatrices","ae","be","a11","a12","a13","a21","a22","a23","a31","a32","a33","b11","b12","b13","b21","b22","b23","b31","b32","b33","determinant","t11","t12","t13","det","detInv","tmp","getNormalMatrix","matrix4","transposeIntoArray","setUvTransform","makeScale","makeRotation","makeTranslation","createElementNS","ColorManagement","enabled","workingColorSpace","spaces","convert","sourceColorSpace","targetColorSpace","transfer","primaries","toXYZ","fromXYZ","fromWorkingColorSpace","toWorkingColorSpace","getPrimaries","colorSpace","getTransfer","getLuminanceCoefficients","luminanceCoefficients","define","colorSpaces","_getMatrix","targetMatrix","_getDrawingBufferColorSpace","outputColorSpaceConfig","drawingBufferColorSpace","_getUnpackColorSpace","workingColorSpaceConfig","unpackColorSpace","REC709_PRIMARIES","REC709_LUMINANCE_COEFFICIENTS","D65","whitePoint","getDataURL","ImageData","putImageData","toDataURL","sRGBToLinear","getImageData","isSource","dataReady","needsUpdate","toJSON","isRootObject","output","isDataTexture","DEFAULT_IMAGE","mapping","DEFAULT_MAPPING","wrapS","wrapT","anisotropy","DEFAULT_ANISOTROPY","mipmaps","channel","internalFormat","matrixAutoUpdate","generateMipmaps","flipY","unpackAlignment","userData","isRenderTargetTexture","pmremVersion","updateMatrix","metadata","generator","wrap","dispose","transformUv","uv","needsPMREMUpdate","isQuaternion","_z","_w","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","z0","z1","sqrSin","EPSILON","tDir","multiplyQuaternionsFlat","_onChangeCallback","quaternion","setFromEuler","euler","order","_order","c3","s2","s3","setFromAxisAngle","axis","setFromRotationMatrix","m12","m13","m21","m22","m23","m31","m32","m33","trace","setFromUnitVectors","vFrom","vTo","rotateTowards","step","slerp","conjugate","multiplyQuaternions","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","qb","cosHalfTheta","sqrSinHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","slerpQuaternions","qa","theta1","theta2","r1","getZ","getW","_onChange","isVector3","setZ","multiplyVectors","applyEuler","applyQuaternion","applyAxisAngle","applyNormalMatrix","applyMatrix4","vz","qz","qw","tz","project","camera","matrixWorldInverse","projectionMatrix","unproject","projectionMatrixInverse","matrixWorld","transformDirection","crossVectors","az","bz","projectOnVector","projectOnPlane","planeNormal","reflect","dz","setFromSpherical","setFromSphericalCoords","phi","sinPhiRadius","setFromCylindrical","setFromCylindricalCoords","setFromMatrixPosition","setFromMatrixScale","setFromMatrixColumn","sz","setFromColor","randomDirection","n14","n24","n34","n41","n42","n43","n44","isMatrix4","copyPosition","setFromMatrix3","makeBasis","extractRotation","scaleZ","makeRotationFromEuler","af","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","compose","lookAt","eye","a14","a24","a34","a41","a42","a43","a44","b14","b24","b34","b41","b42","b43","b44","setPosition","t14","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","makeShear","xy","xz","yx","yz","zx","zy","z2","zz","wx","wy","wz","invSX","invSY","invSZ","makePerspective","near","far","coordinateSystem","makeOrthographic","zInv","DEFAULT_ORDER","isEuler","setFromQuaternion","setFromVector3","reorder","newOrder","enable","enableAll","toggle","disable","disableAll","layers","isEnabled","isObject3D","DEFAULT_UP","configurable","modelViewMatrix","normalMatrix","DEFAULT_MATRIX_AUTO_UPDATE","matrixWorldAutoUpdate","DEFAULT_MATRIX_WORLD_AUTO_UPDATE","matrixWorldNeedsUpdate","castShadow","receiveShadow","frustumCulled","renderOrder","onBeforeShadow","onAfterShadow","onBeforeRender","onAfterRender","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","rotateOnWorldAxis","rotateX","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","vector","updateWorldMatrix","worldToLocal","isCamera","attach","getObjectById","getObjectByProperty","getObjectByName","getObjectsByProperty","getWorldPosition","getWorldQuaternion","getWorldScale","getWorldDirection","raycast","traverse","traverseVisible","traverseAncestors","updateMatrixWorld","force","updateParents","updateChildren","geometries","materials","skeletons","nodes","serialize","library","isInstancedMesh","instanceMatrix","instanceColor","isBatchedMesh","perObjectFrustumCulled","sortObjects","drawRanges","_drawRanges","reservedRanges","_reservedRanges","_visibility","_active","bound","boxInitialized","boxMin","box","boxMax","sphereInitialized","sphereRadius","sphere","sphereCenter","maxInstanceCount","_maxInstanceCount","maxVertexCount","_maxVertexCount","maxIndexCount","_maxIndexCount","geometryInitialized","_geometryInitialized","geometryCount","_geometryCount","matricesTexture","_matricesTexture","_colorsTexture","colorsTexture","boundingSphere","boundingBox","isScene","isColor","environment","isMesh","isLine","isPoints","parameters","isSkinnedMesh","bindMode","bindMatrix","skeleton","material","uuids","animation","extractFromCache","setHex","setStyle","setRGB","hex","setHSL","handleAlpha","components","setColorName","copySRGBToLinear","copyLinearToSRGB","convertSRGBToLinear","convertLinearToSRGB","getHex","getHexString","getHSL","saturation","lightness","getRGB","getStyle","toFixed","offsetHSL","addColors","lerpColors","lerpHSL","forceClone","NAMES","parameterPositions","sampleSize","resultBuffer","_cachedIndex","valueSize","settings","DefaultSettings_","evaluate","i1","t1","t0","validate_interval","seek","linear_scan","forward_scan","giveUpAt","copySampleValue_","t1global","mid","intervalChanged_","interpolate_","getSettings_","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o0","oP","oN","wP","wN","ppp","sP","s0","sN","offset1","offset0","weight1","weight0","times","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","track","trackType","getInterpolation","ValueTypeName","InterpolantFactoryMethodDiscrete","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","createInterpolant","timeOffset","timeScale","startTime","endTime","nKeys","to","validate","prevTime","currTime","DataView","optimize","smoothInterpolation","writeIndex","keep","offsetP","offsetN","readOffset","writeOffset","TypedKeyframeTrack","rootNode","parsedPath","parseTrackName","node","findNode","getValue","_getValue_unbound","_setValue_unbound","isAnimationObjectGroup","Composite","sanitizeNodeName","trackName","matches","objectName","objectIndex","propertyName","propertyIndex","lastDot","bone","getBoneByName","searchNodeSubtree","childNode","subTreeNode","_getValue_unavailable","_setValue_unavailable","_getValue_direct","targetObject","_getValue_array","resolvedProperty","_getValue_arrayElement","_getValue_toArray","_setValue_direct","_setValue_direct_setNeedsUpdate","_setValue_direct_setMatrixWorldNeedsUpdate","_setValue_array","dest","_setValue_array_setNeedsUpdate","_setValue_array_setMatrixWorldNeedsUpdate","_setValue_arrayElement","_setValue_arrayElement_setNeedsUpdate","_setValue_arrayElement_setMatrixWorldNeedsUpdate","_setValue_fromArray","_setValue_fromArray_setNeedsUpdate","_setValue_fromArray_setMatrixWorldNeedsUpdate","targetArray","sourceArray","bones","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","morphAttributes","morphTargetDictionary","ArrayElement","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","targetGroup","optionalParsedPath","_targetGroup","_bindings","subscribe_","firstValidIndex","nCachedObjects_","bindings","__THREE_DEVTOOLS__","CustomEvent","detail","revision","__THREE__","collision","bodies","mass","gravity","onGround","registerCollisionBody","pcLeftRight","body","sidesA","sidesB","playerView","swordView","controller","playerAnimations","collisionBody","physicsBody","swordAnimations","swordCollider","swordCooldownMax","swordCooldown","slash","jumpEnd","jumping","jumpHeight","jumpLanded","lastDeath","jumpStart","Audio","Create","thisArg","_arguments","characterSpriteSheet","walk","jump","sword","P","fulfilled","rejected","writable","_TilemapGeometry","buf","aVertexPosition","aTextureCoord","aFrame","aAnim","aTextureId","aAnimDivisor","aAlpha","vertSize","vertPerQuad","u_proj_trans","u_anim_frame","checkIndexBuffer","createVb","geom","lastTimeAccess","getShader","totalIndices","ibLen","outBuffer","destroyRenderable","_renderable","vb","addRenderable","tilemap","updateBuffer","checkValid","getTileset","is_valid","_instruction","_instructionSet","validateRenderable","execute","pipe_uniforms","u_global","_activeUniforms","at","anim_frame","tileAnim","uProjectionMatrix","uWorldTransformMatrix","compositeParent","WebGLPipes","WebGPUPipes","max_textures","tex_sizes","tex_buf","UNIFORM","dirty_gpu","null_color","markDirty","getBindGroup","bind_group","bind_group_resources","u_texture_size","u_null_color","generate_gpu_textures","generate_gl_textures","gl_gen_resources","samplerSize","u_textures","_shader","tileset","tu","texture_uniforms","encoder","draw","rects_count","WebGLPipesAdaptor","ut","WebGPUPipesAdaptor","POINT_STRUCT2","setTileset","pointsBuf","textureOrArray","ts","flag","tilemapBounds","hasAnimatedTile","tile","tileTexture","textureIndex","was_num","textureList","tileWidth","tileHeight","animX","animY","animCountX","animCountY","animDivisor","pb","tileRotate","tileAnimX","tileAnimY","tileAnimDivisor","divisor","tileAlpha","destroyVb","vbId","vbBuffer","vertexBuf","vs","bk","vbArray","vbInts","ints","animXEncoded","animYEncoded","u0","v0","u1","u2","u3","v3","isModified","anim","clearModify","cols","rows","physicsEngine","buildPlatforms","player","platforms","buildPlatform","spikes","collisions","boxes","platform","currentScene","scenes","appendScene","scene","Title","controls","detatch","setScene","nextScene","prevScene","getScene","overflow","app","resizeTo","tileSpriteSheet","sceneManager"],"sourceRoot":""}